[[ch04_keys_addresses]]
== 金鑰與地址

Alice 想要支付給 Bob，但成千上萬個將驗證她交易的比特幣完整節點並不知道 Alice 或 Bob 是誰——而我們希望保持這種狀態以保護他們的隱私。Alice 需要向 Bob 傳達他應該收到她的一些比特幣，而不將該交易的任何方面與 Bob 的真實身份或 Bob 收到的其他比特幣支付連結起來。Alice 使用的方法必須確保只有 Bob 能夠進一步花費他收到的比特幣。

原始的比特幣白皮書描述了一個非常簡單的方案來實現這些目標，如 <<pay-to-pure-pubkey>> 所示。

[[pay-to-pure-pubkey]]
.原始比特幣白皮書中的交易鏈
image::images/mbc3_aain01.png["原始比特幣白皮書中的交易鏈"]

像 Bob 這樣的接收者在一筆交易中接受比特幣到一個公鑰，該交易由支付者（如 Alice）簽署。Alice 正在花費的比特幣之前已經被接收到她的一個公鑰，她使用相應的私鑰來生成她的簽章。完整節點可以驗證 Alice 的簽章承諾了一個雜湊函數的輸出，該函數本身承諾了 Bob 的公鑰和其他交易細節。

我們將在本章中探討公鑰、私鑰、簽章和雜湊函數，然後將它們一起使用來描述現代比特幣軟體使用的地址。

=== 公鑰密碼學

公鑰密碼學（public key cryptography）是在 1970 年代發明的，是現代計算機和資訊安全的數學基礎。

自從公鑰密碼學發明以來，已經發現了幾個合適的數學函數，例如質數指數運算和橢圓曲線乘法。這些數學函數在一個方向上很容易計算，但在相反方向上使用當今可用的計算機和演算法進行計算是不可行的。基於這些數學函數，密碼學能夠創建無法偽造的數位簽章。比特幣使用橢圓曲線加法和乘法作為其密碼學的基礎。

在比特幣中，我們可以使用公鑰密碼學來創建一個金鑰對（key pair），用於控制對比特幣的存取。金鑰對由私鑰和從私鑰衍生的公鑰組成。公鑰用於接收資金，私鑰用於簽署交易以花費資金。

公鑰和私鑰之間存在數學關係，允許私鑰用於生成訊息的簽章。這些簽章可以在不洩露私鑰的情況下針對公鑰進行驗證。

[TIP]
====
在某些錢包實作中，私鑰和公鑰作為一個金鑰對（key pair）一起儲存以方便使用。然而，公鑰可以從私鑰計算出來，因此僅儲存私鑰也是可能的。
====

比特幣錢包包含一組金鑰對，每個金鑰對由一個私鑰和一個公鑰組成。私鑰（_k_）是一個數字，通常從隨機選擇的數字衍生而來。從私鑰開始，我們使用橢圓曲線乘法，一種單向密碼函數，來生成公鑰（_K_）。

[role="less_space pagebreak-before"]
.為什麼使用非對稱密碼學（公鑰/私鑰）？
****
為什麼在比特幣中使用非對稱密碼學？它不是用來「加密」（保密）交易的。相反，非對稱密碼學的一個有用特性是能夠生成數位簽章（digital signatures）。私鑰可以應用於交易以產生數值簽章。這個簽章只能由知道私鑰的人產生。然而，任何能存取公鑰和交易的人都可以使用它們來驗證（verify）簽章。這種非對稱密碼學的有用特性使得任何人都可以驗證每筆交易上的每個簽章，同時確保只有私鑰的擁有者才能產生有效的簽章。
****

[[private_keys]]
==== 私鑰

私鑰（private key）只是一個數字，隨機選取。對私鑰的控制是使用者對與相應比特幣公鑰關聯的所有資金控制的根源。私鑰用於創建簽章，這些簽章用於透過證明對交易中使用的資金的控制來花費比特幣。私鑰必須始終保密，因為向第三方洩露它等同於讓他們控制由該金鑰保護的比特幣。私鑰也必須備份並防止意外丟失，因為如果丟失了，它就無法恢復，而由它保護的資金也將永遠丟失。

[TIP]
====
比特幣私鑰只是一個數字。您可以使用硬幣、鉛筆和紙張隨機選擇您的私鑰：擲硬幣 256 次，您就有了一個隨機私鑰的二進位數字，可以在比特幣錢包中使用。然後可以從私鑰生成公鑰。但要小心，任何不完全隨機的過程都可能大大降低您私鑰的安全性以及它控制的比特幣的安全性。
====

生成金鑰的第一步也是最重要的步驟是找到一個安全的隨機性來源（計算機科學家稱之為熵（entropy））。創建比特幣金鑰幾乎與「在 1 和 2^256^ 之間選擇一個數字」相同。您用來選擇該數字的確切方法並不重要，只要它不可預測或不可重複。比特幣軟體使用密碼學安全的隨機數生成器來產生 256 位元的熵。

[role="less_space pagebreak-before"]
更準確地說，私鑰可以是 0 和 _n_ - 1（包括）之間的任何數字，其中 _n_ 是一個常數（_n_ = 1.1578 × 10^77^，略小於 2^256^），定義為比特幣中使用的橢圓曲線的階數（參見 <<elliptic_curve>>）。要創建這樣的金鑰，我們隨機選擇一個 256 位元的數字並檢查它是否小於 _n_。在程式設計術語中，這通常透過將從密碼學安全的隨機性來源收集的較大隨機位元字串餵送到 SHA256 雜湊演算法中來實現，該演算法將方便地產生一個 256 位元的值，可以解釋為數字。如果結果小於 _n_，我們就有了一個合適的私鑰。否則，我們只需再次嘗試另一個隨機數。

[WARNING]
====
不要自己編寫程式碼來創建隨機數，或使用程式語言提供的「簡單」隨機數生成器。使用密碼學安全的偽隨機數生成器（CSPRNG），其種子來自具有足夠熵的來源。研究您選擇的隨機數生成器函式庫的文件，以確保它是密碼學安全的。正確實作 CSPRNG 對金鑰的安全性至關重要。
====

以下是一個隨機生成的私鑰（_k_），以十六進位格式顯示（256 位元顯示為 64 個十六進位數字，每個 4 位元）：

----
1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD
----

[TIP]
====
比特幣私鑰空間的大小（2^256^）是一個難以想像的大數字。它在十進位中大約是 10^77^。相比之下，可見宇宙估計包含 10^80^ 個原子。
====

[[elliptic_curve]]
==== 橢圓曲線密碼學解釋

橢圓曲線密碼學（Elliptic Curve Cryptography, ECC）是一種非對稱或公鑰密碼學，基於離散對數問題，透過橢圓曲線上點的加法和乘法來表達。

<<ecc-curve>> 是橢圓曲線的範例，類似於比特幣使用的曲線。

[[ecc-curve]]
[role="width-50"]
.橢圓曲線
image::images/mbc3_0402.png["橢圓曲線"]

比特幣使用特定的橢圓曲線和一組數學常數，如由美國國家標準與技術研究院（NIST）建立的標準 +secp256k1+ 中所定義。+secp256k1+ 曲線由以下函數定義，產生一條橢圓曲線：

[latexmath]
++++
\begin{equation}
{y^2 = (x^3 + 7)}~\text{over}~(\mathbb{F}_p)
\end{equation}
++++

或

[latexmath]
++++
\begin{equation}
{y^2 \mod p = (x^3 + 7) \mod p}
\end{equation}
++++

_mod p_（模質數 _p_）表示這條曲線在質數階 _p_ 的有限域上，也寫作 latexmath:[\(\mathbb{F}_p\)]，其中 _p_ = 2^256^ – 2^32^ – 2^9^ – 2^8^ – 2^7^ – 2^6^ – 2^4^ – 1，一個非常大的質數。

因為這條曲線定義在質數階的有限域上而不是在實數上，它看起來像分散在二維空間中的點的圖案，這使得它難以視覺化。然而，數學運算與實數上的橢圓曲線相同。作為範例，<<ecc-over-F17-math>> 顯示了在質數階 17 的小得多的有限域上的同一條橢圓曲線，在網格上顯示點的圖案。+secp256k1+ 比特幣橢圓曲線可以被認為是在難以想像的大網格上更複雜的點圖案。

[[ecc-over-F17-math]]
.橢圓曲線密碼學：在 F(p) 上視覺化橢圓曲線，其中 p=17
image::images/mbc3_0403.png["橢圓曲線密碼學"]

例如，以下是座標為 (x, y) 的點 P，它是 +secp256k1+ 曲線上的一個點：

[source, python]
----
P =
(55066263022277343669578718895168534326250603453777594175500187360389116729240,
32670510020758816978083085130507043184471273380659243275938904335757337482424)
----

<<example_4_1>> 顯示了如何使用 Python 自己驗證這一點。

[[example_4_1]]
.使用 Python 確認此點在橢圓曲線上
====
[source, pycon]
----
Python 3.10.6 (main, Nov 14 2022, 16:10:14) [GCC 11.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
> x = 55066263022277343669578718895168534326250603453777594175500187360389116729240
> y = 32670510020758816978083085130507043184471273380659243275938904335757337482424
> (x ** 3 + 7 - y**2) % p
0
----
====

[role="less_space pagebreak-before"]
在橢圓曲線數學中，有一個稱為「無窮遠點」的點，大致對應於加法中零的角色。在計算機上，它有時表示為 x = y = 0（這不滿足橢圓曲線方程式，但它是一個可以檢查的簡單特殊情況）。

還有一個 pass:[+] 運算子，稱為「加法」，具有一些類似於小學生學習的傳統實數加法的屬性。給定橢圓曲線上的兩點 P~1~ 和 P~2~，有第三點 P~3~ = P~1~ + P~2~，也在橢圓曲線上。

幾何上，這第三點 P~3~ 的計算方法是在 P~1~ 和 P~2~ 之間畫一條線。這條線將在恰好一個額外的地方與橢圓曲線相交。稱這個點為 P~3~' = (x, y)。然後在 x 軸上反射以得到 P~3~ = (x, –y)。

有幾個特殊情況解釋了「無窮遠點」的需要。

如果 P~1~ 和 P~2~ 是同一點，P~1~ 和 P~2~ 之間的線應該延伸為此點 P~1~ 處曲線的切線。這條切線將恰好在一個新點與曲線相交。您可以使用微積分的技術來確定切線的斜率。這些技術奇怪地有效，即使我們將興趣限制在具有兩個整數座標的曲線上的點！

在某些情況下（即，如果 P~1~ 和 P~2~ 具有相同的 x 值但不同的 y 值），切線將完全垂直，在這種情況下 P~3~ = 「無窮遠點」。

如果 P~1~ 是「無窮遠點」，則 P~1~ + P~2~ = P~2~。同樣，如果 P~2~ 是無窮遠點，則 P~1~ + P~2~ = P~1~。這顯示了無窮遠點如何扮演零的角色。

事實證明，pass:[+] 是結合的，這意味著（A pass:[+] B）pass:[+] C = A pass:[+]（B pass:[+] C）。這意味著我們可以寫 A pass:[+] B pass:[+] C 而不需要括號且沒有歧義。

現在我們已經定義了加法，我們可以用擴展加法的標準方式定義乘法。對於橢圓曲線上的點 P，如果 k 是整數，則 kP = P + P + P + ... + P（k 次）。請注意，在這種情況下，k 有時令人困惑地被稱為「指數」。

[[public_key_derivation]]
==== 公鑰

公鑰（public key）是使用橢圓曲線乘法從私鑰計算出來的，這是不可逆的：_K_ = _k_ × _G_，其中 _k_ 是私鑰，_G_ 是稱為生成點（generator point）的常數點，_K_ 是結果公鑰。反向操作，稱為「尋找離散對數」——如果您知道 _K_ 則計算 _k_——與嘗試所有可能的 _k_ 值（即暴力搜尋）一樣困難。在我們演示如何從私鑰生成公鑰之前，讓我們更詳細地看一下橢圓曲線密碼學。

[TIP]
====
橢圓曲線乘法是密碼學家稱為「陷阱門」函數的一種函數類型：在一個方向（乘法）上很容易做到，但在相反方向（除法）上不可能做到。擁有私鑰的人可以輕鬆創建公鑰，然後與世界分享它，知道沒有人可以反轉該函數並從公鑰計算私鑰。這個數學技巧成為無法偽造和安全的數位簽章的基礎，這些簽章證明了對比特幣資金的控制。
====

從隨機生成的數字 _k_ 形式的私鑰開始，我們將其乘以曲線上的預定點，稱為生成點（generator point）_G_，以在曲線上的某個其他地方產生另一個點，即相應的公鑰 _K_。生成點被指定為 +secp256k1+ 標準的一部分，並且對於比特幣中的所有金鑰始終相同：

[latexmath]
++++
\begin{equation}
{K = k \times G}
\end{equation}
++++

其中 _k_ 是私鑰，_G_ 是生成點，_K_ 是結果公鑰，曲線上的一個點。因為生成點對於所有比特幣使用者始終相同，私鑰 _k_ 乘以 _G_ 將始終產生相同的公鑰 _K_。_k_ 和 _K_ 之間的關係是固定的，但只能在一個方向上計算，從 _k_ 到 _K_。這就是為什麼比特幣公鑰（_K_）可以與任何人共享而不會洩露使用者的私鑰（_k_）。

[TIP]
====
私鑰可以轉換為公鑰，但公鑰不能轉換回私鑰，因為數學運算只在一個方向上有效。
====

實作橢圓曲線乘法，我們取之前生成的私鑰 _k_ 並將其乘以生成點 _G_ 以找到公鑰 _K_：

[source, python]
----
K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD × G
----

公鑰 _K_ 被定義為點 _K_ = (_x_, _y_)：

[latexmath]
++++
\begin{equation}
K = (x, y)
\end{equation}
++++


其中，

----
x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
----



要視覺化點乘以整數，我們將使用實數上更簡單的橢圓曲線——記住，數學運算是相同的。我們的目標是找到生成點 _G_ 的倍數 _kG_，這與將 _G_ 加到自己，連續 _k_ 次相同。在橢圓曲線中，將一個點加到自己等同於在該點上畫一條切線並找到它再次與曲線相交的位置，然後在 x 軸上反射該點。

<<ecc_illustrated>> 將衍生 _G_、_2G_、_4G_ 的過程顯示為曲線上的幾何操作。

[TIP]
====
許多比特幣實作使用 https://oreil.ly/wD60m[libsecp256k1 密碼函式庫] 來進行橢圓曲線數學運算。
====

[[ecc_illustrated]]
.橢圓曲線密碼學：在橢圓曲線上視覺化點 G 乘以整數 k
image::images/mbc3_0404.png["橢圓曲線密碼學"]

=== 輸出和輸入腳本

雖然原始比特幣白皮書的插圖（<<pay-to-pure-pubkey>>）顯示直接使用公鑰（pubkeys）和簽章（sigs），但比特幣的第一個版本實際上是將支付發送到稱為輸出腳本（output script）的欄位，並透過稱為輸入腳本（input script）的欄位授權花費這些比特幣。這些欄位允許除了（或代替）驗證簽章與公鑰對應之外執行額外的操作。例如，輸出腳本可以包含兩個公鑰並要求在支出輸入腳本中放置兩個相應的簽章。

稍後，在 <<tx_script>> 中，我們將詳細學習腳本。現在，我們只需要理解比特幣被接收到一個輸出腳本，該腳本的作用類似於公鑰，而比特幣支出由輸入腳本授權，該腳本的作用類似於簽章。

[[p2pk]]
=== IP 地址：比特幣的原始地址（P2PK）

我們已經確定 Alice 可以透過將她的一些比特幣分配給 Bob 的一個公鑰來支付 Bob。但是 Alice 如何獲得 Bob 的一個公鑰呢？Bob 可以直接給她一個副本，但讓我們再看一下我們在 <<public_key_derivation>> 中使用的公鑰。請注意它相當長。想像一下 Bob 試圖透過電話向 Alice 讀取它：

----
x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
----


比特幣軟體的最早版本不是直接輸入公鑰，而是允許支付者輸入接收者的 IP 地址，如 <<bitcoin_01_send>> 所示。這個功能後來被移除了——使用 IP 地址有很多問題——但對它的快速描述將幫助我們更好地理解為什麼某些功能可能已被新增到比特幣協定中。

[[bitcoin_01_send]]
.透過 https://oreil.ly/IDV1a[網際網路檔案館] 查看早期比特幣的發送畫面
image::images/mbc3_0405.png["早期比特幣的發送畫面"]

如果 Alice 在 Bitcoin 0.1 中輸入了 Bob 的 IP 地址，她的完整節點將與他的完整節點建立連線，並從 Bob 的錢包接收一個新的公鑰，該公鑰他的節點以前從未給過任何人。這是一個新的公鑰很重要，以確保支付 Bob 的不同交易不能被某人透過查看區塊鏈並注意到所有交易都支付相同的公鑰而連結在一起。

使用她的節點從 Bob 的節點接收的公鑰，Alice 的錢包將構建一個支付非常簡單的輸出腳本的交易輸出：

----
<Bob 的公鑰> OP_CHECKSIG
----

Bob 稍後將能夠使用完全由他的簽章組成的輸入腳本花費該輸出：

----
<Bob 的簽章>
----

要弄清楚輸出和輸入腳本在做什麼，您可以將它們組合在一起（輸入腳本在前），然後注意每個資料片段（以尖括號顯示）被放置在項目清單的頂部，稱為堆疊（stack）。當遇到操作碼（opcode）時，它從堆疊中使用項目，從最頂部的項目開始。讓我們從組合的腳本開始看看它是如何工作的：

----
<Bob 的簽章> <Bob 的公鑰> OP_CHECKSIG
----

對於此腳本，Bob 的簽章被放在堆疊上，然後 Bob 的公鑰被放在它的頂部。+OP_CHECKSIG+ 操作消耗兩個元素，從公鑰開始，然後是簽章，將它們從堆疊中移除。它驗證簽章對應於公鑰，並且還承諾（簽署）交易中的各個欄位。如果簽章正確，+OP_CHECKSIG+ 在堆疊上用值 1 替換自己；如果簽章不正確，它用 0 替換自己。如果在評估結束時堆疊頂部有一個非零項目，腳本就通過了。如果交易中的所有腳本都通過，並且關於交易的所有其他細節都有效，那麼完整節點將認為該交易有效。

簡而言之，前面的腳本使用了原始白皮書中描述的相同公鑰和簽章，但增加了兩個腳本欄位和一個操作碼的複雜性。這在這裡似乎是額外的工作，但當我們查看下一節時，我們將開始看到好處。

這種輸出類型今天被稱為支付到公鑰（pay to public key），或簡稱 P2PK。它從未被廣泛用於支付，而且幾乎十年來沒有廣泛使用的程式支援 IP 地址支付。

[[addresses_for_p2pkh]]
=== P2PKH 的傳統地址

輸入您想要支付的人的 IP 地址有許多優點，但也有許多缺點。一個特別的缺點是接收者需要他們的錢包在他們的 IP 地址上線上，並且需要從外部世界可存取。對於很多人來說，這不是一個選項。他們在晚上關閉計算機，他們的筆記型電腦進入睡眠狀態，他們位於防火牆後面，或者他們使用網路位址轉換（NAT）。

這讓我們回到像 Bob 這樣的接收者必須向像 Alice 這樣的支付者提供長公鑰的問題。早期比特幣開發者已知的最短版本的比特幣公鑰是 65 位元組，當以十六進位書寫時相當於 130 個字元。然而，比特幣已經包含了幾個資料結構，遠大於 65 位元組，需要在比特幣的其他部分使用最小量的安全資料進行安全引用。

比特幣透過雜湊函數（hash function）來實現這一點，雜湊函數是一種函數，它接受可能大量的資料，對其進行加擾（雜湊），並輸出固定量的資料。密碼雜湊函數在給定相同輸入時將始終產生相同的輸出，並且安全函數還將使某人無法選擇產生先前看到的輸出的不同輸入。這使得輸出成為對輸入的承諾（commitment）。這是一個承諾，實際上只有輸入 _x_ 會產生輸出 _X_。

例如，想像我想問您一個問題，並以您無法立即閱讀的形式給您我的答案。假設問題是「中本聰是哪一年開始研究比特幣的？」我將以 SHA256 雜湊函數輸出的形式給您我答案的承諾，這是比特幣中最常用的函數：

----
94d7a772612c8f2f2ec609d41f5bd3d04a5aa1dfe3582f04af517d396a302e4e
----

稍後，在您告訴我您對問題答案的猜測之後，我可以揭示我的答案並向您證明我的答案作為雜湊函數的輸入，產生與我之前給您的完全相同的輸出：

----
$ echo "2007.  He said about a year and a half before Oct 2008" | sha256sum
94d7a772612c8f2f2ec609d41f5bd3d04a5aa1dfe3582f04af517d396a302e4e
----

現在想像我們問 Bob 這個問題：「您的公鑰是什麼？」Bob 可以使用雜湊函數給我們一個對他公鑰的密碼學安全承諾。如果他後來揭示他的金鑰，我們驗證它產生與他之前給我們的相同承諾，我們可以確定這是用於創建該早期承諾的完全相同的金鑰。

SHA256 雜湊函數被認為非常安全，並產生 256 位元（32 位元組）的輸出，不到原始比特幣公鑰大小的一半。然而，還有其他稍微不太安全的雜湊函數，產生更小的輸出，例如 RIPEMD-160 雜湊函數，其輸出為 160 位元（20 位元組）。出於中本聰從未說明的原因，原始版本的比特幣透過首先使用 SHA256 雜湊金鑰，然後使用 RIPEMD-160 雜湊該輸出來對公鑰進行承諾；這產生了對公鑰的 20 位元組承諾。

[role="less_space pagebreak-before"]
我們可以從演算法上看這個過程。從公鑰 _K_ 開始，我們計算 SHA256 雜湊，然後計算結果的 RIPEMD-160 雜湊，產生一個 160 位元（20 位元組）的數字：

[latexmath]
++++
\begin{equation}
{A = RIPEMD160(SHA256(K))}
\end{equation}
++++

其中 _K_ 是公鑰，_A_ 是結果承諾。

現在我們了解了如何對公鑰進行承諾，我們需要弄清楚如何在交易中使用它。考慮以下輸出腳本：

----
OP_DUP OP_HASH160 <Bob 的承諾> OP_EQUAL OP_CHECKSIG
----

以及以下輸入腳本：

----
<Bob 的簽章> <Bob 的公鑰>
----

它們一起形成以下腳本：

----
<sig> <pubkey> OP_DUP OP_HASH160 <commitment> OP_EQUALVERIFY OP_CHECKSIG
----

正如我們在 <<p2pk>> 中所做的，我們開始將項目放在堆疊上。Bob 的簽章首先放入；然後將他的公鑰放在堆疊的頂部。+OP_DUP+ 操作複製頂部項目，因此堆疊上的頂部和次頂部項目現在都是 Bob 的公鑰。+OP_HASH160+ 操作消耗（移除）頂部公鑰並用使用 +RIPEMD160(SHA256(K))+ 雜湊它的結果替換它，因此現在堆疊的頂部是 Bob 公鑰的雜湊。接下來，對 Bob 公鑰的承諾被新增到堆疊的頂部。+OP_EQUALVERIFY+ 操作消耗頂部兩個項目並驗證它們相等；如果 Bob 在輸入腳本中提供的公鑰與用於創建 Alice 支付的輸出腳本中承諾的公鑰相同，則應該如此。如果 +OP_EQUALVERIFY+ 失敗，整個腳本就失敗了。最後，我們剩下一個僅包含 Bob 簽章和他的公鑰的堆疊；+OP_CHECKSIG+ 操作碼驗證它們彼此對應，並且簽章承諾交易。

雖然這個支付到公鑰雜湊（pay to public key hash, P2PKH）的過程可能看起來複雜，但它允許 Alice 對 Bob 的支付僅包含對他公鑰的 20 位元組承諾，而不是金鑰本身，在原始版本的比特幣中金鑰本來是 65 位元組。對於 Bob 必須向 Alice 傳達的資料來說，這要少得多。

然而，我們還沒有討論 Bob 如何將這 20 個位元組從他的比特幣錢包傳遞到 Alice 的錢包。有常用的位元組值編碼，例如十六進位，但複製承諾時犯的任何錯誤都會導致比特幣被發送到無法花費的輸出，導致它們永遠丟失。在下一節中，我們將研究緊湊編碼和可靠的檢查和。

[[base58]]
=== Base58check 編碼

為了以緊湊的方式表示長數字，使用更少的符號，許多計算機系統使用基數（或進位）高於 10 的混合字母數字表示。例如，傳統的十進位系統使用 10 個數字，0 到 9，而十六進位系統使用 16 個，字母 A 到 F 作為六個額外的符號。以十六進位格式表示的數字比等效的十進位表示更短。更緊湊的 base64 表示使用 26 個小寫字母、26 個大寫字母、10 個數字，以及 2 個更多的字元，例如「+」和「/」，以透過基於文字的媒體（如電子郵件）傳輸二進位資料。

Base58 是與 base64 類似的編碼，使用大寫和小寫字母以及數字，但省略了一些經常相互誤認且在某些字體中顯示時可能看起來相同的字元。具體來說，base58 是 base64 去掉 0（數字零）、O（大寫 o）、l（小寫 L）、I（大寫 i）以及符號「+」和「/」。或者更簡單地說，它是一組小寫和大寫字母以及數字，但沒有剛才提到的四個字元（0、O、l、I）。<<base58alphabet>> 顯示了完整的 base58 字母表。

[[base58alphabet]]
.比特幣的 base58 字母表
====
----
123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
----
====

為了增加對打字錯誤或抄寫錯誤的額外安全性，base58check 包含一個以 base58 字母表編碼的檢查和（checksum）。檢查和是新增到正在編碼的資料末尾的額外四個位元組。檢查和源自編碼資料的雜湊，因此可用於偵測抄寫和打字錯誤。當呈現 base58check 程式碼時，解碼軟體將計算資料的檢查和並將其與程式碼中包含的檢查和進行比較。如果兩者不匹配，則引入了錯誤，base58check 資料無效。這防止了錯誤輸入的比特幣地址被錢包軟體接受為有效目的地，否則會導致資金損失。

要將資料（數字）轉換為 base58check 格式，我們首先向資料新增一個前綴，稱為「版本位元組」（version byte），用於輕鬆識別編碼的資料類型。例如，前綴零（十六進位的 0x00）表示資料應用作傳統 P2PKH 輸出腳本中的承諾（雜湊）。<<base58check_versions>> 顯示了常見版本前綴的清單。

接下來，我們計算「雙 SHA」檢查和，這意味著我們對前一個結果（前綴與資料串接）應用兩次 SHA256 雜湊演算法：

----
checksum = SHA256(SHA256(prefix||data))
----

從產生的 32 位元組雜湊（雜湊的雜湊）中，我們僅取前四個位元組。這四個位元組用作錯誤檢查碼或檢查和。檢查和被附加到末尾。

結果由三個項目組成：前綴、資料和檢查和。此結果使用先前描述的 base58 字母表進行編碼。<<base58check_encoding>> 說明了 base58check 編碼過程。

[[base58check_encoding]]
.Base58check 編碼：一種 base58、帶版本和檢查和的格式，用於明確編碼比特幣資料
image::images/mbc3_0406.png["Base58checkEncoding"]

++++
<p class="fix_tracking2">
在比特幣中，除了公鑰承諾之外的其他資料也以 base58check 編碼向使用者呈現，以使該資料緊湊、易於閱讀和易於偵測錯誤。base58check 編碼中的版本前綴用於創建易於區分的格式，當以 base58 編碼時，在 base58check 編碼有效載荷的開頭包含特定字元。這些字元使人類易於識別編碼的資料類型以及如何使用它。這就是例如以 1 開頭的 base58check 編碼比特幣地址與以 5 開頭的 base58check 編碼私鑰錢包匯入格式（WIF）之間的區別。一些範例版本前綴和產生的 base58 字元顯示在
<a data-type="xref" href="#base58check_versions">#base58check_versions</a>。
</p>
++++

++++
<table id="base58check_versions">
<caption>Base58check 版本前綴和編碼結果範例</caption>
<thead>
<tr>
<th>類型</th>
<th>版本前綴（十六進位）</th>
<th>Base58 結果前綴</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>支付到公鑰雜湊（P2PKH）的地址</p></td>
<td><p>0x00</p></td>
<td><p>1</p></td>
</tr>
<tr>
<td><p>支付到腳本雜湊（P2SH）的地址</p></td>
<td><p>0x05</p></td>
<td><p>3</p></td>
</tr>
<tr>
<td><p>測試網路 P2PKH 地址</p></td>
<td><p>0x6F</p></td>
<td><p>m 或 n</p></td>
</tr>
<tr>
<td><p>測試網路 P2SH 地址</p></td>
<td><p>0xC4</p></td>
<td><p>2</p></td>
</tr>
<tr>
<td><p>私鑰 WIF</p></td>
<td><p>0x80</p></td>
<td><p>5、K 或 L</p></td>
</tr>
<tr>
<td><p>BIP32 擴展公鑰</p></td>
<td><p>0x0488B21E</p></td>
<td><p>xpub</p></td>
</tr>
</tbody>
</table>
++++

結合公鑰、基於雜湊的承諾和 base58check 編碼，<<pubkey_to_address>> 說明了公鑰轉換為比特幣地址的過程。

[[pubkey_to_address]]
.公鑰到比特幣地址：公鑰轉換為比特幣地址
image::images/mbc3_0407.png["pubkey_to_address"]

[[comp_pub]]
=== 壓縮公鑰

當比特幣最初編寫時，其開發者只知道如何創建 65 位元組的公鑰。然而，後來的開發者意識到公鑰的替代編碼僅使用 33 位元組，並且與當時所有比特幣完整節點向後相容，因此無需更改比特幣協定。這些 33 位元組的公鑰被稱為壓縮公鑰（compressed public keys），而原始的 65 位元組金鑰被稱為未壓縮公鑰（uncompressed public keys）。使用較小的公鑰會產生較小的交易，允許在同一區塊中進行更多支付。

正如我們在 <<public_key_derivation>> 一節中看到的，公鑰是橢圓曲線上的點 [.keep-together]#(x, y)#。因為曲線表達了一個數學函數，曲線上的點代表方程式的解，因此，如果我們知道 _x_ 座標，我們可以透過求解方程式 [.keep-together]#y^2^ mod p = (x^3^ + 7) mod p# 來計算 _y_ 座標。這允許我們僅儲存公鑰點的 _x_ 座標，省略 _y_ 座標並將金鑰的大小和儲存所需的空間減少 256 位元。在每筆交易中幾乎 50% 的大小減少隨著時間的推移累積了大量節省的資料！

這是我們在 <<public_key_derivation>> 中創建的私鑰生成的公鑰：

----
x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
----

以下是顯示為 520 位元數字（130 個十六進位數字）的相同公鑰，前綴為 +04+，後跟 +x+ 然後是 +y+ 座標，格式為 +04 x y+：

++++
<pre data-type="programlisting">
K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A\
    07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
</pre>
++++

而未壓縮公鑰的前綴為 +04+，壓縮公鑰以 +02+ 或 +03+ 前綴開頭。讓我們看看為什麼有兩個可能的前綴：因為方程式的左側是 __y__^2^，_y_ 的解是平方根，可以有正值或負值。視覺上，這意味著產生的 _y_ 座標可以在 x 軸上方或下方。正如您可以從 <<ecc-curve>> 中的橢圓曲線圖中看到的，曲線是對稱的，這意味著它像鏡子一樣被 x 軸反射。因此，雖然我們可以省略 _y_ 座標，但我們必須儲存 _y_ 的符號（正或負）；換句話說，我們必須記住它是在 x 軸上方還是下方，因為這些選項中的每一個都代表不同的點和不同的公鑰。在質數階 p 的有限域上以二進位算術計算橢圓曲線時，_y_ 座標是偶數或奇數，這對應於之前解釋的正/負符號。因此，為了區分 _y_ 的兩個可能值，如果 _y_ 是偶數，我們使用前綴 +02+ 儲存壓縮公鑰，如果是奇數，則使用 +03+，允許軟體正確地從 _x_ 座標推導出 _y_ 座標並將公鑰解壓縮為點的完整座標。<<pubkey_compression>> 說明了公鑰壓縮。


[[pubkey_compression]]
.公鑰壓縮
image::images/mbc3_0408.png["pubkey_compression"]


以下是在 <<public_key_derivation>> 中生成的相同公鑰，顯示為以 264 位元（66 個十六進位數字）儲存的壓縮公鑰，前綴 +03+ 表示 _y_ 座標是奇數：

----
K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
----

這個壓縮公鑰對應於相同的私鑰，這意味著它是從相同的私鑰生成的。然而，它看起來與未壓縮公鑰不同。更重要的是，如果我們使用 HASH160 函數（+RIPEMD160(SHA256(K))+）將此壓縮公鑰轉換為承諾，它將產生與未壓縮公鑰不同的承諾，導致不同的地址。這可能會令人困惑，因為這意味著單個私鑰可以產生以兩種不同格式（壓縮和未壓縮）表示的公鑰，它們產生兩個不同的比特幣地址。然而，對於兩個比特幣地址，私鑰是相同的。



壓縮公鑰現在是幾乎所有比特幣軟體的預設值，並且在使用後來協定升級中新增的某些新功能時是必需的。

然而，某些軟體仍然需要支援未壓縮公鑰，例如從舊錢包匯入私鑰的錢包應用程式。當新錢包掃描區塊鏈以查找舊 P2PKH 輸出和輸入時，它需要知道是掃描 65 位元組金鑰（以及對這些金鑰的承諾）還是 33 位元組金鑰（及其承諾）。未能掃描正確的類型可能導致使用者無法花費其全部餘額。為了解決這個問題，當從錢包匯出私鑰時，用於表示它們的 WIF 在較新的比特幣錢包中實作方式略有不同，以表明這些私鑰已用於產生壓縮公鑰。

[[addresses_for_p2sh]]
=== 傳統支付到腳本雜湊（P2SH）

正如我們在前面的章節中看到的，接收比特幣的人（如 Bob）可以要求支付給他的款項在其輸出腳本中包含某些約束。Bob 在花費這些比特幣時需要使用輸入腳本來滿足這些約束。在 <<p2pk>> 中，約束僅僅是輸入腳本需要提供適當的簽章。在 <<addresses_for_p2pkh>> 中，還需要提供適當的公鑰。

++++
<p class="fix_tracking3">
對於支付者（如 Alice）將 Bob 想要的約束放入她用於支付他的輸出腳本中，Bob 需要向她傳達這些約束。這類似於 Bob 需要向她傳達他的公鑰的問題。就像那個問題一樣，公鑰可能相當大，Bob 使用的約束也可能相當大——可能有數千位元組。這不僅是需要傳達給 Alice 的數千位元組，而且每次她想向 Bob 花錢時，她都需要為這些位元組支付交易手續費。然而，使用雜湊函數對大量資料創建小承諾的解決方案也適用於此處。
</p>
++++

2012 年對比特幣協定的 BIP16 升級允許輸出腳本承諾贖回腳本（redemption script，redeem script）。當 Bob 花費他的比特幣時，他的輸入腳本需要提供與承諾匹配的贖回腳本，以及滿足贖回腳本所需的任何資料（例如簽章）。讓我們從想像 Bob 想要兩個簽章來花費他的比特幣開始，一個來自他的桌面錢包的簽章，一個來自硬體簽署設備的簽章。他將這些條件放入贖回腳本中：

----
<public key 1> OP_CHECKSIGVERIFY <public key 2> OP_CHECKSIG
----

然後，他使用與 P2PKH 承諾相同的 HASH160 機制創建對贖回腳本的承諾，+RIPEMD160(SHA256(script))+。該承諾使用特殊範本放入輸出腳本中：

----
OP_HASH160 <commitment> OP_EQUAL
----

[WARNING]
====
使用支付到腳本雜湊（P2SH）時，您必須使用特定的 P2SH 範本，輸出腳本中不能有額外的資料或條件。如果輸出腳本不完全是 +OP_HASH160 <20 bytes> OP_EQUAL+，則不會使用贖回腳本，任何比特幣可能無法花費或可以被任何人花費（意味著任何人都可以拿走它們）。
====

當 Bob 去花費他收到的對其腳本承諾的支付時，他使用包含贖回腳本的輸入腳本，將其序列化為單個資料元素。他還提供滿足贖回腳本所需的簽章，按照它們將被操作碼消耗的順序放置它們：

----
<signature2> <signature1> <redeem script>
----

當比特幣完整節點收到 Bob 的支出時，它們將驗證序列化的贖回腳本是否雜湊到與承諾相同的值。然後它們將用其反序列化的值在堆疊上替換它：

----
<signature2> <signature1> <pubkey1> OP_CHECKSIGVERIFY <pubkey2> OP_CHECKSIG
----

腳本被執行，如果它通過並且所有其他交易細節都正確，則交易有效。

P2SH 的地址也使用 base58check 創建。版本前綴設定為 5，這會導致編碼地址以 +3+ 開頭。P2SH 地址的範例是 +3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM+。

[TIP]
====
P2SH 不一定與多重簽章交易相同。P2SH 地址最常代表多重簽章腳本，但它也可能代表編碼其他類型交易的腳本。
====

P2PKH 和 P2SH 是使用 base58check 編碼的僅有的兩個腳本範本。它們現在被稱為傳統地址，並且隨著時間的推移變得越來越不常見。傳統地址被 bech32 地址家族所取代。

[[p2sh_collision_attacks]]
.P2SH 碰撞攻擊
****
所有基於雜湊函數的地址在理論上都容易受到攻擊者獨立找到產生雜湊函數輸出（承諾）的相同輸入的攻擊。在比特幣的情況下，如果他們以與原始使用者相同的方式找到輸入，他們將知道使用者的私鑰並能夠花費該使用者的比特幣。攻擊者獨立為現有承諾生成輸入的機會與雜湊演算法的強度成正比。對於像 HASH160 這樣的安全 160 位元演算法，機率是 1-in-2^160^。這是原像攻擊（preimage attack）。

攻擊者還可以嘗試生成兩個產生相同承諾的不同輸入（例如，贖回腳本）。對於完全由單方創建的地址，攻擊者為現有承諾生成不同輸入的機會對於 HASH160 演算法也大約是 1-in-2^160^。這是第二原像攻擊（second preimage attack）。

然而，當攻擊者能夠影響原始輸入值時，這種情況會發生變化。例如，攻擊者參與多重簽章腳本的創建，他們不需要在了解所有其他方的公鑰之後才提交自己的公鑰。在這種情況下，雜湊演算法的強度降低到其平方根。對於 HASH160，機率變為 1-in-2^80^。這是碰撞攻擊（collision attack）。

// bits80=$( echo '2^80' | bc )
// seconds_per_hour="$(( 60 * 60))"
// bitcoin-cli getmininginfo | jq "(.networkhashps / $bits80 * $seconds_per_hour)"
// 0.8899382363032076

為了將這些數字放在背景中，截至 2023 年初，所有比特幣礦工合計每小時執行大約 2^80^ 次雜湊函數。他們執行的雜湊函數與 HASH160 不同，因此他們現有的硬體無法對其創建碰撞攻擊，但比特幣網路的存在證明了針對像 HASH160 這樣的 160 位元函數的碰撞攻擊是實際可行的。比特幣礦工已經花費了相當於數十億美元的特殊硬體，因此創建碰撞攻擊並不便宜，但有些組織預期收到數十億美元的比特幣到由涉及多方的流程生成的地址，這可能使攻擊有利可圖。

有完善的密碼協定可以防止碰撞攻擊，但一個不需要錢包開發者任何特殊知識的簡單解決方案是簡單地使用更強的雜湊函數。後來對比特幣的升級使這成為可能，較新的比特幣地址提供至少 128 位元的碰撞抵抗。執行 2^128^ 次雜湊操作將使所有當前的比特幣礦工花費大約 320 億年。

雖然我們不認為對創建新 P2SH 地址的任何人有任何直接威脅，但我們建議所有新錢包使用較新類型的地址，以消除地址碰撞攻擊的擔憂。
****

=== Bech32 地址

2017 年，比特幣協定進行了升級。當使用升級時，它防止交易識別碼（txid）在沒有支出使用者同意（或當需要多個簽章時的簽署者仲裁）的情況下被更改。這個升級稱為隔離見證（segregated witness，或簡稱 segwit），還為區塊中的交易資料提供了額外的容量以及其他幾個好處。然而，希望直接存取 segwit 好處的使用者必須接受對新輸出腳本的支付。

如 <<p2sh>> 中所述，P2SH 輸出類型的優勢之一是支付者（如 Alice）不需要知道接收者（如 Bob）使用的腳本的細節。segwit 升級設計為使用這種機制，允許使用者透過使用 P2SH 地址立即開始存取許多新好處。但是，要讓 Bob 存取所有好處，他需要 Alice 的錢包使用不同類型的腳本向他支付。這將需要 Alice 的錢包升級以支援新腳本。

起初，比特幣開發者提出了 BIP142，它將繼續使用帶有新版本位元組的 base58check，類似於 P2SH 升級。但是，讓所有錢包升級到帶有新 base58check 版本的新腳本預計需要幾乎與讓它們升級到全新地址格式一樣多的工作，因此幾位比特幣貢獻者著手設計可能的最佳地址格式。他們識別了 base58check 的幾個問題：

- 其大小寫混合的呈現使得大聲朗讀或轉錄不方便。嘗試向朋友朗讀本章中的傳統地址之一，讓他們轉錄它。請注意您必須如何在每個字母前加上「大寫」和「小寫」這些詞。另外，請注意，當您審查他們的書寫時，某些字母的大寫和小寫版本在許多人的筆跡中可能看起來相似。

- 它可以偵測錯誤，但不能幫助使用者糾正這些錯誤。例如，如果您在手動輸入地址時不小心調換了兩個字元，您的錢包幾乎肯定會警告存在錯誤，但它不會幫助您找出錯誤所在。您可能需要幾分鐘令人沮喪的時間才能最終發現錯誤。

- 大小寫混合的字母表還需要額外的空間來在 QR 碼中編碼，QR 碼通常用於在錢包之間共享地址和發票。這額外的空間意味著 QR 碼需要在相同解析度下更大，否則它們變得更難快速掃描。

[role="less_space pagebreak-before"]
- 它要求每個支付者錢包升級以支援像 P2SH 和 segwit 這樣的新協定功能。儘管升級本身可能不需要太多程式碼，但經驗表明，許多錢包作者忙於其他工作，有時可能會延遲升級數年。這對每個想要使用新功能的人都有不利影響。

為 segwit 開發地址格式的開發者在一種名為 bech32（發音為軟「ch」，如「besh thirty-two」）的新地址格式中找到了這些問題的每一個的解決方案。「bech」代表 BCH，這是 1959 年和 1960 年發現 bech32 所基於的循環碼的三個人的首字母縮寫。「32」代表 bech32 字母表中的字元數（類似於 base58check 中的 58）：

- Bech32 僅使用數字和單一大小寫的字母（最好以小寫呈現）。儘管其字母表幾乎是 base58check 字母表大小的一半，但用於支付到見證公鑰雜湊（P2WPKH）腳本的 bech32 地址僅略長於用於等效 P2PKH 腳本的傳統地址。

- Bech32 既可以偵測又可以幫助糾正錯誤。在預期長度的地址中，它在數學上保證能夠偵測影響四個或更少字元的任何錯誤；這比 base58check 更可靠。對於較長的錯誤，它偵測失敗的機率少於十億分之一，這與 base58check 的可靠性大致相同。更好的是，對於僅輸入了幾個錯誤的地址，它可以告訴使用者這些錯誤發生的位置，讓他們快速糾正輕微的轉錄錯誤。參見 <<bech32_typo_detection>> 以獲取輸入錯誤地址的範例。
+
[[bech32_typo_detection]]
.Bech32 錯誤偵測
====
地址：
  bc1p9nh05ha8wrljf7ru236awpass:[<u><strong>n</strong></u>]4t2x0d5ctkkywmpass:[<u><strong>v</strong></u>]9sclnm4t0av2vgs4k3au7

偵測到的錯誤以粗體和底線顯示。使用 https://oreil.ly/paWIx[bech32 地址解碼器示範] 生成。
====

- Bech32 最好僅使用小寫字元書寫，但這些小寫字元可以在 QR 碼中編碼地址之前替換為大寫字元。這允許使用占用更少空間的特殊 QR 編碼模式。請注意 <<bech32_qrcode_uc_lc>> 中同一地址的兩個 QR 碼在大小和複雜性上的差異。
+
[[bech32_qrcode_uc_lc]]
.以小寫和大寫 QR 編碼的相同 bech32 地址
image::images/mbc3_0409.png["以小寫和大寫 QR 編碼的相同 bech32 地址"]

- Bech32 利用作為 segwit 一部分設計的升級機制，使支付者錢包能夠支付尚未使用的輸出類型。目標是讓開發者今天構建一個允許向 bech32 地址支出的錢包，並讓該錢包能夠繼續向 bech32 地址支出，以供未來協定升級中新增的新功能的使用者使用。人們希望我們可能永遠不再需要經歷允許人們完全使用 P2SH 和 segwit 所需的全系統升級循環。

==== Bech32 地址的問題

Bech32 地址在除一個問題外的所有領域都會成功。關於它們偵測錯誤能力的數學保證僅在您輸入到錢包的地址長度與原始地址的長度相同時才適用。如果您在轉錄過程中新增或刪除任何字元，保證就不適用，您的錢包可能會將資金花費到錯誤的地址。然而，即使沒有保證，人們認為使用者新增或刪除字元產生具有有效檢查和的字串的可能性非常小，確保使用者的資金是安全的。

不幸的是，bech32 演算法中的一個常數的選擇恰好使得在以字母「p」結尾的地址的倒數第二個位置新增或刪除字母「q」變得非常容易。在這些情況下，您還可以多次新增或刪除字母「q」。這有時會被檢查和捕獲，但它被遺漏的頻率遠高於 bech32 替換錯誤的十億分之一的預期。有關範例，請參見 <<bech32_length_extension_example>>。

[role="less_space pagebreak-before"]
[[bech32_length_extension_example]]
.擴展 bech32 地址的長度而不使其檢查和無效
====
----
預期的 bech32 地址：
bc1pqqqsq9txsqp

具有有效檢查和的錯誤地址：
bc1pqqqsq9txsqqqqp
bc1pqqqsq9txsqqqqqqp
bc1pqqqsq9txsqqqqqqqqp
bc1pqqqsq9txsqqqqqqqqqp
bc1pqqqsq9txsqqqqqqqqqqqp
----
====
//from segwit_addr import *
//
//for foo in range(0,1000):
//    addr = encode('bc', 1, foo.to_bytes(3,'big'))
//    print(foo, addr)



對於 segwit 的初始版本（版本 0），這不是一個實際的問題。v0 segwit 輸出僅定義了兩個有效長度：22 位元組和 34 位元組。這些對應於 42 個字元或 62 個字元長的 bech32 地址，因此某人需要從 bech32 地址的倒數第二個位置新增或刪除字母「q」20 次，才能在錢包無法偵測的情況下將錢發送到無效地址。然而，如果未來實作基於 segwit 的升級，這將成為使用者的問題。

==== Bech32m

儘管 bech32 對 segwit v0 效果良好，但開發者不想在後來版本的 segwit 中不必要地限制輸出大小。沒有限制，在 bech32 地址中新增或刪除單個「q」可能導致使用者意外地將他們的錢發送到無法花費或任何人都可以花費的輸出（允許任何人拿走這些比特幣）。開發者詳盡地分析了 bech32 問題，並發現更改其演算法中的單個常數將消除該問題，確保任何插入或刪除最多五個字元只會在少於十億分之一的時間內未被偵測到。

//https://gist.github.com/sipa/a9845b37c1b298a7301c33a04090b2eb

具有單個不同常數的 bech32 版本稱為 bech32 modified（bech32m）。對於相同底層資料，bech32 和 bech32m 地址中的所有字元都將相同，除了最後六個（檢查和）。這意味著錢包需要知道正在使用哪個版本才能驗證檢查和，但兩種地址類型都包含一個內部版本位元組，使得確定這一點變得容易。



要同時使用 bech32 和 bech32m，我們將查看 bech32m 比特幣地址的編碼和解析規則，因為它們包含解析 bech32 地址的能力，並且是比特幣錢包當前推薦的地址格式。

Bech32m 地址以人類可讀部分（HRP）開頭。BIP173 中有創建您自己的 HRP 的規則，但對於比特幣，您只需要知道已經選擇的 HRP，如 <<bech32_hrps_for_bitcoin>> 所示。

++++
<table id="bech32_hrps_for_bitcoin">
<caption>比特幣的 Bech32 HRP</caption>
<thead>
<tr>
<th>HRP</th>
<th>網路</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>bc</p></td>
<td><p>比特幣主網</p></td>
</tr>
<tr>
<td><p>tb</p></td>
<td><p>比特幣測試網路</p></td>
</tr>
</tbody>
</table>
++++

HRP 後面跟著一個分隔符，數字「1」。早期的協定分隔符提案使用冒號，但某些允許使用者雙擊單詞以突出顯示它以進行複製和貼上的作業系統和應用程式不會將突出顯示延伸到冒號並越過冒號。使用數字確保雙擊突出顯示適用於任何通常支援 bech32m 字串的程式（包括其他數字）。選擇數字「1」是因為 bech32 字串不會在其他地方使用它，以防止數字「1」和小寫字母「l」之間的意外音譯。

bech32m 地址的另一部分稱為「資料部分」。此部分有三個元素：

見證版本（Witness version）::
  單個位元組，在緊接分隔符後的 bech32m 比特幣地址中編碼為單個字元。這個字母代表 segwit 版本。字母「q」是「0」的編碼，用於 segwit v0，即引入 bech32 地址的 segwit 的初始版本。字母「p」是「1」的編碼，用於 segwit v1（也稱為 taproot），其中開始使用 bech32m。segwit 有十七個可能的版本，比特幣要求 bech32m 資料部分的第一個位元組解碼為數字 0 到 16（包括）。

見證程式（Witness program）::
  從 2 到 40 位元組。對於 segwit v0，此見證程式必須為 20 或 32 位元組；沒有其他長度有效。對於 segwit v1，截至撰寫本文時唯一定義的長度是 32 位元組，但以後可能會定義其他長度。

檢查和（Checksum）::
  恰好 6 個字元。這是使用 BCH 碼創建的，BCH 碼是一種錯誤糾正碼（儘管對於比特幣地址，我們稍後會看到僅將檢查和用於錯誤偵測而不是糾正至關重要）。
//TODO

讓我們透過創建 bech32 和 bech32m 地址的範例來說明這些規則。對於以下所有範例，我們將使用 https://oreil.ly/gpTT6[Python 的 bech32m 參考程式碼]。

我們將首先生成四個輸出腳本，每個腳本對應發布時使用的不同 segwit 輸出之一，以及一個尚未定義含義的未來 segwit 版本。腳本列在 <<scripts_for_diff_segwit_outputs>> 中。

// bc1q9d3xa5gg45q2j39m9y32xzvygcgay4rgc6aaee
// 2b626ed108ad00a944bb2922a309844611d25468
//
// bc1qvj9r9egtd7mu2gemy28kpf4zefq4ssqzdzzycj7zjhk4arpavfhsct5a3p
// 648a32e50b6fb7c5233b228f60a6a2ca4158400268844c4bc295ed5e8c3d626f
//
// bc1p9nh05ha8wrljf7ru236awm4t2x0d5ctkkywmu9sclnm4t0av2vgs4k3au7
// 2ceefa5fa770ff24f87c5475d76eab519eda6176b11dbe1618fcf755bfac5311
//
// bc1sqqqqkfw08p
// O_16 OP_PUSH2 0000

++++
<table id="scripts_for_diff_segwit_outputs">
<caption>不同類型 segwit 輸出的腳本</caption>
<thead>
<tr>
<th>輸出類型</th>
<th>範例腳本</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>P2WPKH</p></td>
<td><p><code>OP_0 2b626ed108ad00a944bb2922a309844611d25468</code></p></td>
</tr>
<tr>
<td><p>P2WSH</p></td>
<td><p><code>OP_0 648a32e50b6fb7c5233b228f60a6a2ca4158400268844c4bc295ed5e8c3d626f</code></p></td>
</tr>
<tr>
<td><p>P2TR</p></td>
<td><p><code>OP_1 2ceefa5fa770ff24f87c5475d76eab519eda6176b11dbe1618fcf755bfac5311</code></p></td>
</tr>
<tr>
<td><p>未來範例</p></td>
<td><p><code>OP_16 0000</code></p></td>
</tr>
</tbody>
</table>
++++


對於 P2WPKH 輸出，見證程式包含以與 <<addresses_for_p2pkh>> 中看到的 P2PKH 輸出承諾完全相同的方式構建的承諾。公鑰被傳遞到 SHA256 雜湊函數中。產生的 32 位元組摘要然後被傳遞到 RIPEMD-160 雜湊函數中。該函數的摘要（承諾）放置在見證程式中。

對於支付到見證腳本雜湊（P2WSH）輸出，我們不使用 P2SH 演算法。相反，我們取腳本，將其傳遞到 SHA256 雜湊函數中，並在見證程式中使用該函數的 32 位元組摘要。對於 P2SH，SHA256 摘要使用 RIPEMD-160 再次雜湊，但在某些情況下這可能不安全；有關詳細資訊，請參見 <<p2sh_collision_attacks>>。使用沒有 RIPEMD-160 的 SHA256 的結果是 P2WSH 承諾為 32 位元組（256 位元）而不是 20 位元組（160 位元）。

對於支付到 taproot（P2TR）輸出，見證程式是 secp256k1 曲線上的一個點。它可能是一個簡單的公鑰，但在大多數情況下，它應該是承諾某些額外資料的公鑰。我們將在 <<taproot>> 中了解更多關於該承諾的資訊。

++++
<p class="fix_tracking2">
對於未來 segwit 版本的範例，我們簡單地使用可能的最高 segwit 版本號（16）和具有空值的最小允許見證程式（2 位元組）。</p>
++++

現在我們知道了版本號和見證程式，我們可以將它們每個都轉換為 bech32 地址。讓我們使用 Python 的 bech32m 參考函式庫快速生成這些地址，然後更深入地了解正在發生的事情：

----
$ github="https://raw.githubusercontent.com"
$ wget $github/sipa/bech32/master/ref/python/segwit_addr.py

$ python
>>> from segwit_addr import *
>>> from binascii import unhexlify

>>> help(encode)
encode(hrp, witver, witprog)
    編碼 segwit 地址。

>>> encode('bc', 0, unhexlify('2b626ed108ad00a944bb2922a309844611d25468'))
'bc1q9d3xa5gg45q2j39m9y32xzvygcgay4rgc6aaee'
>>> encode('bc', 0,
unhexlify('648a32e50b6fb7c5233b228f60a6a2ca4158400268844c4bc295ed5e8c3d626f'))
'bc1qvj9r9egtd7mu2gemy28kpf4zefq4ssqzdzzycj7zjhk4arpavfhsct5a3p'
>>> encode('bc', 1,
unhexlify('2ceefa5fa770ff24f87c5475d76eab519eda6176b11dbe1618fcf755bfac5311'))
'bc1p9nh05ha8wrljf7ru236awm4t2x0d5ctkkywmu9sclnm4t0av2vgs4k3au7'
>>> encode('bc', 16, unhexlify('0000'))
'bc1sqqqqkfw08p'
----

如果我們打開檔案 __segwit_addr.py__ 並查看程式碼正在做什麼，我們注意到的第一件事是 bech32（用於 segwit v0）和 bech32m（用於後來的 segwit 版本）之間的唯一差異是常數：

----
BECH32_CONSTANT = 1
BECH32M_CONSTANT = 0x2bc830a3
----

接下來我們注意到產生檢查和的程式碼。在檢查和的最後一步，適當的常數使用 xor 操作合併到值中。那個單一值是 bech32 和 bech32m 之間的唯一差異。

創建檢查和後，資料部分中的每個 5 位元字元（包括見證版本、見證程式和檢查和）都被轉換為字母數字字元。

要解碼回輸出腳本，我們反向工作。首先讓我們使用參考函式庫解碼我們的兩個地址：

----
>>> help(decode)
decode(hrp, addr)
    解碼 segwit 地址。

>>> _ = decode("bc", "bc1q9d3xa5gg45q2j39m9y32xzvygcgay4rgc6aaee")
>>>  _[0], bytes(_[1]).hex()
(0, '2b626ed108ad00a944bb2922a309844611d25468')
>>> _ = decode("bc",
        "bc1p9nh05ha8wrljf7ru236awm4t2x0d5ctkkywmu9sclnm4t0av2vgs4k3au7")
>>> _[0], bytes(_[1]).hex()
(1, '2ceefa5fa770ff24f87c5475d76eab519eda6176b11dbe1618fcf755bfac5311')
----

我們取回見證版本和見證程式。這些可以插入到我們輸出腳本的範本中：

----
<version> <program>
----

例如：

----
OP_0 2b626ed108ad00a944bb2922a309844611d25468
OP_1 2ceefa5fa770ff24f87c5475d76eab519eda6176b11dbe1618fcf755bfac5311
----

[WARNING]
====
此處需要注意的一個可能錯誤是見證版本「0」用於 +OP_0+，它使用位元組 0x00——但見證版本「1」使用 +OP_1+，即位元組 0x51。見證版本「2」到「16」分別使用 0x52 到 0x60。
====

在實作 bech32m 編碼或解碼時，我們強烈建議您使用 BIP350 中提供的測試向量。我們還要求您確保您的程式碼通過與支付尚未定義的未來 segwit 版本相關的測試向量。這將有助於使您的軟體在未來許多年內可用，即使您無法在新的比特幣功能可用時立即新增對它們的支援。

[[priv_formats]]
==== 私鑰格式

私鑰可以用多種不同的格式表示，所有這些格式都對應於相同的 256 位元數字。<<table_4-2>> 顯示了用於表示私鑰的幾種常見格式。不同的格式在不同的情況下使用。十六進位和原始二進位格式在軟體內部使用，很少向使用者顯示。WIF 用於在錢包之間匯入/匯出金鑰，並經常用於私鑰的 QR 碼（條碼）表示。

.私鑰格式的現代相關性
****
早期的比特幣錢包軟體在新使用者錢包初始化時生成一個或多個獨立的私鑰。當初始的金鑰集全部使用完畢時，錢包可能會生成額外的私鑰。可以匯出或匯入個別私鑰。每次生成或匯入新私鑰時，都需要創建錢包的新備份。

後來的比特幣錢包開始使用確定性錢包（deterministic wallets），其中所有私鑰都從單個種子值生成。對於典型的鏈上使用，這些錢包只需要備份一次。然而，如果使用者從這些錢包之一匯出單個私鑰，並且攻擊者獲得該金鑰加上關於錢包的一些非私密資料，他們可能能夠衍生錢包中的任何私鑰——允許攻擊者竊取所有錢包資金。此外，金鑰無法匯入到確定性錢包中。這意味著幾乎沒有現代錢包支援匯出或匯入個別金鑰的能力。本節中的資訊主要對需要與早期比特幣錢包相容的任何人感興趣。

有關更多資訊，請參見 <<hd_wallets>>。

****

++++
<table id="table_4-2">
<caption>私鑰表示（編碼格式）</caption>
<thead>
<tr>
<th>類型</th>
<th>前綴</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Hex</p></td>
<td><p>無</p></td>
<td><p>64 個十六進位數字</p></td>
</tr>
<tr>
<td><p>WIF</p></td>
<td><p>5</p></td>
<td><p>Base58check 編碼：base58，版本前綴為 128，32 位元檢查和</p></td>
</tr>
<tr>
<td><p>WIF-compressed</p></td>
<td><p>K 或 L</p></td>
<td><p>如上所述，在編碼前新增後綴 0x01</p></td>
</tr>
</tbody>
</table>
++++

<<table_4-3>> 顯示了以幾種不同格式生成的私鑰。

++++
<table id="table_4-3">
<caption>範例：相同金鑰，不同格式</caption>
<thead>
<tr>
<th>格式</th>
<th>私鑰</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Hex</p></td>
<td><p>1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd</p></td>
</tr>
<tr>
<td><p>WIF</p></td>
<td><p>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td>
</tr>
<tr>
<td><p>WIF-compressed</p></td>
<td><p>KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</p></td>
</tr>
</tbody>
</table>
++++

所有這些表示都是顯示相同數字、相同私鑰的不同方式。它們看起來不同，但任何一種格式都可以輕鬆轉換為任何其他格式。

[[comp_priv]]
==== 壓縮私鑰

常用術語「壓縮私鑰」是一個用詞不當，因為當私鑰以 WIF-compressed 格式匯出時，它實際上比「未壓縮」私鑰長一個位元組。這是因為私鑰有一個新增的單位元組後綴（在 <<table_4-4>> 中以十六進位顯示為 01），這表示私鑰來自較新的錢包，應該僅用於產生壓縮公鑰。私鑰本身沒有被壓縮，也無法被壓縮。術語「壓縮私鑰」實際上意味著「應該僅從中衍生壓縮公鑰的私鑰」，而「未壓縮私鑰」實際上意味著「應該僅從中衍生未壓縮公鑰的私鑰」。您應該僅將匯出格式稱為「WIF-compressed」或「WIF」，而不將私鑰本身稱為「壓縮」，以避免進一步混淆。

<<table_4-4>> 顯示了以 WIF 和 WIF-compressed 格式編碼的相同金鑰。

++++
<table id="table_4-4">
<caption>範例：相同金鑰，不同格式</caption>
<thead>
<tr>
<th>格式</th>
<th>私鑰</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Hex</p></td>
<td><p>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</p></td>
</tr>
<tr>
<td><p>WIF</p></td>
<td><p>5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td>
</tr>
<tr>
<td><p>Hex-compressed</p></td>
<td><p>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD01</p></td>
</tr>
<tr>
<td><p>WIF-compressed</p></td>
<td><p>KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</p></td>
</tr>
</tbody>
</table>
++++

請注意，十六進位壓縮私鑰格式在末尾有一個額外的位元組（十六進位的 01）。雖然 WIF 和 WIF-compressed 格式的 base58 編碼版本前綴相同（0x80），但在數字末尾新增一個位元組會導致 base58 編碼的第一個字元從 5 變為 _K_ 或 _L_。可以將此視為十進位編碼中數字 100 和數字 99 之間差異的 base58 等價物。雖然 100 比 99 長一位數字，但它的前綴也是 1 而不是 9。隨著長度變化，它會影響前綴。在 base58 中，當數字長度增加一個位元組時，前綴 5 變為 _K_ 或 _L_。

請記住，這些格式不能互換使用。在實作壓縮公鑰的較新錢包中，私鑰只會以 WIF-compressed 格式（帶有 _K_ 或 _L_ 前綴）匯出。如果錢包是較舊的實作並且不使用壓縮公鑰，則私鑰只會以 WIF 格式（帶有 5 前綴）匯出。這裡的目標是向匯入這些私鑰的錢包發出訊號，說明它必須在區塊鏈中搜尋壓縮還是未壓縮的公鑰和地址。

如果比特幣錢包能夠實作壓縮公鑰，它將在所有交易中使用這些公鑰。錢包中的私鑰將用於在曲線上衍生公鑰點，這些公鑰點將被壓縮。壓縮的公鑰將用於產生比特幣地址，這些地址將用於交易中。從實作壓縮公鑰的新錢包匯出私鑰時，WIF 會被修改，在私鑰中新增一個單位元組後綴 +01+。產生的 base58check 編碼私鑰稱為「壓縮 WIF」，以字母 _K_ 或 _L_ 開頭，而不是像來自較舊錢包的 WIF 編碼（未壓縮）金鑰那樣以「5」開頭。

=== 進階金鑰與地址

在以下章節中，我們將研究進階形式的金鑰和地址，例如靚號地址和紙錢包。

==== 靚號地址

靚號地址（vanity addresses）是包含人類可讀訊息的有效比特幣地址。例如，+1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33+ 是一個有效地址，包含形成單詞「Love」的字母作為前四個 base58 字母。靚號地址需要生成和測試數十億個候選私鑰，直到找到具有所需圖案的比特幣地址。儘管靚號生成演算法中有一些最佳化，但該過程本質上涉及隨機選擇私鑰、衍生公鑰、衍生比特幣地址，並檢查它是否與所需的靚號圖案匹配，重複數十億次直到找到匹配項。

一旦找到與所需圖案匹配的靚號地址，衍生它的私鑰就可以被擁有者用於花費比特幣，方式與任何其他地址完全相同。靚號地址與任何其他地址一樣安全，沒有更安全或更不安全。它們依賴於與任何其他地址相同的橢圓曲線密碼學（ECC）和安全雜湊演算法（SHA）。您找到以靚號圖案開頭的地址的私鑰並不比您找到任何其他地址的私鑰更容易。

Eugenia 是一位在菲律賓運營的兒童慈善機構董事。假設 Eugenia 正在組織一次募款活動，並希望使用靚號比特幣地址來宣傳募款活動。Eugenia 將創建一個以「1Kids」開頭的靚號地址來宣傳兒童慈善募款活動。讓我們看看如何創建這個靚號地址以及它對 Eugenia 慈善機構的安全意味著什麼。

===== 生成靚號地址

重要的是要認識到，比特幣地址只是一個由 base58 字母表中的符號表示的數字。搜尋像「1Kids」這樣的圖案可以看作是在從 +1Kids11111111111111111111111111111+ 到 +1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz+ 的範圍內搜尋地址。該範圍內大約有 58^29^（大約 1.4 × 10^51^）個地址，全部以「1Kids」開頭。<<table_4-11>> 顯示了具有前綴 1Kids 的地址範圍。

++++
<table id="table_4-11">
<caption>以「1Kids」開頭的靚號地址範圍</caption>
<tbody>
<tr>
<td><p><strong>從</strong></p></td>
<td><p><code>1Kids11111111111111111111111111111</code></p></td>
</tr>
<tr>
<td/>
<td><p><code>1Kids11111111111111111111111111112</code></p></td>
</tr>
<tr>
<td/>
<td><p><code>1Kids11111111111111111111111111113</code></p></td>
</tr>
<tr>
<td/>
<td><p><code>…​</code></p></td>
</tr>
<tr>
<td><p><strong>到</strong></p></td>
<td><p><code>1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz</code></p></td>
</tr>
</tbody>
</table>
++++

讓我們將圖案「1Kids」視為一個數字，並查看我們在比特幣地址中找到這個圖案的頻率（見 <<table_4-12>>）。一台普通的桌上型電腦 PC，沒有任何專用硬體，每秒可以搜尋大約 100,000 個金鑰。

++++
<table id="table_4-12">
<caption>靚號圖案（1KidsCharity）的頻率和桌上型 PC 上的平均搜尋時間</caption>
<thead>
<tr>
<th>長度</th>
<th>圖案</th>
<th>頻率</th>
<th>平均搜尋時間</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>1</p></td>
<td><p>1K</p></td>
<td><p>1 in 58 keys</p></td>
<td><p>&lt; 1 毫秒</p></td>
</tr>
<tr>
<td><p>2</p></td>
<td><p>1Ki</p></td>
<td><p>1 in 3,364</p></td>
<td><p>50 毫秒</p></td>
</tr>
<tr>
<td><p>3</p></td>
<td><p>1Kid</p></td>
<td><p>1 in 195,000</p></td>
<td><p>&lt; 2 秒</p></td>
</tr>
<tr>
<td><p>4</p></td>
<td><p>1Kids</p></td>
<td><p>1 in 11 million</p></td>
<td><p>1 分鐘</p></td>
</tr>
<tr>
<td><p>5</p></td>
<td><p>1KidsC</p></td>
<td><p>1 in 656 million</p></td>
<td><p>1 小時</p></td>
</tr>
<tr>
<td><p>6</p></td>
<td><p>1KidsCh</p></td>
<td><p>1 in 38 billion</p></td>
<td><p>2 天</p></td>
</tr>
<tr>
<td><p>7</p></td>
<td><p>1KidsCha</p></td>
<td><p>1 in 2.2 trillion</p></td>
<td><p>3–4 個月</p></td>
</tr>
<tr>
<td><p>8</p></td>
<td><p>1KidsChar</p></td>
<td><p>1 in 128 trillion</p></td>
<td><p>13–18 年</p></td>
</tr>
<tr>
<td><p>9</p></td>
<td><p>1KidsChari</p></td>
<td><p>1 in 7 quadrillion</p></td>
<td><p>800 年</p></td>
</tr>
<tr>
<td><p>10</p></td>
<td><p>1KidsCharit</p></td>
<td><p>1 in 400 quadrillion</p></td>
<td><p>46,000 年</p></td>
</tr>
<tr>
<td><p>11</p></td>
<td><p>1KidsCharity</p></td>
<td><p>1 in 23 quintillion</p></td>
<td><p>250 萬年</p></td>
</tr>
</tbody>
</table>
++++

正如您所看到的，Eugenia 不會很快創建靚號地址「1KidsCharity」，即使她可以存取數千台電腦。每個額外的字元都會將難度增加 58 倍。超過七個字元的圖案通常由專用硬體找到，例如具有多個圖形處理單元（GPU）的訂製桌上型電腦。GPU 系統上的靚號搜尋比通用 CPU 上快許多數量級。

另一種找到靚號地址的方法是將工作外包給靚號礦工池。https://oreil.ly/99K81[靚號池] 是一項服務，允許那些擁有快速硬體的人透過為他人搜尋靚號地址來賺取比特幣。只需支付費用，Eugenia 就可以將搜尋七個字元圖案靚號地址的工作外包出去，並在幾個小時內獲得結果，而不必運行 CPU 搜尋數月。

生成靚號地址是一種暴力練習：嘗試隨機金鑰，檢查產生的地址是否與所需圖案匹配，重複直到成功。

===== 靚號地址的安全性和隱私

靚號地址在比特幣早期很流行，但截至 2023 年幾乎完全不再使用。這種趨勢有兩個可能的原因：

確定性錢包:: 正如我們在 <<recovery_code_intro>> 中看到的，可以透過簡單地寫下幾個單詞或字元來備份大多數現代錢包中的每個金鑰。這是透過使用確定性演算法從這些單詞或字元衍生錢包中的每個金鑰來實現的。除非使用者為他們創建的每個靚號地址備份額外資料，否則無法將靚號地址與確定性錢包一起使用。更實際的是，大多數使用確定性金鑰生成的錢包根本不允許從靚號生成器匯入私鑰或金鑰調整。

避免地址重複使用:: 使用靚號地址接收多筆支付到同一地址會在所有這些支付之間創建連結。這對 Eugenia 來說可能是可以接受的，如果她的非營利組織無論如何都需要向稅務機關報告其收入和支出。然而，這也降低了向 Eugenia 支付或從她那裡接收支付的人的隱私。例如，Alice 可能想要匿名捐贈，Bob 可能不希望他的其他客戶知道他給 Eugenia 提供折扣價格。

// https://github.com/MakisChristou/vanitybech

除非解決前述問題，否則我們預計未來不會看到很多靚號地址。

[[paper_wallets]]
==== 紙錢包

紙錢包（paper wallets）是列印在紙上的私鑰。通常，紙錢包還包含相應的比特幣地址以方便使用，但這不是必需的，因為它可以從私鑰衍生。

[WARNING]
====
紙錢包是一項過時的技術，對大多數使用者來說是危險的。生成它們涉及許多微妙的陷阱，其中最重要的是生成程式碼可能被「後門」洩露的可能性。許多比特幣就是以這種方式被竊取的。這裡展示紙錢包僅供參考，不應用於儲存比特幣。使用恢復碼來備份您的金鑰，可能使用硬體簽署設備來儲存金鑰和簽署交易。不要使用紙錢包。
====


紙錢包有多種設計和尺寸，具有許多不同的功能。<<paper_wallet_simple>> 顯示了一個範例紙錢包。

[[paper_wallet_simple]]
.簡單紙錢包的範例
image::images/mbc3_0410.png[]

有些旨在作為禮物贈送，並具有季節性主題，例如聖誕節和新年。其他設計用於儲存在銀行保險庫或保險箱中，私鑰以某種方式隱藏，可以用不透明的刮刮貼紙，或者摺疊並用防篡改膠箔密封。其他設計具有金鑰和地址的額外副本，以可拆卸存根的形式，類似於票根，允許您儲存多個副本以防止火災、洪水或其他自然災害。

從比特幣原始的以公鑰為中心的設計到現代地址和腳本（如 bech32m 和支付到 taproot）——甚至未來比特幣升級的地址——您已經了解了比特幣協定如何允許支付者識別應該接收其支付的錢包。但是，當實際上是您的錢包接收支付時，您會希望確保即使您的錢包資料發生問題，您仍然可以存取這些資金。在下一章中，我們將研究比特幣錢包如何設計以保護其資金免受各種威脅。
