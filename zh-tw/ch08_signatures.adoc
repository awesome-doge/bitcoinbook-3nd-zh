[[c_signatures]]
== 數位簽章

目前在 Bitcoin 中使用兩種((("數位簽章", "schnorr 簽章演算法")))((("schnorr 簽章演算法")))((("數位簽章", "ECDSA")))((("ECDSA (橢圓曲線數位簽章演算法)")))((("交易", "簽章", see="數位簽章")))簽章演算法，_schnorr 簽章演算法_和_橢圓曲線數位簽章演算法_（_ECDSA_）。這些演算法用於基於橢圓曲線私鑰/公鑰對的數位簽章，如 <<elliptic_curve>> 中所述。它們用於支付隔離見證 v0 P2WPKH 輸出、隔離見證 v1 P2TR 金鑰路徑支付，以及腳本函數 +OP_CHECKSIG+、+OP_CHECKSIGVERIFY+、+OP_CHECKMULTISIG+、[.keep-together]#+OP_CHECKMULTISIGVERIFY+# 和 +OP_CHECKSIGADD+。任何時候執行其中一個，都必須提供簽章。

數位簽章((("數位簽章", "目的")))在 Bitcoin 中有三個目的。首先，簽章證明私鑰的控制者（暗示是資金的所有者）已經_授權_花費這些資金。其次，授權證明是_不可否認的_（不可抵賴性）。第三，授權的交易無法被未經授權的第三方更改——其_完整性_是完好的。

[NOTE]
====
每個交易輸入及其可能包含的任何簽章都_完全_獨立於任何其他輸入或簽章。多方可以協作構建交易並且只簽署一個輸入。有幾種協議使用這個事實來創建多方交易以保護隱私。
====

在本章中，我們將探討數位簽章如何工作，以及它們如何在不洩露私鑰的情況下提供私鑰控制的證明。

[role="less_space pagebreak-before"]
=== 數位簽章如何工作

數位簽章由兩部分組成。第一部分是使用私鑰（簽署金鑰）為訊息（交易）創建簽章的演算法。第二部分是允許任何人驗證簽章的演算法，前提是還提供了訊息和相應的公鑰。

==== 創建數位簽章

在 Bitcoin((("數位簽章", "創建")))使用數位簽章演算法時，被簽署的「訊息」是交易，或更準確地說是交易中特定資料子集的雜湊，((("承諾雜湊")))稱為_承諾雜湊_（請參見 <<sighash_types>>）。簽署金鑰是使用者的私鑰。結果是簽章：

[latexmath]
++++
\begin{equation}
Sig = F_{sig}(F_{hash}(m), x)
\end{equation}
++++

其中：

* _x_ 是簽署私鑰
* _m_ 是要簽署的訊息，承諾雜湊（例如交易的部分）
* _F_~_hash_~ 是雜湊函數
* _F_~_sig_~ 是簽署演算法
* _Sig_ 是產生的簽章

您可以在 <<schnorr_signatures>> 和 <<ecdsa_signatures>> 中找到有關 schnorr 和 ECDSA 簽章數學的更多詳細資訊。

在 schnorr 和 ECDSA 簽章中，函數 _F_~_sig_~ 產生由兩個值組成的簽章 +Sig+。在不同的演算法中，這兩個值之間存在差異，我們稍後會探討。計算出這兩個值後，它們被序列化為位元組流。對於 ECDSA 簽章，編碼使用稱為_專用編碼規則_（_Distinguished Encoding Rules_）或 _DER_ 的國際標準編碼方案。對於 schnorr 簽章，使用更簡單的序列化格式。

==== 驗證簽章

簽章((("數位簽章", "驗證")))((("驗證", "數位簽章")))驗證演算法接受訊息（交易和相關資料的部分的雜湊）、簽署者的公鑰和簽章，如果簽章對此訊息和公鑰有效，則返回 ++TRUE++。

要驗證簽章，必須擁有簽章、序列化的交易、有關被支付輸出的一些資料，以及與用於創建簽章的私鑰相對應的公鑰。本質上，簽章的驗證意味著「只有生成此公鑰的私鑰的控制者才能在此交易上產生此簽章」。

[[sighash_types]]
==== 簽章雜湊類型（SIGHASH）

數位簽章((("數位簽章", "SIGHASH 標誌", id="digital-signature-sighash")))((("SIGHASH 標誌", id="sighash")))適用於訊息，就 Bitcoin 而言，訊息就是交易本身。簽章證明簽署者對特定交易資料的_承諾_。在最簡單的形式中，簽章幾乎適用於整個交易，從而承諾所有輸入、輸出和其他交易欄位。但是，簽章可以只承諾交易中資料的子集，這對於許多場景都很有用，我們將在本節中看到。

Bitcoin 簽章有一種方法可以使用 +SIGHASH+ 標誌來指示交易資料的哪一部分包含在由私鑰簽署的雜湊中。+SIGHASH+ 標誌是附加到簽章的單個位元組。每個簽章都有明確或隱含的 +SIGHASH+ 標誌，並且標誌可以因輸入而異。具有三個已簽署輸入的交易可能具有三個帶有不同 +SIGHASH+ 標誌的簽章，每個簽章簽署（承諾）交易的不同部分。

請記住，每個輸入可能包含一個或多個簽章。因此，一個輸入可能具有帶有不同 +SIGHASH+ 標誌的簽章，這些標誌承諾交易的不同部分。還請注意，Bitcoin 交易可能包含來自不同「所有者」的輸入，他們可能只在部分構建的交易中簽署一個輸入，與其他人協作收集所有必要的簽章以製作有效的交易。許多 +SIGHASH+ 標誌類型只有在您考慮多個參與者在 Bitcoin 網路之外協作並更新部分簽署的交易時才有意義。

有三個 +SIGHASH+ 標誌：+ALL+、+NONE+ 和 +SINGLE+，如 <<sighash_types_and_their>> 所示。

[[sighash_types_and_their]]
++++
<table id="sighash_types_and_their">
<caption>
<span class="plain"><code>SIGHASH</code></span> 類型及其含義</caption>
<thead>
<tr>
<th><code>SIGHASH</code> 標誌</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>ALL</code></p></td>
<td><p><code>0x01</code></p></td>
<td><p>簽章適用於所有輸入和輸出</p></td>
</tr>
<tr>
<td><p><code>NONE</code></p></td>
<td><p><code>0x02</code></p></td>
<td><p>簽章適用於所有輸入，但不適用於任何輸出</p></td>
</tr>
<tr>
<td><p><code>SINGLE</code></p></td>
<td><p><code>0x03</code></p></td>
<td><p>簽章適用於所有輸入，但僅適用於與已簽署輸入具有相同索引號的一個輸出</p></td>
</tr>
</tbody>
</table>
++++

此外，還有一個修飾符標誌 +SIGHASH_ANYONECANPAY+，可以與前面的每個標誌組合。當設置 +ANYONECANPAY+ 時，只簽署一個輸入，其餘的（及其序列號）保持開放以供修改。+ANYONECANPAY+ 的值為 +0x80+，並透過按位 OR 應用，產生如 <<sighash_types_with_modifiers>> 所示的組合標誌。

[role="less_space pagebreak-before"]
[[sighash_types_with_modifiers]]
++++
<table id="sighash_types_with_modifiers">
<caption>
<span class="plain"><code>SIGHASH</code></span> 類型及修飾符的含義</caption>
<thead>
<tr>
<th><code>SIGHASH</code> 標誌</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>ALL|ANYONECANPAY</code></p></td>
<td><p><code>0x81</code></p></td>
<td><p>簽章適用於一個輸入和所有輸出</p></td>
</tr>
<tr>
<td><p><code>NONE|ANYONECANPAY</code></p></td>
<td><p><code>0x82</code></p></td>
<td><p>簽章適用於一個輸入，不適用於任何輸出</p></td>
</tr>
<tr>
<td><p><code>SINGLE|ANYONECANPAY</code></p></td>
<td><p><code>0x83</code></p></td>
<td><p>簽章適用於一個輸入和具有相同索引號的輸出</p></td>
</tr>
</tbody>
</table>
++++

+SIGHASH+ 標誌在簽署和驗證期間的應用方式是製作交易的副本，並省略或截斷其中的某些欄位（設置為零長度並清空）。然後將結果交易序列化。+SIGHASH+ 標誌包含在序列化的交易資料中，並對結果進行雜湊。雜湊摘要本身就是被簽署的「訊息」。根據使用哪個 +SIGHASH+ 標誌，交易的不同部分會被包含。透過包含 +SIGHASH+ 標誌本身，簽章也承諾 +SIGHASH+ 類型，因此它不能被更改（例如，被礦工）。

在 <<serialization_of_signatures_der>> 中，我們將看到 DER 編碼簽章的最後部分是 +01+，這是 ECDSA 簽章的 +SIGHASH_ALL+ 標誌。這會鎖定交易資料，因此 Alice 的簽章承諾所有輸入和輸出的狀態。這是最常見的簽章形式。

讓我們看一些其他 +SIGHASH+ 類型以及它們在實踐中的使用方式：

+ALL|ANYONECANPAY+ :: 這種((("群眾募資")))結構可用於製作「群眾募資」風格的交易。試圖籌集資金的人可以構建一個帶有單個輸出的交易。單個輸出將「目標」金額支付給募資者。這樣的交易顯然是無效的，因為它沒有輸入。但是，其他人現在可以透過添加自己的輸入作為捐贈來修改它。他們使用 +ALL|ANYONECANPAY+ 簽署自己的輸入。除非收集到足夠的輸入以達到輸出的價值，否則交易無效。每筆捐贈都是一個「承諾」，在籌集整個目標金額之前，募資者無法收取。不幸的是，這個協議可以被募資者透過添加自己的輸入（或從借錢給他們的人那裡）來規避，從而允許他們收取捐款，即使他們沒有達到指定的價值。

+NONE+ :: 這種結構可用於創建特定金額的「無記名支票」或「空白支票」。它承諾所有輸入但允許輸出被更改。任何人都可以將自己的 Bitcoin 地址寫入輸出腳本。就其本身而言，這允許任何礦工更改輸出目的地並為自己索取資金，但如果交易中的其他所需簽章使用 +SIGHASH_ALL+ 或其他承諾輸出的類型，它允許那些支付者更改目的地而不允許任何第三方（如礦工）修改輸出。

+NONE|ANYONECANPAY+ :: 這種結構可用於建立「粉塵收集器」。錢包中擁有微小 UTXO 的使用者無法在不讓手續費成本超過 UTXO 價值的情況下花費這些 UTXO；請參見 <<uneconomical_outputs>>。使用這種類型的簽章，不經濟的 UTXO 可以被捐贈給任何人隨時聚合和花費。

有一些修改或擴展 +SIGHASH+ 系統的提案。截至本文撰寫時討論最廣泛的提案是((("BIP118 SIGHASH 標誌")))BIP118，它提議添加兩個新的 sighash 標誌。使用 +SIGHASH_ANYPREVOUT+ 的簽章不會承諾輸入的輸出點欄位，允許它用於花費特定見證程式的任何先前輸出。例如，如果 Alice 收到兩個相同金額到相同見證程式的輸出（例如，需要來自她錢包的單個簽章），則用於花費其中一個輸出的 +SIGHASH_ANYPREVOUT+ 簽章可以被複製並用於將另一個輸出花費到相同的目的地。

使用 +SIGHASH_ANYPREVOUTANYSCRIPT+ 的簽章不會承諾輸出點、金額、見證程式或 taproot 默克爾樹（腳本樹）中的特定葉子，允許它花費簽章可以滿足的任何先前輸出。例如，如果 Alice 收到兩個不同金額和不同見證程式的輸出（例如，一個需要單個簽章，另一個需要她的簽章加上一些其他資料），則用於花費其中一個輸出的 +SIGHASH_ANYPREVOUTANYSCRIPT+ 簽章可以被複製並用於將另一個輸出花費到相同的目的地（假設第二個輸出的額外資料是已知的）。

兩個 ++SIGHASH_ANYPREVOUT++ 操作碼的主要預期用途是改進支付通道，例如閃電網路（LN）中使用的支付通道，儘管已經描述了其他幾種用途。

[NOTE]
====
您不會經常看到 +SIGHASH+ 標誌在使用者的錢包應用程式中作為選項呈現。簡單的錢包應用程式使用 [.keep-together]#+SIGHASH_ALL+# 標誌簽署。更複雜的應用程式，例如 LN 節點，可能使用替代的 +SIGHASH+ 標誌，但它們使用經過廣泛審查的協議來了解替代((("數位簽章", "SIGHASH 標誌", startref="digital-signature-sighash")))((("SIGHASH 標誌", startref="sighash")))標誌的影響。
====

[[schnorr_signatures]]
=== Schnorr 簽章

在 1989 年，((("數位簽章", "schnorr 簽章演算法", id="digital-sigs-schnorr")))((("schnorr 簽章演算法", id="schnorr")))Claus Schnorr 發表了一篇論文，描述了以他命名的簽章演算法。該演算法並不特定於 Bitcoin 和許多其他應用程式使用的橢圓曲線密碼學（ECC），儘管它今天可能與 ECC 最密切相關。Schnorr 簽章具有許多優良特性：

可證明的安全性::
schnorr 簽章安全性的數學((("數位簽章", "schnorr 簽章演算法", "特性")))((("schnorr 簽章演算法", "特性")))證明僅取決於解決離散對數問題（DLP）的難度，特別是對於 Bitcoin 的橢圓曲線（EC），以及雜湊函數（如 Bitcoin 中使用的 SHA256 函數）產生不可預測值的能力，稱為隨機預言模型（ROM）。其他簽章演算法具有額外的依賴關係，或者需要更大的公鑰或簽章才能獲得與 ECC-Schnorr 相當的安全性（當威脅被定義為經典計算機時；其他演算法可能針對量子計算機提供更有效的安全性）。

線性::
Schnorr 簽章具有數學家((("線性")))稱為_線性_的特性，這適用於具有兩個特定特性的函數。第一個特性是將兩個或多個變數相加然後對該和運行函數將產生與對每個變數獨立運行函數然後將結果相加相同的值，例如，_f(x_ + _y_ + _z)_ == _f(x)_ + _f(y)_ + _f(z)_；這個特性被((("可加性")))稱為_可加性_。第二個特性是將變數相乘然後對該乘積運行函數將產生與對變數運行函數然後將其乘以相同數量相同的值，例如，_f(a_ × _x)_ == _a_ × _f(x)_；這個特性被((("1 次齊次性")))稱為 _1 次齊次性_。
+
在密碼學操作中，某些函數可能是私有的（例如涉及私鑰或秘密 nonce 的函數），因此無論是在函數內部還是外部執行操作都能獲得相同的結果，這使得多方可以輕鬆協調和合作而無需共享他們的秘密。我們將在 <<schnorr_multisignatures>> 和 <<schnorr_threshold_signatures>> 中看到 schnorr 簽章線性的一些具體好處。

批次驗證::
當以某種方式使用時（Bitcoin 確實如此），schnorr 線性的一個((("數位簽章的批次驗證")))結果是，可以相對簡單地同時驗證多個 schnorr 簽章，所需時間少於獨立驗證每個簽章所需的時間。在批次中驗證的簽章越多，速度提升就越大。對於區塊中典型數量的簽章，可以在大約一半的時間內批次驗證它們，相比獨立驗證每個簽章所需的時間。

在本章後面，我們將準確描述 Bitcoin 中使用的 schnorr 簽章演算法，但我們將從其簡化版本開始，並分階段逐步實現實際協議。

[role="less_space pagebreak-before"]
Alice((("數位簽章", "schnorr 簽章演算法", "使用範例")))((("schnorr 簽章演算法", "使用範例")))首先選擇一個大的隨機數（_x_），我們稱之為她的_私鑰_。她還知道 Bitcoin 橢圓曲線上的一個公共點，稱為生成器（_G_）（請參見 <<public_key_derivation>>）。Alice 使用 EC 乘法將 _G_ 乘以她的私鑰 _x_，在這種情況下，_x_ 被稱為_純量_，因為它縮放了 _G_。結果是 _xG_，我們稱之為 Alice 的_公鑰_。Alice 將她的公鑰給 Bob。即使 Bob 也知道 _G_，DLP 也阻止 Bob 能夠將 _xG_ 除以 _G_ 來衍生 Alice 的私鑰。

在稍後的某個時候，Bob 希望 Alice 透過證明她知道 Bob 之前收到的公鑰（_xG_）的純量 _x_ 來識別自己。Alice 不能直接給 Bob _x_，因為那會允許他向其他人識別為她，所以她需要在不向 Bob 洩露 _x_ 的情況下證明她對 _x_ 的知識，((("零知識證明")))稱為_零知識證明_。為此，我們開始 schnorr 身份過程：

1. Alice 選擇另一個大的隨機數（_k_），我們稱之為_私有 nonce_。她再次將其用作純量，將其乘以 _G_ 以產生 _kG_，我們稱之為_公共 nonce_。她將公共 nonce 給 Bob。

2. Bob 選擇他自己的大隨機數 _e_，我們稱之為_挑戰純量_。我們說「挑戰」是因為它用於挑戰 Alice 證明她知道她之前給 Bob 的公鑰（_xG_）的私鑰（_x_）；我們說「純量」是因為它稍後將用於乘以 EC 點。

3. Alice 現在有數字（純量）_x_、_k_ 和 _e_。她使用公式 _s_ = _k_ + _ex_ 將它們組合在一起以產生最終的純量 _s_。她將 _s_ 給 Bob。

4. Bob 現在知道純量 _s_ 和 _e_，但不知道 _x_ 或 _k_。但是，Bob 確實知道 _xG_ 和 _kG_，他可以自己計算 _sG_ 和 _exG_。這意味著他可以檢查 Alice 執行的操作的放大版本的相等性：[.keep-together]#_sG_ == _kG_ + _exG_。#如果相等，那麼 Bob 可以確信 Alice 在生成 _s_ 時知道 _x_。

.使用整數而不是點的 Schnorr 身份協議
****
如果我們透過將前面的每個值（包括 _G_）替換為簡單的整數而不是橢圓曲線上的點來創建一個不安全的過度簡化，可能更容易理解互動式 schnorr 身份協議。例如，我們將使用從 3 開始的質數：

設置：Alice 選擇 _x_ = 3 作為她的私鑰。她將其乘以生成器 _G_ = 5 以獲得她的公鑰 _xG_ = 15。她給 Bob 15。

1. Alice 選擇私有 nonce _k_ = 7 並生成公共 nonce _kG_ = 35。她給 Bob 35。

2. Bob 選擇 _e_ = 11 並將其給 Alice。

3. Alice 生成 _s_ = 40 = 7 + 11 × 3。她給 Bob 40。

4. Bob 衍生 _sG_ = 200 = 40 × 5 和 _exG_ = 165 = 11 × 15。然後他驗證 [.keep-together]#200 == 35 + 165。#注意，這與 Alice 執行的操作相同，但所有值都被 5（_G_ 的值）放大了。

當然，這是一個過度簡化的範例。當使用簡單整數時，我們可以將乘積除以生成器 _G_ 以獲得底層純量，這是不安全的。這就是為什麼 Bitcoin 中使用的橢圓曲線密碼學的一個關鍵特性是乘法很容易，但除以曲線上的點是不切實際的。此外，使用如此小的數字，透過暴力破解找到底層值（或有效替代品）很容易；Bitcoin 中使用的數字要大得多。
****

讓我們討論互動式 schnorr 身份協議的一些安全功能：

nonce (k)::
在步驟 1 中，((("數位簽章", "schnorr 簽章演算法", "安全功能")))((("schnorr 簽章演算法", "安全功能")))Alice 選擇一個 Bob 不知道且無法猜測的數字，並給他該數字的縮放形式 _kG_。在那時，Bob 也已經擁有她的公鑰（_xG_），這是 _x_（她的私鑰）的縮放形式。這意味著當 Bob 處理最終等式（_sG_ = _kG_ + _exG_）時，有兩個 Bob 不知道的獨立變數（_x_ 和 _k_）。可以使用簡單的代數來解決具有一個未知變數的等式，但不能解決兩個獨立未知變數的等式，因此 Alice 的 nonce 的存在阻止 Bob 能夠衍生她的私鑰。非常重要的是要注意，這種保護取決於 nonce 以任何方式都是不可猜測的。如果 Alice 的 nonce 有任何可預測的內容，Bob 可能能夠利用它來找出 Alice 的私鑰。有關更多詳細資訊，請參見 <<nonce_warning>>。

挑戰純量 (e)::
Bob 等待接收 Alice 的公共 nonce，然後在步驟 2 中給她一個 Alice 之前不知道且無法猜測的數字（挑戰純量）。Bob 只有在她承諾她的公共 nonce 之後才給她挑戰純量，這一點至關重要。考慮一下如果不知道 _x_ 的人想要冒充 Alice，而 Bob 不小心在他們告訴他公共 nonce _kG_ 之前給了他們挑戰純量 _e_，會發生什麼。這允許冒充者更改 Bob 將用於驗證的等式兩側的參數，_sG_ == _kG_ + _exG_；具體來說，他們可以更改 _sG_ 和 _kG_。想想該表達式的簡化形式：_x_ = _y_ + _a_。如果您可以更改 _x_ 和 _y_，您可以使用 _x_++'++ = (_x_ – _a_) + _a_ 來抵消 _a_。您為 _x_ 選擇的任何值現在都將滿足等式。對於實際等式，冒充者只需為 _s_ 選擇一個隨機數，生成 _sG_，然後使用 EC 減法選擇一個等於 _kG_ = _sG_ – _exG_ 的 _kG_。他們給 Bob 他們計算的 _kG_，稍後給他們隨機的 _sG_，Bob 認為這是有效的，因為 [.keep-together]#_sG_ == (_sG_ – _exG_)# + _exG_。這解釋了為什麼協議中的操作順序是必不可少的：Bob 必須只在 Alice 承諾她的公共 nonce 之後才給 Alice 挑戰純量。

++++
<p class="fix_tracking">
這裡描述的互動式身份協議與 Claus Schnorr 的原始描述的一部分相符，但它缺少我們在去中心化 Bitcoin 網路中需要的兩個基本功能。第一個是它依賴於 Bob 等待 Alice 承諾她的公共 nonce，然後 Bob 給她一個隨機挑戰純量。在 Bitcoin 中，每筆交易的支付者都需要由數千個 Bitcoin 完整節點進行認證——包括尚未啟動但其運營者有一天想要確保他們收到的比特幣來自每筆交易都有效的轉帳鏈的未來節點。任何無法與 Alice 通訊的 Bitcoin 節點，今天或將來，都將無法認證她的交易，並且將與所有確實認證它的其他節點不一致。這對於像 Bitcoin 這樣的共識系統是不可接受的。為了讓 Bitcoin 正常工作，我們需要一個不需要 Alice 與每個想要認證她的節點之間進行互動的協議。
</p>
++++

一種簡單的技術，稱為 Fiat-Shamir 轉換（以其發現者命名），可以將 schnorr 互動式身份協議轉變為非互動式數位簽章方案。回想一下步驟 1 和 2 的重要性——包括它們必須按順序執行。Alice 必須承諾一個不可預測的 nonce；Bob 必須只在收到她的承諾後才給 Alice 一個不可預測的挑戰純量。還要回想我們在本書其他地方使用的安全密碼雜湊函數的特性：當給定相同的輸入時，它總是產生相同的輸出，但當給定不同的輸入時，它會產生與隨機資料無法區分的值。

這允許 Alice 選擇她的私有 nonce，衍生她的公共 nonce，然後雜湊公共 nonce 以獲得挑戰純量。因為 Alice 無法預測雜湊函數的輸出（挑戰），並且因為對於相同的輸入（nonce）它始終是相同的，這確保了 Alice 獲得隨機挑戰，即使她選擇 nonce 並自己對其進行雜湊。我們不再需要 Bob 的互動。她可以簡單地發布她的公共 nonce _kG_ 和純量 _s_，數千個完整節點（過去和未來）中的每一個都可以雜湊 _kG_ 以產生 _e_，使用它來產生 _exG_，然後驗證 _sG_ == _kG_ + _exG_。明確寫出，驗證等式變為 [.keep-together]#_sG_ == _kG_ + _hash_(_kG_) × _xG_。#

我們需要另一件事來完成將互動式 schnorr 身份協議轉換為對 Bitcoin 有用的數位簽章協議。我們不只是想讓 Alice 證明她知道她的私鑰；我們還想讓她能夠承諾一個訊息。具體來說，我們希望她承諾與她想要發送的 Bitcoin 交易相關的資料。有了 Fiat-Shamir 轉換，我們已經有了一個承諾，所以我們可以簡單地讓它額外承諾訊息。我們現在還使用 _hash_(_kG_ || _m_) 承諾訊息 _m_，而不是 _hash_(_kG_)，其中 || 代表串聯。

我們現在已經定義了 schnorr 簽章協議的一個版本，但還有一件事我們需要做以解決 Bitcoin 特定的問題。在 BIP32 金鑰衍生中，如 <<public_child_key_derivation>> 中所述，未強化衍生的演算法獲取公鑰並向其添加非秘密值以產生衍生公鑰。這意味著也可以將該非秘密值添加到一個金鑰的有效簽章中以產生相關金鑰的簽章。該相關簽章是有效的，但它未經擁有私鑰的人授權，這是一個重大的安全失敗。為了保護 BIP32 未強化衍生並支援人們想要在 schnorr 簽章之上構建的幾個協議，Bitcoin 的 schnorr 簽章版本稱為 _BIP340 secp256k1 的 schnorr 簽章_，除了公共 nonce 和訊息之外，還承諾正在使用的公鑰。這使得完整承諾為 _hash_(_kG_ || _xG_ || _m_)。

現在我們已經描述了 BIP340 schnorr 簽章演算法的每個部分並解釋了它為我們做了什麼，我們可以定義協議。整數的乘法是_模 p_ 執行的，表示操作的結果除以數字 _p_（如 secp256k1 標準中定義的），並使用餘數。數字 _p_ 非常大，但如果它是 3 且操作的結果是 5，我們將使用的實際數字是 2（即，5 除以 3 的餘數是 2）。

設置：Alice 選擇一個大的隨機數（_x_）作為她的私鑰（直接或使用像 BIP32 這樣的協議從大的隨機種子值確定性地生成私鑰）。她使用 secp256k1 中定義的參數（請參見 <<elliptic_curve>>）將生成器 _G_ 乘以她的純量 _x_，產生 _xG_（她的公鑰）。她將她的公鑰給每個將來會認證她的 Bitcoin 交易的人（例如，透過將 _xG_ 包含在交易輸出中）。當她準備好花費時，她開始生成她的簽章：

1. Alice 選擇一個大的隨機私有 nonce _k_ 並衍生公共 nonce _kG_。

2. 她選擇她的訊息 _m_（例如，交易資料）並生成挑戰純量 _e_ = _hash_(_kG_ || _xG_ || _m_)。

3. 她產生純量 _s_ = _k_ + _ex_。兩個值 _kG_ 和 _s_ 是她的簽章。她將這個簽章給每個想要驗證該簽章的人；她還需要確保每個人都收到她的訊息 _m_。在 Bitcoin 中，這是透過在她的支付交易的見證結構中包含她的簽章，然後將該交易中繼到完整節點來完成的。

4. 驗證者（例如，完整節點）使用 _s_ 衍生 _sG_，然後驗證 _sG_ == _kG_ + _hash_(_kG_ || _xG_ || _m_) × _xG_。如果等式有效，Alice 證明了她知道她的私鑰 _x_（不洩露它）並承諾訊息 _m_（包含交易資料）。

==== Schnorr 簽章的序列化

schnorr 簽章((("數位簽章", "schnorr 簽章演算法", "序列化")))((("schnorr 簽章演算法", "序列化")))((("序列化", "schnorr 簽章演算法", secondary-sortas="schnorr")))由兩個值組成，_kG_ 和 _s_。值 _kG_ 是 Bitcoin 橢圓曲線（稱為 secp256k1）上的一個點，通常由兩個 32 位元組座標表示，例如（_x_, _y_）。但是，只需要 _x_ 座標，因此只包含該值。當您在 Bitcoin 的 schnorr 簽章中看到 _kG_ 時，請注意它只是該點的 _x_ 座標。

值 _s_ 是一個純量（意味著乘以其他數字的數字）。對於 Bitcoin 的 secp256k1 曲線，它永遠不會超過 32 位元組長。

儘管 _kG_ 和 _s_ 有時可以是可以用少於 32 位元組表示的值，但它們不太可能比 32 位元組小得多，因此它們被序列化為兩個 32 位元組值（即，小於 32 位元組的值有前導零）。它們按 _kG_ 然後 _s_ 的順序序列化，正好產生 64 位元組。

taproot 軟分叉，也稱為 v1 segwit，將 schnorr 簽章引入 Bitcoin，是它們截至本文撰寫時在 Bitcoin 中使用的唯一方式。當與 taproot 金鑰路徑或腳本路徑支付一起使用時，64 位元組 schnorr 簽章被認為使用預設簽章雜湊（sighash），即 +SIGHASH_ALL+。如果使用替代 sighash，或者支付者想要浪費空間明確指定 +SIGHASH_ALL+，則將指定簽章雜湊的單個額外位元組附加到簽章，使簽章為 65 位元組。

正如我們將看到的，64 或 65 位元組比 <<serialization_of_signatures_der>> 中描述的用於 ECDSA 簽章的序列化要有效得多。

[[schnorr_multisignatures]]
==== 基於 Schnorr 的無腳本多重簽章

在((("數位簽章", "schnorr 簽章演算法", "無腳本多重簽章", id="digital-sigs-schnorr-multisig")))((("schnorr 簽章演算法", "無腳本多重簽章", id="schnorr-multisig")))((("無腳本多重簽章", "在 schnorr 簽章演算法中", secondary-sortas="schnorr", id="scriptless-multi-schnorr")))((("多重簽章腳本", "在 schnorr 簽章演算法中", secondary-sortas="schnorr", id="multi-script-schnorr")))<<schnorr_signatures>> 中描述的單簽章 schnorr 協議中，Alice 使用簽章（_kG_, _s_）公開證明她對她的私鑰的知識，在這種情況下我們稱之為 _y_。想像一下，如果 Bob 也有一個私鑰（_z_），並且他願意與 Alice 合作證明他們一起知道 _x_ = _y_ + _z_，而不向彼此或其他任何人洩露他們的私鑰。讓我們再次經歷 BIP340 schnorr 簽章協議。

[WARNING]
====
我們即將描述的簡單協議由於我們將很快解釋的原因而不安全。我們僅使用它來演示 schnorr 多重簽章的機制，然後再描述被認為是安全的相關協議。
====

Alice 和 Bob 需要衍生 _x_ 的公鑰，即 _xG_。由於可以使用橢圓曲線操作將兩個 EC 點加在一起，他們首先由 Alice 衍生 _yG_，Bob 衍生 _zG_。然後他們將它們加在一起以創建 [.keep-together]#_xG_ = _yG_ + _zG_。#點 _xG_ 是((("聚合公鑰")))((("公鑰", "聚合")))他們的_聚合公鑰_。要創建簽章，他們開始簡單的多重簽章協議：

1. 他們各自單獨選擇一個大的隨機私有 nonce，Alice 為 _a_，Bob 為 _b_。他們還各自單獨衍生相應的公共 nonce _aG_ 和 _bG_。他們一起產生聚合公共 nonce _kG_ = _aG_ + _bG_。

2. 他們就要簽署的訊息 _m_（例如，交易）達成一致，並且各自生成挑戰純量的副本：_e_ = _hash_(_kG_ || _xG_ || _m_)。

3. Alice 產生純量 _q_ = _a_ + _ey_。Bob 產生純量 _r_ = _b_ + _ez_。他們將純量加在一起以產生 _s_ = _q_ + _r_。他們的簽章是兩個值 _kG_ [.keep-together]#和 _s_。#

4. 驗證者使用正常等式檢查他們的公鑰和簽章：[.keep-together]#_sG_ ==# _kG_ + _hash_(_kG_ || _xG_ || _m_) × _xG_。

Alice 和 Bob 已經證明他們知道他們的私鑰之和，而他們中的任何一個都沒有向另一個或其他任何人洩露他們的私鑰。該協議可以擴展到任何數量的參與者（例如，一百萬人可以證明他們知道他們一百萬個不同金鑰的總和）。

前面的協議有幾個安全問題。最值得注意的是，一方可能在承諾自己的公鑰之前了解其他方的公鑰。例如，Alice 誠實地生成她的公鑰 _yG_ 並與 Bob 共享。Bob 使用 _zG_ – _yG_ 生成他的公鑰。當他們的兩個金鑰組合時 [.keep-together]#(_yG_ + _zG_ – _yG_),# 正負 _yG_ 項抵消，因此公鑰僅代表 _z_ 的私鑰（即 Bob 的私鑰）。現在 Bob 可以在沒有 Alice 任何協助的情況下創建有效簽章。這被((("金鑰抵消攻擊")))稱為_金鑰抵消攻擊_。

有多種方法可以解決金鑰抵消攻擊。最簡單的方案是要求每個參與者在與所有其他參與者共享有關該金鑰的任何資訊之前承諾他們的公鑰部分。例如，Alice 和 Bob 各自單獨雜湊他們的公鑰並與對方共享他們的摘要。當他們都擁有對方的摘要時，他們可以共享他們的金鑰。他們各自檢查對方的金鑰雜湊到先前提供的摘要，然後正常進行協議。這防止他們中的任何一個選擇抵消其他參與者金鑰的公鑰。但是，很容易無法正確實作此方案，例如以天真的方式將其與未強化 BIP32 公鑰衍生一起使用。此外，它為參與者之間的通訊添加了額外的步驟，這在許多情況下可能是不可取的。已經提出了解決這些缺點的更複雜的方案。

除了金鑰抵消攻擊之外，還有許多針對((("nonce 攻擊")))nonce 的攻擊。回想一下，nonce 的目的是防止任何人能夠使用他們對簽章驗證等式中其他值的知識來解決您的私鑰，確定其值。為了有效地實現這一點，您每次簽署不同的訊息或更改其他簽章參數時都必須使用不同的 nonce。不同的 nonce 不得以任何方式相關。對於多重簽章，每個參與者都必須遵循這些規則，否則可能會危及其他參與者的安全。此外，需要防止抵消和其他攻擊。實現這些目標的不同協議做出不同的權衡，因此在所有情況下都沒有單一的多重簽章協議可推薦。相反，我們將注意 MuSig 協議系列中的三個：

MuSig::
也稱為 _MuSig1_，此協議((("MuSig 協議")))在簽署過程中需要三輪通訊，使其類似於我們剛剛描述的過程。MuSig1 的最大優勢是其簡單性。

MuSig2::
這只((("MuSig2 協議")))需要兩輪通訊，有時可以允許其中一輪與金鑰交換結合。這可以顯著加快某些協議的簽署速度，例如無腳本多重簽章計畫在 LN 中使用的方式。MuSig2 在 BIP327 中指定（截至本文撰寫時唯一具有 BIP 的無腳本多重簽章協議）。

MuSig-DN::
DN 代表((("MuSig-DN 協議")))((("重複會話攻擊")))確定性 Nonce，它消除了稱為_重複會話攻擊_的問題。它不能與金鑰交換結合，並且比 MuSig 或 MuSig2 更複雜。

對於大多數應用程式，MuSig2 是截至本文撰寫時最好的多重簽章協議((("數位簽章", "schnorr 簽章演算法", "無腳本多重簽章", startref="digital-sigs-schnorr-multisig")))((("schnorr 簽章演算法", "無腳本多重簽章", startref="schnorr-multisig")))((("無腳本多重簽章", "在 schnorr 簽章演算法中", secondary-sortas="schnorr", startref="scriptless-multi-schnorr")))((("多重簽章腳本", "在 schnorr 簽章演算法中", secondary-sortas="schnorr", startref="multi-script-schnorr")))。

[[schnorr_threshold_signatures]]
==== 基於 Schnorr 的無腳本閾值簽章

無腳本((("數位簽章", "schnorr 簽章演算法", "無腳本閾值簽章", id="digital-sigs-schnorr-threshold")))((("schnorr 簽章演算法", "無腳本閾值簽章", id="schnorr-threshold")))((("無腳本閾值簽章", id="scriptless-threshold-schnorr")))((("閾值簽章", "在 schnorr 簽章演算法中", secondary-sortas="schnorr", id="threshold-schnorr")))多重簽章協議僅適用於 _k_-of-_k_ 簽署。成為聚合公鑰一部分的部分公鑰的每個人都必須向最終簽章貢獻部分簽章和部分 nonce。但是，有時參與者希望允許他們的子集簽署，例如 _t_-of-_k_，其中閾值（_t_）數量的參與者可以為 _k_ 個參與者構建的金鑰簽署。這種類型的簽章稱為_閾值簽章_。

我們在 <<multisig>> 中看到了基於腳本的閾值簽章。但就像無腳本多重簽章與腳本多重簽章相比節省空間並增加隱私一樣，_無腳本閾值簽章_與_腳本閾值簽章_相比節省空間並增加隱私。對於未參與簽署的任何人來說，_無腳本閾值簽章_看起來就像任何其他簽章，可以由單簽章使用者或透過無腳本多重簽章協議創建。

已知生成無腳本閾值簽章的各種方法，最簡單的方法是對我們之前創建無腳本多重簽章的方式進行輕微修改。此協議還依賴於可驗證秘密共享（其本身依賴於安全秘密共享）。

基本秘密共享可以透過簡單拆分來工作。Alice 有一個秘密數字，她將其拆分為三個等長部分並與 Bob、Carol 和 Dan 共享。這三個人可以按正確的順序組合他們收到的部分數字（稱為_份額_）以重建 Alice 的秘密。更複雜的方案將涉及 Alice 向每個份額添加一些額外資訊，稱為糾錯碼，允許他們中的任何兩個恢復數字。這個方案是不安全的，因為每個份額都讓其持有者部分了解 Alice 的秘密，使參與者比沒有份額的非參與者更容易猜測 Alice 的秘密。

安全秘密共享方案防止參與者了解有關秘密的任何資訊，除非他們組合最小閾值數量的份額。例如，Alice 可以選擇閾值 2，如果她想讓 Bob、Carol 和 Dan 中的任何兩個能夠重建她的秘密。最著名的安全秘密共享演算法是 _Shamir's Secret Sharing Scheme_，通常縮寫為 SSSS，以其發現者命名，他也是我們在 <<schnorr_signatures>> 中看到的 Fiat-Shamir 轉換的發現者之一。

在某些密碼學協議中，例如我們正在努力實現的無腳本閾值簽章方案，Bob、Carol 和 Dan 知道 Alice 正確地遵循了她那一方的協議至關重要。他們需要知道她創建的份額都來自同一個秘密，她使用了她聲稱的閾值，並且她給了他們每個人不同的份額。一個可以完成所有這些的協議，並且仍然是一個安全的秘密共享方案，是一個_可驗證的秘密共享方案_。

要了解多重簽章和可驗證秘密共享如何為 Alice、Bob 和 Carol 工作，想像他們每個人都希望接收可以由他們中的任何兩個花費的資金。他們如 <<schnorr_multisignatures>> 中所述協作以產生常規多重簽章公鑰以接受資金（k-of-k）。然後每個參與者從他們的私鑰衍生兩個秘密份額——每個其他兩個參與者一個。這些份額允許他們中的任何兩個重建多重簽章的原始部分私鑰。每個參與者將他們的一個秘密份額分發給其他兩個參與者，導致每個參與者儲存他們自己的部分私鑰和每個其他參與者的一個份額。隨後，每個參與者驗證他們收到的份額與給其他參與者的份額相比的真實性和唯一性。

稍後，當（例如）Alice 和 Bob 想要在沒有 Carol 參與的情況下生成無腳本閾值簽章時，他們交換他們擁有的 Carol 的兩個份額。這使他們能夠重建 Carol 的部分私鑰。Alice 和 Bob 也有他們的私鑰，允許他們使用所有三個必要的金鑰創建無腳本多重簽章。

換句話說，剛剛描述的無腳本閾值簽章方案與無腳本多重簽章方案相同，只是閾值數量的參與者有能力重建無法或不願意簽署的任何其他參與者的部分私鑰。

這確實指出了在考慮無腳本閾值簽章協議時需要注意的幾件事：

無問責制::
因為 Alice 和 Bob 重建了 Carol 的部分私鑰，所以涉及 Carol 的過程產生的無腳本多重簽章與沒有涉及 Carol 的多重簽章之間不可能存在根本區別。即使 Alice、Bob 或 Carol 聲稱他們沒有簽署，也沒有保證的方法讓他們證明他們沒有幫助產生簽章。如果知道組中哪些成員簽署很重要，您將需要使用腳本。

操縱攻擊::
想像一下 Bob 告訴 Alice Carol 不可用，因此他們一起工作以重建 Carol 的部分私鑰。然後 Bob 告訴 Carol Alice 不可用，因此他們一起工作以重建 Alice 的部分私鑰。現在 Bob 擁有他自己的部分私鑰加上 Alice 和 Carol 的金鑰，允許他在沒有他們參與的情況下自己花費資金。這種攻擊可以透過使用通訊方案來防止，該方案允許他們中的任何一個看到所有其他人的訊息（例如，如果 Bob 告訴 Alice Carol 不可用，Carol 能夠在她開始與 Bob 工作之前看到該訊息）。其他解決方案，可能更強大的解決方案，在本文撰寫時正在研究中。

截至本文撰寫時，還沒有無腳本閾值簽章協議被提議為 BIP，儘管多位 Bitcoin 貢獻者已經對該主題進行了重要研究，我們預計在本((("數位簽章", "schnorr 簽章演算法", startref="digital-sigs-schnorr")))((("schnorr 簽章演算法", startref="schnorr")))((("數位簽章", "schnorr 簽章演算法", "無腳本閾值簽章", startref="digital-sigs-schnorr-threshold")))((("schnorr 簽章演算法", "無腳本閾值簽章", startref="schnorr-threshold")))((("無腳本閾值簽章", startref="scriptless-threshold-schnorr")))((("閾值簽章", "在 schnorr 簽章演算法中", secondary-sortas="schnorr", startref="threshold-schnorr")))書出版後，經過同行評審的解決方案將變得可用。

[[ecdsa_signatures]]
=== ECDSA 簽章

不幸的是((("數位簽章", "ECDSA", id="digital-signature-ecdsa")))((("ECDSA (橢圓曲線數位簽章演算法)", id="ecdsa")))，對於 Bitcoin 和許多其他應用程式的未來發展，Claus Schnorr 對他發現的演算法申請了專利，並在近二十年內阻止了它在開放標準和開源軟體中的使用。1990 年代初期的密碼學家在被阻止使用 schnorr 簽章方案時，開發了一種替代構造，稱為_數位簽章演算法_（DSA），並有一個適應於橢圓曲線的版本稱為 ECDSA。

ECDSA 方案和建議的標準化參數在 2007 年開始開發 Bitcoin 時已經在密碼學函式庫中廣泛實現。這幾乎肯定是 ECDSA 從第一個發布版本直到 2021 年 taproot 軟分叉激活之前，成為 Bitcoin 支援的唯一數位簽章協議的原因。ECDSA 今天仍然支援所有非 taproot 交易。與 schnorr 簽章相比的一些差異包括：

更複雜::
  正如我們將看到的，ECDSA 需要更多操作來創建或驗證簽章，與 schnorr 簽章協議相比。從實現的角度來看，它並不顯著更複雜，但額外的複雜性使 ECDSA 靈活性較低、性能較差，並且更難證明其安全性。

安全性證明較少::
  互動式 schnorr 簽章身份協議僅依賴於橢圓曲線離散對數問題（ECDLP）的強度。在 Bitcoin 中使用的非互動式認證協議也依賴於隨機預言機模型（ROM）。然而，ECDSA 的額外複雜性阻止了完整安全性證明的發表（據我們所知）。我們不是證明密碼學演算法的專家，但在 30 年之後，ECDSA 似乎不太可能被證明只需要與 schnorr 相同的兩個假設。

非線性::
  ECDSA 簽章無法輕鬆組合以創建無腳本多重簽章或用於相關的進階應用，例如多方簽章適配器。這個問題有解決方法，但它們涉及額外的複雜性，顯著減慢操作速度，並且在某些情況下，導致軟體意外洩露私鑰。

==== ECDSA 演算法

讓我們看看 ECDSA 的數學。簽章由數學函數 _F_~_sig_~ 創建，該函數產生由兩個值組成的簽章。在 ECDSA 中，這兩個值是 _R_ 和 _s_。

簽章演算法首先生成一個私有 nonce（_k_）並從中衍生一個公共 nonce（_K_）。數位簽章的 _R_ 值是 nonce _K_ 的 _x_ 座標。

從那裡，演算法計算簽章的 _s_ 值。就像我們對 schnorr 簽章所做的那樣，涉及整數的操作是模 p：

[latexmath]
++++
\begin{equation}
s = k^{-1} (Hash(m) + x \times R)
\end{equation}
++++


其中：

* _k_ 是私有 nonce
* _R_ 是公共 nonce 的 _x_ 座標
* _x_ 是 Alice 的私鑰
* _m_ 是訊息（交易資料）

驗證是簽章生成函數的反向，使用 _R_、_s_ 值和公鑰計算值 _K_，這是橢圓曲線上的一個點（簽章創建中使用的公共 nonce）：

[latexmath]
++++
\begin{equation}
K = s^{-1} \times Hash(m) \times G + s^{-1} \times R \times X
\end{equation}
++++

其中：

- _R_ 和 _s_ 是簽章值
- _X_ 是 Alice 的公鑰
- _m_ 是訊息（被簽署的交易資料）
- _G_ 是橢圓曲線生成器點

如果計算點 _K_ 的 _x_ 座標等於 _R_，那麼驗證者可以得出簽章有效的結論。

[TIP]
====
ECDSA 必然是一個相當複雜的數學部分；完整解釋超出了本書的範圍。網上有許多優秀的指南會逐步帶您了解它：搜尋「ECDSA explained」。
====

[[serialization_of_signatures_der]]
==== ECDSA 簽章的序列化（DER）

讓我們((("序列化", "ECDSA 簽章")))看看以下 DER 編碼的簽章：

----
3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204
b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e381301
----

該簽章是簽署者產生的 _R_ 和 _s_ 值的序列化位元組流，以證明對授權花費輸出的私鑰的控制。序列化格式由九個元素組成，如下所示：

* +0x30+，表示 DER 序列的開始
* +0x45+，序列的長度（69 位元組）
  * +0x02+，後面跟著一個整數值
  * +0x21+，整數的長度（33 位元組）
  * +R+，++00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb++
  * +0x02+，後面跟著另一個整數
  * +0x20+，整數的長度（32 位元組）
  * +S+，++4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813++
* 後綴（+0x01+）表示使用的雜湊((("數位簽章", "ECDSA", startref="digital-signature-ecdsa")))((("ECDSA (橢圓曲線數位簽章演算法)", startref="ecdsa")))類型（+SIGHASH_ALL+）

[[nonce_warning]]
=== 簽章中隨機性的重要性

正如我們((("數位簽章", "隨機性，重要性", id="digital-signature-random")))((("隨機性，數位簽章中的重要性", id="random-digital-signature")))在 <<schnorr_signatures>> 和 <<ecdsa_signatures>> 中看到的，簽章生成演算法使用隨機數 _k_ 作為私有/公共 nonce 對的基礎。_k_ 的值並不重要，_只要它是隨機的_。如果來自同一私鑰的簽章對不同訊息（交易）使用相同的私有 nonce _k_，那麼任何人都可以計算出簽署_私鑰_。在簽章演算法中重複使用相同的 _k_ 值會導致私鑰洩露！

[WARNING]
====
如果在兩個不同交易的簽署演算法中使用相同的值 _k_，私鑰可以被計算出來並暴露給全世界！
====

這不僅僅是理論上的可能性。我們已經看到這個問題導致 Bitcoin 中幾種不同的交易簽署演算法實現中私鑰的洩露。由於無意中重複使用 _k_ 值，人們的資金被盜取。重複使用 _k_ 值的最常見原因是隨機數生成器初始化不當。

為了避免這個漏洞，業界最佳實踐不是僅使用熵種子的隨機數生成器來生成 _k_，而是使用部分由交易資料本身加上用於簽署的私鑰種子的過程。這確保每筆交易產生不同的 _k_。用於 ECDSA 的 _k_ 確定性初始化的行業標準演算法在 https://oreil.ly/yuabl[RFC6979] 中定義，由網際網路工程任務組發布。對於 schnorr 簽章，BIP340 推薦預設簽署演算法。

BIP340 和 RFC6979 可以完全確定性地生成 _k_，這意味著相同的交易資料將始終產生相同的 _k_。許多錢包這樣做是因為這使編寫測試來驗證其安全關鍵的簽署程式碼是否正確產生 _k_ 值變得容易。BIP340 和 RFC6979 也都允許在計算中包含額外資料。如果該資料是熵，那麼即使簽署完全相同的交易資料，也會產生不同的 _k_。這可以增加對側通道攻擊和故障注入攻擊的保護。

如果您正在實現一個演算法來簽署 Bitcoin 中的交易，您_必須_使用 BIP340、RFC6979 或類似的演算法來確保您為每筆((("數位簽章", "隨機性，重要性", startref="digital-signature-random")))((("隨機性，數位簽章中的重要性", startref="random-digital-signature")))交易生成不同的 _k_。

=== 隔離見證的新簽署演算法

Bitcoin((("數位簽章", "隔離見證和")))((("隔離見證 (segwit)", "數位簽章和")))((("承諾雜湊")))交易中的簽章適用於_承諾雜湊_，該雜湊從交易資料計算得出，鎖定資料的特定部分以指示簽署者對這些值的承諾。例如，在簡單的 +SIGHASH_ALL+ 類型簽章中，承諾雜湊包括所有輸入和輸出。

不幸的是，傳統承諾雜湊的計算方式引入了節點驗證簽章時可能被迫執行大量雜湊計算的可能性。具體來說，雜湊操作相對於交易中的輸入數量大約呈二次方增長。因此，攻擊者可以創建一個具有非常大量簽章操作的交易，導致整個 Bitcoin 網路必須執行數百或數千次雜湊操作來驗證交易。

Segwit 代表了透過更改承諾雜湊計算方式來解決這個問題的機會。對於 segwit 版本 0 見證程式，簽章驗證使用如 BIP143 中指定的改進承諾雜湊演算法。

新演算法允許雜湊操作的數量相對於簽章操作的數量以更漸進的 O(n) 增長，減少了使用過於複雜的交易創建拒絕服務攻擊的機會。

在本章中，我們了解了 Bitcoin 的 schnorr 和 ECDSA 簽章。這解釋了完整節點如何認證交易以確保只有控制接收比特幣的金鑰的人才能花費這些比特幣。我們還檢查了簽章的幾個進階應用，例如無腳本多重簽章和無腳本閾值簽章，可以用來提高 Bitcoin 的效率和隱私。在過去幾章中，我們學習了如何創建交易、如何使用授權和認證保護它們以及如何簽署它們。接下來，我們將學習如何透過向我們創建的交易添加手續費來鼓勵礦工確認它們。

//FIXME: mention segwit v0 and v1 coverage of values to aid hardware
//wallets