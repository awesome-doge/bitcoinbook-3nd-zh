[[bitcoin_network_ch08]]
== 比特幣網路

Bitcoin 是((("Bitcoin", "作為點對點網路", secondary-sortas="點對點網路", seealso="比特幣網路")))((("點對點網路，Bitcoin 作為", seealso="比特幣網路")))((("網路 (Bitcoin)", see="比特幣網路")))((("比特幣網路")))在網際網路之上構建的點對點網路架構。點對點（或 P2P）一詞意味著參與網路的完整節點彼此是對等的，它們都可以執行相同的功能，並且沒有「特殊」節點。網路節點在網狀網路中以「扁平」拓撲相互連接。網路中沒有伺服器、沒有中心化服務，也沒有階層。P2P 網路中的節點同時提供和消費服務。P2P 網路本質上具有彈性、去中心化和開放性。P2P 網路架構的一個卓越範例是早期的網際網路本身，其中 IP 網路上的節點是平等的。今天的網際網路架構更具階層性，但網際網路協議仍然保留其扁平拓撲的本質。除了 Bitcoin 和網際網路之外，P2P 技術最大和最成功的應用是檔案共享，Napster 是先驅，BitTorrent 是該架構的最新演進。

Bitcoin 的 P2P 網路架構不僅僅是拓撲選擇。Bitcoin 在設計上是一個 P2P 數位現金系統，網路架構既是該核心特性的反映，也是其基礎。控制權的去中心化是核心設計原則，只能透過扁平和去中心化的 P2P 共識網路來實現和維護。

「Bitcoin 網路」一詞是指執行 Bitcoin P2P 協議的節點集合。除了 Bitcoin P2P 協議之外，還有其他用於挖礦和輕量級錢包的協議。這些額外的協議由閘道路由伺服器提供，這些伺服器使用 Bitcoin P2P 協議存取 Bitcoin 網路，然後將該網路擴展到執行其他協議的節點。例如，Stratum 伺服器透過 Stratum 協議將 Stratum 挖礦節點連接到主要的 Bitcoin 網路，並將 Stratum 協議橋接到 Bitcoin P2P 協議。除了基礎的 Bitcoin P2P 協議之外，我們將在本章中描述一些最常用的協議。

=== 節點類型和角色

儘管((("比特幣網路", "節點", "類型")))((("節點", "類型")))((("完整節點", "目的")))((("對等節點")))Bitcoin P2P 網路中的完整節點（對等節點）彼此平等，但它們可能根據其支援的功能承擔不同的角色。Bitcoin 完整節點驗證區塊，並可能包含其他功能，例如路由、挖礦和錢包服務。

一些稱為_存檔完整節點_的節點((("存檔完整節點")))也維護區塊鏈的完整和最新副本。這些節點可以向僅儲存區塊鏈子集並使用一種稱為_簡化支付驗證_（SPV）的方法部分驗證交易的客戶端提供資料。這些客戶端被稱為((("SPV (簡化支付驗證) 客戶端")))((("輕量級客戶端")))輕量級客戶端。

礦工透過執行專用硬體來解決工作量證明演算法，以競爭創建新區塊。一些礦工經營完整節點，驗證區塊鏈上的每個區塊，而其他礦工是參與礦池挖礦的客戶端，並依賴礦池伺服器為他們提供工作。

使用者錢包可能連接到使用者自己的完整節點，這在桌面 Bitcoin 客戶端中有時是這種情況，但許多使用者錢包，特別是那些在資源受限裝置（例如智慧型手機）上執行的錢包，是輕量級節點。

除了 Bitcoin P2P 協議上的主要節點類型之外，還有執行其他協議的伺服器和節點，例如專用的礦池協議和輕量級客戶端存取協議。

=== 網路

截至本文撰寫時，((("比特幣網路", "節點", "數量")))((("節點", "數量")))執行 Bitcoin P2P 協議的主要 Bitcoin 網路由大約 10,000 個監聽節點組成，這些節點執行各種版本的 Bitcoin Core，以及數百個節點執行 Bitcoin P2P 協議的其他各種實現，例如 BitcoinJ、btcd 和 bcoin。Bitcoin P2P 網路上的一小部分節點也是挖礦節點。各種個人和公司透過執行存檔完整節點與 Bitcoin 網路介接，具有區塊鏈的完整副本和網路節點，但沒有挖礦或錢包功能。這些節點充當網路邊緣路由器，允許在其上建立各種其他服務（交易所、錢包、區塊瀏覽器、商家支付處理）。


[role="less_space pagebreak-before"]
=== 緊湊區塊中繼

當礦工((("比特幣網路", "節點", "緊湊區塊中繼", id="bitcoin-network-node-compact-relay")))((("節點", "緊湊區塊中繼", id="node-compact-relay")))((("區塊", "緊湊區塊中繼", id="block-compact-relay")))((("緊湊區塊中繼", id="compact-block-relay")))((("挖礦", "區塊", "緊湊區塊中繼", id="mining-block-compact-relay")))找到新區塊時，他們會向 Bitcoin 網路（包括其他礦工）宣布它。找到該區塊的礦工可以立即開始在其頂部建立；所有尚未了解該區塊的其他礦工將繼續在先前的區塊頂部建立，直到他們了解它為止。

如果在他們了解新區塊之前，其中一個其他礦工創建了一個區塊，他們的區塊將與第一個礦工的新區塊競爭。只有一個區塊會被所有完整節點使用的區塊鏈包含，礦工只會因被廣泛接受的區塊而獲得報酬。

哪個區塊首先在其頂部建立第二個區塊就獲勝（除非出現另一次接近的平局），這被((("區塊發現競賽")))稱為_區塊發現競賽_，如 <<mining_race>> 所示。區塊發現競賽給最大的礦工帶來優勢，因此它們與 Bitcoin 的基本去中心化相對立。為了防止區塊發現競賽並允許任何規模的礦工平等參與 Bitcoin 挖礦這個抽獎，最小化一個礦工宣布新區塊與其他礦工收到該區塊之間的時間非常有用。

[[mining_race]]
.需要挖礦競賽的區塊鏈分叉。
image::images/mbc3_1001.png["Mining race"]

2015 年，新版本的 Bitcoin Core 添加了一個稱為_緊湊區塊中繼_的功能（在 BIP152 中指定），允許更快地傳輸新區塊並使用更少的頻寬。

作為背景，中繼未確認交易的完整節點也在其記憶池中儲存許多這些交易（請參見 <<mempool>>）。當其中一些交易在新區塊中確認時，節點不需要接收這些交易的第二個副本。

緊湊區塊允許對等節點為每筆交易發送一個簡短的 6 位元組識別碼，而不是接收冗餘的未確認交易。當您的節點收到帶有一個或多個識別碼的緊湊區塊時，它會檢查其記憶池中的這些交易，如果找到則使用它們。對於在您的本地節點記憶池中找不到的任何交易，您的節點可以向對等節點發送請求以獲取副本。

相反，如果遠端對等節點認為您的節點記憶池沒有區塊中出現的某些交易，它可以在緊湊區塊中包含這些交易的副本。例如，Bitcoin Core 始終發送區塊的 coinbase 交易。

如果遠端對等節點正確猜測您的節點記憶池中有哪些交易，以及沒有哪些交易，它將以幾乎理論上可能的效率發送區塊（對於典型的區塊，效率將在 97% 到 99% 之間）。

[TIP]
====
緊湊區塊中繼不會減小區塊的大小。它只是防止節點已經擁有的資訊的冗餘傳輸。當節點之前沒有關於區塊的資訊時，例如當節點首次啟動時，它必須接收每個區塊的完整副本。
====

Bitcoin Core 目前為發送緊湊區塊實現了兩種模式，如 <<bip152_illustration>> 所示：

低頻寬模式::
  當您的((("低頻寬模式（緊湊區塊中繼）")))節點請求對等節點使用低頻寬模式（預設）時，該對等節點將告訴您的節點新區塊的 32 位元組識別碼（標頭雜湊），但不會向您的節點發送有關它的任何詳細資訊。如果您的節點首先從另一個來源獲取該區塊，這可以避免浪費任何更多的頻寬獲取該區塊的冗餘副本。如果您的節點確實需要該區塊，它將請求緊湊區塊。

高頻寬模式::
  當您的節點((("高頻寬模式（緊湊區塊中繼）")))請求對等節點使用高頻寬模式時，該對等節點將向您的節點發送新區塊的緊湊區塊，甚至在它完全驗證該區塊有效之前。對等節點將執行的唯一驗證是確保區塊的標頭包含正確數量的工作量證明。由於工作量證明的生成成本很高（在撰寫本文時約為 150,000 美元），礦工不太可能偽造它只是為了浪費中繼節點的頻寬。在中繼之前跳過驗證允許新區塊以每跳的最小延遲在網路中傳播。
+
高頻寬模式的缺點是您的節點可能會從它選擇的每個高頻寬對等節點接收冗餘資訊。截至本文撰寫時，Bitcoin Core 目前僅要求三個對等節點使用高頻寬模式（並且它試圖選擇具有快速宣布區塊歷史的對等節點）。

// released into the public domain by Nicolas Dorier
[[bip152_illustration]]
.BIP152 模式比較（來自 BIP152）。陰影條表示節點驗證區塊所需的時間。
image::images/mbc3_1002.png["BIP152"]

這兩種方法的名稱（取自 BIP152）可能有點令人困惑。低頻寬模式透過在大多數情況下不發送區塊來節省頻寬。高頻寬模式使用的頻寬比低頻寬模式多，但在大多數情況下，比實現緊湊區塊之前用於區塊中繼的頻寬少((("比特幣網路", "節點", "緊湊區塊中繼", startref="bitcoin-network-node-compact-relay")))((("節點", "緊湊區塊中繼", startref="node-compact-relay")))((("區塊", "緊湊區塊中繼", startref="block-compact-relay")))((("緊湊區塊中繼", startref="compact-block-relay")))((("挖礦", "區塊", "緊湊區塊中繼", startref="mining-block-compact-relay")))得多。

=== 私有區塊中繼網路

儘管((("比特幣網路", "節點", "私有區塊中繼", id="bitcoin-network-node-private-relay")))((("節點", "私有區塊中繼", id="node-private-relay")))((("區塊", "私有區塊中繼", id="block-private-relay")))((("私有區塊中繼", id="private-block-relay")))((("挖礦", "區塊", "私有區塊中繼", id="mining-block-private-relay")))緊湊區塊在最小化區塊在網路中傳播所需的時間方面大有幫助，但可以進一步最小化延遲。然而，與緊湊區塊不同，其他解決方案涉及權衡，使它們無法用於或不適合公共 P2P 中繼網路。因此，人們對區塊的私有中繼網路進行了實驗。

一種簡單的技術是預先選擇端點之間的路由。例如，在靠近主要跨洋光纖線路的資料中心執行伺服器的中繼網路可能能夠比等待區塊到達距離光纖線路數公里的某個家庭使用者執行的節點更快地轉發新區塊。

另一種更複雜的技術是((("FEC（前向錯誤更正）")))((("前向錯誤更正（FEC）")))前向錯誤更正（FEC）。這允許將緊湊區塊訊息拆分為幾個部分，每個部分都附加了額外的資料。如果其中任何部分未收到，則可以從收到的部分重建該部分。根據設定，如果遺失，最多可以重建幾個部分。

FEC 避免了由於底層網路連接問題而導致緊湊區塊（或其某些部分）未到達的問題。這些問題經常發生，但我們通常不會注意到它們，因為我們主要使用自動重新請求遺失資料的協議。但是，請求遺失的資料會使接收時間增加三倍。例如：

1. Alice 向 Bob 發送一些資料。
2. Bob 沒有收到資料（或資料已損壞）。Bob 向 Alice 重新請求資料。
3. Alice 再次發送資料。

第三種技術是假設所有接收資料的節點在其記憶池中幾乎擁有所有相同的交易，因此它們都可以接受相同的緊湊區塊。這不僅可以節省我們在每跳計算緊湊區塊的時間，而且意味著每跳都可以在驗證之前簡單地將 FEC 封包中繼到下一跳。

前面每種方法的權衡是它們在中心化情況下運作良好，但在去中心化網路中（個別節點無法信任其他節點）則不然。資料中心的伺服器需要花錢，並且通常可以由資料中心的營運商存取，使它們比安全的家用電腦更不可信。在驗證之前中繼資料很容易浪費頻寬，因此只能在私有網路上合理使用，在該網路中各方之間存在一定程度的信任和問責。

開發人員 Matt Corallo 於 2015 年創建了原始的 https://oreil.ly/30ZKi[Bitcoin Relay Network]((("Bitcoin Relay Network")))，以實現礦工之間以非常低的延遲快速同步區塊。該網路由託管在世界各地基礎設施上的幾個虛擬私有伺服器（VPS）組成，並用於連接大多數礦工和礦池。

2016 年，隨著((("FIBRE（快速網際網路比特幣中繼引擎）")))((("快速網際網路比特幣中繼引擎（FIBRE）"))_快速網際網路比特幣中繼引擎_或 https://bitcoinfibre.org[_FIBRE_] 的引入，原始的 Bitcoin Relay Network 被取代，該引擎也由開發人員 Matt Corallo 創建。FIBRE 是允許操作基於 UDP 的中繼網路的軟體，該網路在節點網路內中繼區塊。FIBRE 實現了 FEC 和_緊湊區塊_優化，以進一步減少傳輸的資料量和((("比特幣網路", "節點", "私有區塊中繼", startref="bitcoin-network-node-private-relay")))((("節點", "私有區塊中繼", startref="node-private-relay")))((("區塊", "私有區塊中繼", startref="block-private-relay")))((("私有區塊中繼", startref="private-block-relay")))((("挖礦", "區塊", "私有區塊中繼", startref="mining-block-private-relay")))網路延遲。

=== 網路發現

當新((("比特幣網路", "節點", "網路發現", id="bitcoin-network-node-discovery")))((("節點", "網路發現", id="node-discovery")))((("網路發現", id="network-discovery")))節點啟動時，它必須發現網路上的其他 Bitcoin 節點才能參與。要開始此過程，新節點必須發現網路上至少一個現有節點並連接到它。其他節點的地理位置無關；Bitcoin 網路拓撲沒有地理定義。因此，可以隨機選擇任何現有的 Bitcoin 節點。

要連接到已知的對等節點，節點會建立 TCP 連接，通常連接到埠 8333（通常稱為 Bitcoin 使用的埠），或者如果提供了替代埠，則連接到替代埠。建立連接後，節點將透過傳輸 +version+ 訊息來啟動「握手」（請參見 <<network_handshake>>），該訊息包含基本識別資訊，包括：

+Version+:: 客戶端「說」的 Bitcoin P2P 協議版本（例如，70002）
+nLocalServices+:: 節點支援的本地服務列表
+nTime+:: 當前時間
+addrYou+:: 從該節點看到的遠端節點的 IP 位址
+addrMe+:: 本地節點發現的本地節點的 IP 位址
+subver+:: 顯示在此節點上執行的軟體類型的子版本（例如，[.keep-together]#+/Satoshi:0.9.2.1/+#）
+BestHeight+:: 此節點區塊鏈的區塊高度
+fRelay+:: BIP37 添加的欄位，用於請求不接收未確認的交易

+version+ 訊息始終是任何對等節點向另一個對等節點發送的第一條訊息。接收 +version+ 訊息的本地對等節點將檢查遠端對等節點報告的 +Version+，並決定遠端對等節點是否相容。如果遠端對等節點相容，本地對等節點將確認 +version+ 訊息並透過發送 +verack+ 建立連接。

[role="less_space pagebreak-before"]
新節點如何找到對等節點？第一種方法是使用多個 _DNS 種子_查詢 DNS，這些((("DNS 種子")))DNS 伺服器提供 Bitcoin 節點的 IP 位址列表。其中一些 DNS 種子提供穩定 Bitcoin 監聽節點的靜態 IP 位址列表。一些 DNS 種子是 BIND（Berkeley Internet Name Daemon）的自訂實現，它們從由爬蟲或長時間執行的 Bitcoin 節點收集的 Bitcoin 節點位址列表中返回隨機子集。Bitcoin Core 客戶端包含幾個不同 DNS 種子的名稱。不同 DNS 種子的所有權多樣性和實現多樣性為初始引導過程提供了高度的可靠性。在 Bitcoin Core 客戶端中，使用 DNS 種子的選項由選項開關 +-dnsseed+ 控制（預設設定為 1，以使用 DNS 種子）。

或者，對網路一無所知的引導節點必須獲得至少一個 Bitcoin 節點的 IP 位址，之後它可以透過進一步的介紹建立連接。命令列參數 +-seednode+ 可用於連接到一個節點，僅將其用作種子進行介紹。在使用初始種子節點進行介紹後，客戶端將與其斷開連接並使用新發現的對等節點。

[[network_handshake]]
.對等節點之間的初始握手。
image::images/mbc3_1003.png["NetworkHandshake"]

建立一個或多個連接後，新節點將向其鄰居發送包含其自己 IP 位址的 +addr+ 訊息。鄰居將依次將 +addr+ 訊息轉發給他們的鄰居，確保新連接的節點廣為人知並更好地連接。此外，新連接的節點可以向其鄰居發送 +getaddr+，要求他們返回其他對等節點的 IP 位址列表。這樣，節點可以找到要連接的對等節點，並在網路上宣傳其存在，以便其他節點找到它。<<address_propagation>> 顯示了位址發現協議。


[[address_propagation]]
.位址傳播和發現。
image::images/mbc3_1004.png["AddressPropagation"]

節點必須連接到幾個不同的對等節點，以便建立到 Bitcoin 網路的多樣化路徑。路徑不可靠——節點來來去去——因此節點必須在失去舊連接時繼續發現新節點，並在其他節點引導時協助它們。只需要一個連接即可引導，因為第一個節點可以向其對等節點提供介紹，並且這些對等節點可以提供進一步的介紹。連接到超過少數幾個節點也是不必要的，並且會浪費網路資源。引導後，節點將記住其最近成功的對等連接，以便如果它重新啟動，它可以快速與其先前的對等網路重新建立連接。如果先前的對等節點都沒有回應其連接請求，該節點可以再次使用種子節點進行引導。

在執行 Bitcoin Core 客戶端的節點上，您可以使用命令 +getpeerinfo+ 列出對等連接：

[source,bash]
----
$ bitcoin-cli getpeerinfo
----
[source,json]
----
[
  {
    "id": 0,
    "addr": "82.64.116.5:8333",
    "addrbind": "192.168.0.133:50564",
    "addrlocal": "72.253.6.11:50564",
    "network": "ipv4",
    "services": "0000000000000409",
    "servicesnames": [
      "NETWORK",
      "WITNESS",
      "NETWORK_LIMITED"
    ],
    "lastsend": 1683829947,
    "lastrecv": 1683829989,
    "last_transaction": 0,
    "last_block": 1683829989,
    "bytessent": 3558504,
    "bytesrecv": 6016081,
    "conntime": 1683647841,
    "timeoffset": 0,
    "pingtime": 0.204744,
    "minping": 0.20337,
    "version": 70016,
    "subver": "/Satoshi:24.0.1/",
    "inbound": false,
    "bip152_hb_to": true,
    "bip152_hb_from": false,
    "startingheight": 788954,
    "presynced_headers": -1,
    "synced_headers": 789281,
    "synced_blocks": 789281,
    "inflight": [
    ],
    "relaytxes": false,
    "minfeefilter": 0.00000000,
    "addr_relay_enabled": false,
    "addr_processed": 0,
    "addr_rate_limited": 0,
    "permissions": [
    ],
    "bytessent_per_msg": {
      ...
    },
    "bytesrecv_per_msg": {
      ...
    },
    "connection_type": "block-relay-only"
  },
]
----

要覆寫對等節點的自動管理並指定 IP 位址列表，使用者可以提供選項 +-connect=<IPAddress>+ 並指定一個或多個 IP 位址。如果使用此選項，節點將僅連接到選定的 IP 位址，而不是自動發現和維護對等連接。

如果連接上沒有流量，節點將定期發送訊息以維護連接。如果節點在連接上長時間沒有通訊，則假定它已斷開連接，並將尋找新的對等節點。因此，網路動態地適應暫時的節點和網路問題，並可以根據需要有機地成長和收縮，無需任何((("比特幣網路", "節點", "網路發現", startref="bitcoin-network-node-discovery")))((("節點", "網路發現", startref="node-discovery")))((("網路發現", startref="network-discovery")))中心控制。

=== 完整節點

完整節點((("比特幣網路", "完整節點，目的")))((("完整節點", "目的")))是在具有最多工作量證明的有效區塊鏈上驗證每個區塊中每筆交易的節點。

完整節點獨立處理每個區塊，從第一個區塊（創世區塊）之後開始，一直建立到網路中最新的已知區塊。完整節點可以獨立且權威地驗證任何交易。完整節點依賴網路接收有關新交易區塊的更新，然後驗證這些更新並將其納入其本地視圖中，了解哪些腳本控制哪些比特幣，稱為((("UTXO（未花費交易輸出）"))_未花費交易輸出_（UTXO）集。

執行完整節點為您提供純粹的 Bitcoin 體驗：獨立驗證所有交易，無需依賴或信任任何其他系統。

有一些完整節點的替代實現，使用不同的程式語言和軟體架構構建，或者做出了不同的設計決策。但是，最常見的實現是 Bitcoin Core。Bitcoin 網路上超過 95% 的完整節點執行各種版本的 Bitcoin Core。它在 +version+ 訊息中發送的子版本字串中被識別為「Satoshi」，並由命令 +getpeerinfo+ 顯示，如我們之前看到的；例如，[.keep-together]#+/Satoshi:24.0.1/+#。

=== 交換「清單」

完整節點((("比特幣網路", "節點", "同步區塊鏈", id="bitcoin-network-node-sync")))((("節點", "同步區塊鏈", id="node-sync")))((("完整節點", "同步區塊鏈", id="full-node-sync")))((("區塊鏈", "同步", id="blockchain-sync")))((("同步區塊鏈", id="sync-blockchain")))連接到對等節點後首先要做的事情是嘗試構建完整的區塊標頭鏈。如果它是一個全新的節點，並且根本沒有區塊鏈，它只知道一個區塊，即創世區塊，該區塊靜態嵌入在客戶端軟體中。從區塊 #0（創世區塊）之後開始，新節點將必須下載數十萬個區塊才能與網路同步並重新建立完整的區塊鏈。

同步區塊鏈的過程從 +version+ 訊息開始，因為該訊息包含 +BestHeight+，即節點的當前區塊鏈高度（區塊數）。節點將看到來自其對等節點的 +version+ 訊息，知道它們各自擁有多少個區塊，並能夠與它自己的區塊鏈中擁有的區塊數進行比較。對等節點將交換 +getheaders+ 訊息，該訊息包含其本地區塊鏈頂部區塊的雜湊。其中一個對等節點將能夠將接收到的雜湊識別為屬於不在頂部的區塊，而是屬於較舊的區塊，從而推斷其自己的本地區塊鏈比遠端節點的區塊鏈長。

擁有較長區塊鏈的對等節點比另一個節點擁有更多的區塊，並且可以識別另一個節點需要哪些標頭才能「趕上」。它將使用 +headers+ 訊息識別要共享的前 2,000 個標頭。節點將繼續請求額外的標頭，直到它收到遠端對等節點聲稱擁有的每個區塊的標頭。

同時，節點將開始使用 +getdata+ 訊息請求先前收到的每個標頭的區塊。節點將從其每個選定的對等節點請求不同的區塊，這使它能夠斷開與明顯慢於平均速度的對等節點的連接，以便找到較新（可能更快）的對等節點。

例如，假設一個節點只有創世區塊。然後，它將從其對等節點接收 +headers+ 訊息，其中包含鏈中接下來 2,000 個區塊的標頭。它將開始從所有連接的對等節點請求區塊，保持最多 1,024 個區塊的佇列。區塊需要按順序驗證，因此如果佇列中最舊的區塊——節點接下來需要驗證的區塊——尚未收到，節點會斷開與應該提供該區塊的對等節點的連接。然後，它會找到一個新的對等節點，該節點可能能夠在節點的所有其他對等節點能夠提供 1,023 個區塊之前提供一個區塊。

當收到每個區塊時，它會被添加到區塊鏈中，如我們將在 <<blockchain>> 中看到的。隨著本地區塊鏈逐漸建立，將請求和接收更多區塊，該過程將繼續，直到節點趕上網路的其餘部分。

這個將本地區塊鏈與對等節點進行比較並檢索任何遺失區塊的過程會在節點離線一段((("比特幣網路", "節點", "同步區塊鏈", startref="bitcoin-network-node-sync")))((("節點", "同步區塊鏈", startref="node-sync")))((("完整節點", "同步區塊鏈", startref="full-node-sync")))((("區塊鏈", "同步", startref="blockchain-sync")))((("同步區塊鏈", startref="sync-blockchain")))時間後發生。

[[spv_nodes]]
=== 輕量級客戶端

許多((("比特幣網路", "輕量級客戶端", id="bitcoin-network-lightweight")))((("輕量級客戶端", id="lightweight")))((("SPV (簡化支付驗證) 客戶端", id="spv-lightweight")))Bitcoin 客戶端設計為在空間和功率受限的裝置上執行，例如智慧型手機、平板電腦或嵌入式系統。對於此類裝置，使用_簡化支付驗證_（SPV）方法，允許它們在不驗證完整區塊鏈的情況下運作。這些類型的客戶端稱為輕量級客戶端。

輕量級客戶端僅下載區塊標頭，不下載每個區塊中包含的交易。產生的標頭鏈（不包含交易）比完整區塊鏈小約 10,000 倍。輕量級客戶端無法構建可用於花費的所有 UTXO 的完整圖片，因為它們不知道網路上的所有交易。相反，它們使用稍微不同的方法驗證交易，該方法依賴於對等節點按需提供區塊鏈相關部分的部分視圖。

作為類比，完整節點就像一個陌生城市的遊客，配備了每條街道和每個地址的詳細地圖。相比之下，輕量級客戶端就像一個陌生城市的遊客，在只知道一條主要大道的情況下向隨機陌生人詢問逐轉彎指示。雖然兩位遊客都可以透過訪問街道來驗證街道的存在，但沒有地圖的遊客不知道任何小巷下有什麼，也不知道存在哪些其他街道。站在 23 Church Street 前面，沒有地圖的遊客無法知道城市中是否還有十幾個其他 [.keep-together]#「23 Church# Street」地址，以及這是否是正確的地址。沒有地圖的遊客最好的機會是詢問足夠多的人，並希望其中一些人不是想搶劫他。

輕量級客戶端透過參考其在區塊鏈中的_深度_來驗證交易。完整節點將構建一個完全驗證的鏈，其中包含數千個區塊和數百萬筆交易，一直沿著區塊鏈向下（回到過去）到創世區塊，而輕量級客戶端將驗證所有區塊的工作量證明（但不驗證區塊及其所有交易是否有效），並將該鏈連結到感興趣的交易。

例如，在檢查區塊 800,000 中的交易時，完整節點會驗證從創世區塊到 800,000 的所有區塊，並建立完整的 UTXO 資料庫，透過確認交易存在且其輸出仍未花費來確立交易的有效性。輕量級客戶端只能驗證交易存在。客戶端使用 _merkle 路徑_（請參見 <<merkle_trees>>）在交易和包含它的區塊之間建立連結。然後，輕量級客戶端等待，直到它看到堆疊在包含該交易的區塊頂部的六個區塊 800,001 到 800,006，並透過在區塊 800,006 到 800,001 下建立其深度來驗證它。網路上其他節點接受了區塊 800,000，並且礦工完成了在其頂部產生另外六個區塊所需的工作這一事實，透過代理證明了交易實際存在。

通常無法說服輕量級客戶端交易存在於區塊中（當交易實際上不存在時）。輕量級客戶端透過請求 merkle 路徑證明並透過驗證區塊鏈中的工作量證明來確立交易在區塊中的存在。但是，交易的存在可以對輕量級客戶端「隱藏」。輕量級客戶端絕對可以驗證交易存在，但無法驗證交易（例如同一 UTXO 的雙重花費）不存在，因為它沒有所有交易的記錄。這個漏洞可用於針對輕量級客戶端的拒絕服務攻擊或雙重花費攻擊。為了防禦這一點，輕量級客戶端需要隨機連接到多個客戶端，以增加它與至少一個誠實節點接觸的機率。這種需要隨機連接意味著輕量級客戶端也容易受到網路分區攻擊或女巫攻擊，在這些攻擊中，它們連接到假節點或假網路，無法存取誠實節點或真實的 Bitcoin 網路。

對於許多實際目的，連接良好的輕量級客戶端足夠安全，在資源需求、實用性和安全性之間取得平衡。然而，對於萬無一失的安全性，沒有什麼比執行完整節點更好。

[TIP]
====
完整節點透過檢查其下方數千個區塊的整個鏈來驗證交易，以保證 UTXO 存在且未花費，而輕量級客戶端僅證明交易存在，並檢查包含該交易的區塊是否被其上方的少數區塊掩埋。
====

要獲取驗證交易是鏈的一部分所需的區塊標頭，輕量級客戶端使用 +getheaders+ 訊息。回應的對等節點將使用單個 +headers+ 訊息發送最多 2,000 個區塊標頭。請參見 <<spv_synchronization>> 中的插圖。

[[spv_synchronization]]
.輕量級客戶端同步區塊標頭。
image::images/mbc3_1005.png["Header synchronization"]

區塊標頭允許輕量級客戶端驗證任何單獨的區塊屬於具有最多工作量證明的區塊鏈，但它們不會告訴客戶端哪些區塊包含其錢包感興趣的交易。客戶端可以下載每個區塊並檢查，但這將使用執行完整節點所需資源的很大一部分，因此開發人員一直在尋找其他方法來解決這個問題。

在輕量級客戶端引入後不久，Bitcoin 開發人員添加了一個稱為_布隆過濾器_的功能，試圖減少輕量級客戶端了解其傳入和傳出交易所需使用的頻寬。布隆過濾器允許輕量級客戶端接收交易的子集，而無需直接準確地揭示它們感興趣的地址，透過使用機率而不是((("比特幣網路", "輕量級客戶端", startref="bitcoin-network-lightweight")))((("輕量級客戶端", startref="lightweight")))((("SPV (簡化支付驗證) 客戶端", startref="spv-lightweight")))固定模式的過濾機制。

[[bloom_filters]]
=== 布隆過濾器

布隆過濾器((("比特幣網路", "布隆過濾器", "操作概述", id="bitcoin-network-bloom-overview")))((("布隆過濾器", "操作概述", id="bloom-overview")))是一種機率搜尋過濾器，是一種描述所需模式而無需精確指定它的方式。布隆過濾器提供了一種有效的方式來表達搜尋模式，同時保護隱私。它們被輕量級客戶端用來向其對等節點詢問與特定模式匹配的交易，而無需準確揭示它們正在搜尋哪些地址、金鑰或交易。

在我們之前的類比中，一個沒有地圖的遊客正在詢問前往特定地址「23 Church St.」的方向。如果他們向陌生人詢問前往這條街道的方向，他們就會無意中洩露了他們的目的地。布隆過濾器就像詢問「這個社區有沒有名稱以 R-C-H 結尾的街道？」這樣的問題比詢問「23 Church St.」洩露的目的地資訊稍微少一些。使用這種技術，遊客可以更詳細地指定所需地址，例如「以 U-R-C-H 結尾」，或者不那麼詳細，例如「以 H 結尾」。透過改變搜尋的精確度，遊客會以獲得更多或更少的特定結果為代價來洩露更多或更少的資訊。如果他們詢問一個不太特定的模式，他們會得到更多可能的地址和更好的隱私，但許多結果是不相關的。如果他們詢問一個非常特定的模式，他們會得到更少的結果，但失去隱私。

布隆過濾器透過允許輕量級客戶端為交易指定一個搜尋模式來實現此功能，該模式可以根據精確度或隱私進行調整。更特定的布隆過濾器將產生準確的結果，但代價是洩露輕量級客戶端感興趣的模式，從而洩露使用者錢包擁有的地址。不太特定的布隆過濾器將產生更多關於更多交易的資料，其中許多與客戶端無關，但將允許客戶端維持更好的隱私。

==== 布隆過濾器的運作方式

布隆過濾器被實現為 N 個二進位數字的可變大小陣列（位元欄位）和可變數量的 M 個雜湊函數。雜湊函數被設計為始終產生 1 到 N 之間的輸出，對應於二進位數字陣列。雜湊函數是確定性生成的，因此任何實現布隆過濾器的客戶端將始終使用相同的雜湊函數，並對特定輸入獲得相同的結果。透過選擇不同長度（N）的布隆過濾器和不同數量（M）的雜湊函數，可以調整布隆過濾器，改變準確度和隱私的等級。

在 <<bloom1>> 中，我們使用一個非常小的 16 位元陣列和一組三個雜湊函數來演示布隆過濾器的運作方式。

[[bloom1]]
.一個簡單的布隆過濾器範例，具有 16 位元欄位和三個雜湊函數。
image::images/mbc3_1006.png["Bloom1"]

布隆過濾器被初始化，使得位元陣列全部為零。要將模式添加到布隆過濾器，該模式依次由每個雜湊函數進行雜湊處理。將第一個雜湊函數應用於輸入會產生一個 1 到 N 之間的數字。找到陣列中的對應位元（從 1 到 N 索引），並將其設定為 +1+，從而記錄雜湊函數的輸出。然後，使用下一個雜湊函數來設定另一個位元，依此類推。一旦應用了所有 M 個雜湊函數，搜尋模式將作為已從 +0+ 更改為 +1+ 的 M 個位元「記錄」在布隆過濾器中。

<<bloom2>> 是將模式「A」添加到 <<bloom1>> 中所示的簡單布隆過濾器的範例。

添加第二個模式就像重複此過程一樣簡單。該模式依次由每個雜湊函數進行雜湊處理，並透過將位元設定為 +1+ 來記錄結果。請注意，隨著布隆過濾器填充更多模式，雜湊函數結果可能與已設定為 +1+ 的位元重合，在這種情況下，位元不會更改。本質上，隨著更多模式記錄在重疊位元上，布隆過濾器開始變得飽和，更多位元被設定為 +1+，過濾器的準確度會降低。這就是為什麼過濾器是一個機率資料結構——隨著添加更多模式，它變得不太準確。準確度取決於添加的模式數量與位元陣列大小（N）和雜湊函數數量（M）的比較。更大的位元陣列和更多的雜湊函數可以以更高的準確度記錄更多模式。較小的位元陣列或較少的雜湊函數將記錄較少的模式，並產生較低的準確度。

[[bloom2]]
.將模式「A」添加到我們的簡單布隆過濾器。
image::images/mbc3_1007.png["Bloom2"]

<<bloom3>> 是將第二個模式「B」添加到簡單布隆過濾器的範例。

[[bloom3]]
.將第二個模式「B」添加到我們的簡單布隆過濾器。
image::images/mbc3_1008.png["Bloom3"]

[role="less_space pagebreak-before"]
要測試模式是否是布隆過濾器的一部分，該模式由每個雜湊函數進行雜湊處理，並將產生的位元模式與位元陣列進行測試。如果雜湊函數索引的所有位元都設定為 +1+，則該模式_可能_記錄在布隆過濾器中。由於位元可能因為多個模式的重疊而被設定，因此答案不是確定的，而是機率的。簡單來說，布隆過濾器的正面匹配是「可能，是的。」

<<bloom4>> 是測試簡單布隆過濾器中模式「X」是否存在的範例。對應的位元設定為 +1+，因此該模式可能是匹配的。

[[bloom4]]
.測試布隆過濾器中模式「X」的存在。結果是機率正面匹配，意思是「可能」。
image::images/mbc3_1009.png["Bloom4"]

相反地，如果對布隆過濾器測試一個模式，並且任何一個位元設定為 +0+，這證明該模式沒有記錄在布隆過濾器中。負面結果不是機率，它是確定性的。簡單來說，布隆過濾器的負面匹配是「絕對不是！」

<<bloom5>> 是測試簡單布隆過濾器中模式「Y」是否存在的範例。其中一個對應的位元設定為 +0+，因此該模式絕對((("比特幣網路", "布隆過濾器", "操作概述", startref="bitcoin-network-bloom-overview")))((("布隆過濾器", "操作概述", startref="bloom-overview")))不是匹配的。

[[bloom5]]
.測試布隆過濾器中模式「Y」的存在。結果是確定性負面匹配，意思是「絕對不是！」
image::images/mbc3_1010.png[]

==== 輕量級客戶端如何使用布隆過濾器

布隆過濾器((("比特幣網路", "布隆過濾器", "輕量級客戶端和", id="bitcoin-network-bloom-lightweight")))((("布隆過濾器", "輕量級客戶端和", id="bloom-lightweight")))((("輕量級客戶端", "布隆過濾器和", id="lightweight-bloom")))被用來過濾輕量級客戶端從其對等節點接收的交易（和包含它們的區塊），選擇僅對輕量級客戶端感興趣的交易，而無需準確揭示它感興趣的地址或金鑰。

輕量級客戶端將布隆過濾器初始化為「空」；在該狀態下，布隆過濾器將不匹配任何模式。然後，輕量級客戶端將列出它感興趣的所有地址、金鑰和雜湊。它將透過從其錢包控制的任何 UTXO 中提取公鑰雜湊、腳本雜湊和交易 ID 來執行此操作。然後，輕量級客戶端將這些每一個添加到布隆過濾器中，以便如果這些模式出現在交易中，布隆過濾器將「匹配」，而無需洩露模式本身。

然後，輕量級客戶端將發送一個 +filterload+ 訊息給對等節點，其中包含要在連接上使用的布隆過濾器。在對等節點上，布隆過濾器會針對每個傳入交易進行檢查。完整節點會根據布隆過濾器檢查交易的幾個部分，尋找匹配，包括：

++++
<ul>
<li>交易 ID</li>
<li>每個交易輸出的腳本中的資料元件（腳本中的每個金鑰和雜湊）</li>
<li class="less_space pagebreak-before">每個交易輸入</li>
<li>每個輸入簽章資料元件（或見證腳本）</li>
</ul>
++++


透過檢查所有這些元件，布隆過濾器可用於匹配公鑰雜湊、腳本、+OP_RETURN+ 值、簽章中的公鑰，或任何未來的智慧合約或複雜腳本元件。

建立過濾器後，對等節點將針對布隆過濾器測試每個交易的輸出。只有匹配過濾器的交易才會被發送到客戶端。

為了回應來自客戶端的 +getdata+ 訊息，對等節點將發送一個 +merkleblock+ 訊息，其中僅包含與過濾器匹配的區塊的區塊標頭，以及每個匹配交易的默克爾路徑（參見 <<merkle_trees>>）。然後，對等節點還將發送包含過濾器匹配的交易的 +tx+ 訊息。

當完整節點向輕量級客戶端發送交易時，輕量級客戶端會丟棄任何誤報，並使用正確匹配的交易來更新其 UTXO 集和錢包餘額。當它更新自己對 UTXO 集的檢視時，它也會修改布隆過濾器以匹配任何未來引用它剛剛找到的 UTXO 的交易。然後，完整節點使用新的布隆過濾器來匹配新交易，整個過程重複。

設定布隆過濾器的客戶端可以透過發送 +filteradd+ 訊息以互動方式將模式添加到過濾器。要清除布隆過濾器，客戶端可以發送 +filterclear+ 訊息。由於無法從布隆過濾器中刪除模式，因此如果不再需要某個模式，客戶端必須清除並重新發送新的布隆過濾器。

輕量級客戶端的網路協議和布隆過濾器機制在 BIP37 中定義。

不幸的是，在部署布隆過濾器之後，很明顯它們並沒有提供太多隱私。接收來自對等節點的布隆過濾器的完整節點可以將該過濾器應用於整個區塊鏈，以找到客戶端的所有交易（加上誤報）。然後，它可以尋找交易之間的模式和關係。隨機選擇的誤報交易不太可能具有從輸出到輸入的父子關係，但來自使用者錢包的交易很可能具有該關係。如果所有相關交易都具有某些特徵，例如至少一個 P2PKH 輸出，則可以假設沒有該特徵的交易不屬於該錢包。

還發現了特別構造的過濾器可能會強制處理它們的完整節點執行大量工作，這可能導致拒絕服務攻擊。

由於這兩個原因，Bitcoin Core 最終將對布隆過濾器的支援限制為僅限於節點營運者明確允許的 IP 地址上的客戶端。這意味著需要一種替代方法來幫助輕量級客戶端找到它們的交易((("比特幣網路", "布隆過濾器", "輕量級客戶端和", startref="bitcoin-network-bloom-lightweight")))((("布隆過濾器", "輕量級客戶端和", startref="bloom-lightweight")))((("輕量級客戶端", "布隆過濾器和", startref="lightweight-bloom")))。

=== 緊湊區塊過濾器

// https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012636.html

2016 年，一位匿名開發人員((("比特幣網路", "緊湊區塊過濾器", id="bitcoin-network-compact-filter")))((("緊湊區塊過濾器", id="compact-block-filter")))((("區塊", "緊湊區塊過濾器", id="block-compact-filter")))在 Bitcoin-Dev 郵件列表中提出了一個想法，即反轉布隆過濾器過程。使用 BIP37 布隆過濾器，每個客戶端對其地址進行雜湊處理以創建布隆過濾器，節點對每個交易的部分進行雜湊處理以嘗試匹配該過濾器。在新提案中，節點對區塊中每個交易的部分進行雜湊處理以創建布隆過濾器，客戶端對其地址進行雜湊處理以嘗試匹配該過濾器。如果客戶端找到匹配，它們會下載整個區塊。

[NOTE]
====
儘管名稱相似，BIP152 _緊湊區塊_ 和 BIP157/158 _緊湊區塊過濾器_ 是不相關的。
====

這允許節點為每個區塊創建單個過濾器，他們可以將其保存到磁碟並一次又一次地提供服務，消除了 BIP37 的拒絕服務漏洞。客戶端不會向完整節點提供有關其過去或未來地址的任何資訊。它們只下載區塊，其中可能包含數千筆不是由客戶端創建的交易。它們甚至可以從不同的對等節點下載每個匹配的區塊，使完整節點更難連接屬於單個客戶端的跨多個區塊的交易。

這個服務器生成的過濾器想法並不提供完美的隱私；它仍然對完整節點產生一些成本（並且它確實需要輕量級客戶端使用更多頻寬進行區塊下載），並且過濾器只能用於已確認的交易（而不是未確認的交易）。然而，它比 BIP37 客戶端請求的布隆過濾器更加私密和可靠。

在描述了基於布隆過濾器的原始想法之後，開發人員意識到有一種更好的資料結構用於服務器生成的過濾器，稱為 Golomb-Rice 編碼集合（GCS）。

==== Golomb-Rice 編碼集合（GCS）

假設((("比特幣網路", "緊湊區塊過濾器", "GCS（Golomb-Rice 編碼集合）", id="bitcoin-network-compact-filter-gcs")))((("緊湊區塊過濾器", "GCS（Golomb-Rice 編碼集合）", id="compact-block-filter-gcs")))((("區塊", "緊湊區塊過濾器", "GCS（Golomb-Rice 編碼集合）", id="block-compact-filter-gcs")))((("GCS（Golomb-Rice 編碼集合）", id="gcs-filter")))Alice 想向 Bob 發送一個數字列表。簡單的方法是只向他發送整個數字列表：

----
849
653
476
900
379
----

但有一種更有效的方法。首先，Alice 按數字順序排列列表：

----
379
476
653
849
900
----

然後，Alice 發送第一個數字。對於剩餘的數字，她發送該數字與前一個數字之間的差異。例如，對於第二個數字，她發送 97（476 – 379）；對於第三個數字，她發送 177（653 – 476）；依此類推：

----
379
97
177
196
51
----

我們可以看到，有序列表中兩個數字之間的差異產生的數字比原始數字短。收到此列表後，Bob 可以透過簡單地將每個數字與其前一個數字相加來重建原始列表。這意味著我們在不損失任何資訊的情況下節省了空間，這被((("無損編碼")))稱為_無損編碼_。

如果我們在固定值範圍內隨機選擇數字，那麼我們選擇的數字越多，差異的平均（平均）大小就越小。這意味著我們需要傳輸的資料量不會像列表長度增加那樣快速增加（達到一定程度）。

更有用的是，差異列表中隨機選擇的數字的長度自然偏向較小的長度。考慮從 1 到 6 中選擇兩個隨機數字；這與擲兩個骰子相同。有 36 種不同的兩個骰子組合：

[cols="1,1,1,1,1,1"]
|===
| 1 1 | 1 2 | 1 3 | 1 4 | 1 5 | 1 6
| 2 1 | 2 2 | 2 3 | 2 4 | 2 5 | 2 6
| 3 1 | 3 2 | 3 3 | 3 4 | 3 5 | 3 6
| 4 1 | 4 2 | 4 3 | 4 4 | 4 5 | 4 6
| 5 1 | 5 2 | 5 3 | 5 4 | 5 5 | 5 6
| 6 1 | 6 2 | 6 3 | 6 4 | 6 5 | 6 6
|===

讓我們找出較大數字和較小數字之間的差異：

[role="less_space pagebreak-before"]
[cols="1,1,1,1,1,1"]
|===
| 0 | 1 | 2 | 3 | 4 | 5
| 1 | 0 | 1 | 2 | 3 | 4
| 2 | 1 | 0 | 1 | 2 | 3
| 3 | 2 | 1 | 0 | 1 | 2
| 4 | 3 | 2 | 1 | 0 | 1
| 5 | 4 | 3 | 2 | 1 | 0
|===

如果我們計算每個差異發生的頻率，我們會看到小差異比大差異更有可能發生：

++++
<table>

<thead>
<tr>
<th>差異</th>
<th>出現次數</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>0</p></td>
<td><p>6</p></td>
</tr>
<tr>
<td><p>1</p></td>
<td><p>10</p></td>
</tr>
<tr>
<td><p>2</p></td>
<td><p>8</p></td>
</tr>
<tr>
<td><p>3</p></td>
<td><p>6</p></td>
</tr>
<tr>
<td><p>4</p></td>
<td><p>4</p></td>
</tr>
<tr>
<td><p>5</p></td>
<td><p>2</p></td>
</tr>
</tbody>
</table>
++++

如果我們知道我們可能需要儲存大數字（因為大差異可能發生，即使它們很少見），但我們最常需要儲存小數字，我們可以使用一個系統對每個數字進行編碼，該系統對小數字使用更少的空間，對大數字使用額外的空間。平均而言，該系統將比對每個數字使用相同的空間量表現得更好。

Golomb 編碼提供了該功能。Rice 編碼是 Golomb 編碼的子集，在某些情況下使用更方便，包括 Bitcoin ((("比特幣網路", "緊湊區塊過濾器", "GCS（Golomb-Rice 編碼集合）", startref="bitcoin-network-compact-filter-gcs")))((("緊湊區塊過濾器", "GCS（Golomb-Rice 編碼集合）", startref="compact-block-filter-gcs")))((("區塊", "緊湊區塊過濾器", "GCS（Golomb-Rice 編碼集合）", startref="block-compact-filter-gcs")))((("GCS（Golomb-Rice 編碼集合）", startref="gcs-filter")))區塊過濾器的應用。

==== 區塊過濾器中應包含哪些資料

我們的主要((("比特幣網路", "緊湊區塊過濾器", "包含什麼", id="bitcoin-network-compact-filter-include")))((("緊湊區塊過濾器", "包含什麼", id="compact-block-filter-include")))((("區塊", "緊湊區塊過濾器", "包含什麼", id="block-compact-filter-include")))目標是允許錢包了解區塊是否包含影響該錢包的交易。為了使錢包有效，它需要了解兩種類型的資訊：

當它收到資金時::

具體來說，當交易輸出包含錢包控制的腳本（例如透過控制授權的私鑰）時

當它花費資金時::

具體來說，當交易輸入引用錢包控制的先前交易輸出時

在設計緊湊區塊過濾器期間的次要目標是允許接收過濾器的錢包驗證它從對等節點接收到的是準確的過濾器。例如，如果錢包下載了創建過濾器的區塊，錢包可以生成自己的過濾器。然後，它可以將其過濾器與對等節點的過濾器進行比較，並驗證它們是相同的,證明對等節點生成了準確的過濾器。

為了滿足主要和次要目標，過濾器需要引用兩種類型的資訊：

* 區塊中每個交易的每個輸出的腳本

* 區塊中每個交易的每個輸入的輸出點

緊湊區塊過濾器的早期設計包括這兩種資訊，但人們意識到，如果我們犧牲次要目標，有一種更有效的方式來實現主要目標。在新設計中，區塊過濾器仍然引用兩種類型的資訊，但它們更密切相關：

* 與以前一樣，區塊中每個交易的每個輸出的腳本。

* 在一個變化中，它還會引用區塊中每個交易的每個輸入的輸出點所引用的輸出的腳本。換句話說，正在被花費的輸出腳本。

這有幾個優點。首先，這意味著錢包不需要追蹤輸出點；它們可以只掃描它們預期接收資金的輸出腳本。其次，任何時候區塊中的後續交易花費同一區塊中早期交易的輸出時，它們都將引用相同的輸出腳本。對同一輸出腳本的多次引用在緊湊區塊過濾器中是冗餘的，因此可以刪除冗餘副本，縮小過濾器的大小。

當完整節點驗證一個區塊時，它們需要存取區塊中當前交易輸出的輸出腳本和從先前區塊引用的交易輸出的輸出腳本，因此它們能夠在這個簡化模型中建立緊湊區塊過濾器。但是，區塊本身不包含先前區塊中包含的交易的輸出腳本，因此客戶端沒有方便的方式來驗證區塊過濾器是否正確建立。然而，有一種替代方案可以幫助客戶端檢測對等節點是否在欺騙它：從((("比特幣網路", "緊湊區塊過濾器", "包含什麼", startref="bitcoin-network-compact-filter-include")))((("緊湊區塊過濾器", "包含什麼", startref="compact-block-filter-include")))((("區塊", "緊湊區塊過濾器", "包含什麼", startref="block-compact-filter-include")))多個對等節點獲取相同的過濾器。

==== 從多個對等節點下載區塊過濾器

對等節點((("比特幣網路", "緊湊區塊過濾器", "下載多個", id="bitcoin-network-compact-filter-download")))((("緊湊區塊過濾器", "下載多個", id="compact-block-filter-download")))((("區塊", "緊湊區塊過濾器", "下載多個", id="block-compact-filter-download")))((("下載多個區塊過濾器", id="download-multiple-block")))((("多個區塊過濾器，下載", id="multiple-block-download")))可以向錢包提供不準確的過濾器。有兩種方法可以創建不準確的過濾器。對等節點可以創建一個引用實際上沒有出現在關聯區塊中的交易的過濾器（誤報）。或者，對等節點可以創建一個不引用實際出現在關聯區塊中的交易的過濾器（漏報）。

針對不準確過濾器的第一個保護是讓客戶端從多個對等節點獲取過濾器。BIP157 協議允許客戶端僅下載一個簡短的 32 位元組的過濾器承諾，以確定每個對等節點是否宣傳與客戶端的所有其他對等節點相同的過濾器。如果所有這些對等節點都同意，這最大程度地減少了客戶端必須花費的頻寬來查詢許多不同的對等節點的過濾器。

如果兩個或更多不同的對等節點對同一區塊有不同的過濾器，客戶端可以下載所有這些過濾器。然後，它還可以下載關聯的區塊。如果區塊包含與錢包相關的任何交易，但不是其中一個過濾器的一部分，那麼錢包可以確定創建該過濾器的對等節點是不準確的——Golomb-Rice 編碼集合總是會包含潛在匹配。

或者，如果區塊不包含過濾器說可能匹配錢包的交易，這並不能證明過濾器不準確。為了最小化 GCS 的大小，我們允許一定數量的誤報。錢包可以做的是繼續從對等節點下載額外的過濾器，無論是隨機的還是當它們指示匹配時，然後追蹤客戶端的誤報率。如果它與過濾器設計使用的誤報率顯著不同，錢包可以停止使用該對等節點。在大多數情況下，不準確過濾器的唯一後果是錢包使用的頻寬((("比特幣網路", "緊湊區塊過濾器", "下載多個", startref="bitcoin-network-compact-filter-download")))((("緊湊區塊過濾器", "下載多個", startref="compact-block-filter-download")))((("區塊", "緊湊區塊過濾器", "下載多個", startref="block-compact-filter-download")))((("下載多個區塊過濾器", startref="download-multiple-block")))((("多個區塊過濾器，下載", startref="multiple-block-download")))超過預期。

==== 使用有損編碼減少頻寬

關於((("比特幣網路", "緊湊區塊過濾器", "有損編碼")))((("緊湊區塊過濾器", "有損編碼")))((("區塊", "緊湊區塊過濾器", "有損編碼")))((("有損編碼")))我們想要傳達的區塊中的交易資料是輸出腳本。輸出腳本的長度各不相同並遵循模式，這意味著它們之間的差異不會像我們希望的那樣均勻分佈。然而，我們已經在本書的許多地方看到，我們可以使用雜湊函數來創建對某些資料的承諾，並產生一個看起來像隨機選擇的數字的值。

在本書的其他地方，我們使用了密碼學安全的雜湊函數，它提供了關於其承諾強度和其輸出與隨機的無法區分性的保證。然而，有更快、更可配置的非密碼學雜湊函數，例如我們將用於緊湊區塊過濾器的 SipHash 函數。

BIP158 中描述了所使用演算法的詳細資訊，但要點是使用 SipHash 和一些算術運算將每個輸出腳本減少為 64 位元承諾。您可以將其視為取一組大數字並將它們截斷為較短的數字，這是一個會失去資料的過程（因此稱為_有損編碼_）。透過失去一些資訊，我們不需要稍後儲存那麼多資訊，從而節省空間。在這種情況下，我們從通常為 160 位元或更長的典型輸出腳本降至僅 64 位元。

==== 使用緊湊區塊過濾器

區塊中每個輸出腳本承諾的 64 位元值被排序，刪除重複條目，並透過找到每個條目之間的差異（增量）來構建 GCS。然後，該緊湊區塊過濾器由對等節點分發給其客戶端（例如錢包）。

客戶端使用增量來重建原始承諾。客戶端（例如錢包）也會取得它正在監視的所有輸出腳本，並以與 BIP158 相同的方式生成承諾。它檢查其生成的承諾是否與過濾器中的承諾匹配。

回想一下我們關於緊湊區塊過濾器有損性的例子，類似於截斷數字。假設客戶端正在尋找包含數字 123456 的區塊，而準確（但有損）的緊湊區塊過濾器包含數字 1234。當客戶端看到 1234 時，它將下載關聯的區塊。

有 100% 的保證，包含 1234 的準確過濾器將允許客戶端了解包含 123456 的區塊，稱為_真正面_。然而，也有機會該區塊可能包含 123400、123401 或幾乎一百個其他不是客戶端正在尋找的條目（在此範例中），((("誤報")))稱為_誤報_。

100% 的真正面匹配率非常好。這意味著錢包可以依賴緊湊區塊過濾器來找到影響該錢包的每筆交易。非零誤報率意味著錢包最終會下載一些不包含錢包感興趣的交易的區塊。其主要後果是客戶端將使用額外的頻寬，這不是一個大問題。BIP158 緊湊區塊過濾器的實際誤報率非常低，因此這不是一個主要問題。誤報率也可以幫助改善客戶端的隱私，就像布隆過濾器一樣，儘管任何想要最佳隱私的人仍應使用自己的完整節點。

從長遠來看，一些開發人員主張讓區塊承諾該區塊的過濾器，最有可能的方案是讓每個 coinbase 交易承諾該區塊的過濾器。完整節點將自己計算每個區塊的過濾器，並且僅在包含準確承諾的情況下才接受區塊。這將允許輕量級客戶端下載 80 位元組的區塊標頭、一個（通常）小的 coinbase 交易和該區塊的過濾器，以接收強有力的證據證明過濾器((("比特幣網路", "緊湊區塊過濾器", startref="bitcoin-network-compact-filter")))((("緊湊區塊過濾器", startref="compact-block-filter")))((("區塊", "緊湊區塊過濾器", startref="block-compact-filter")))是準確的。


[role="less_space pagebreak-before"]
=== 輕量級客戶端與隱私

輕量級客戶端((("比特幣網路", "輕量級客戶端", "隱私")))((("輕量級客戶端", "隱私")))((("隱私", "輕量級客戶端")))的隱私比完整節點弱。完整節點下載所有交易，因此不會洩露它是否在其錢包中使用某個地址的資訊。輕量級客戶端僅下載與其錢包以某種方式相關的交易。

布隆過濾器和緊湊區塊過濾器是減少隱私損失的方法。如果沒有它們，輕量級客戶端將不得不明確列出它感興趣的地址，造成嚴重的隱私洩露。然而，即使有過濾器，監視輕量級客戶端流量的對手或作為 P2P 網路中的節點直接連接到它的對手，隨著時間的推移可能能夠收集足夠的資訊來了解輕量級客戶端錢包中的地址。

=== 加密和認證連接

大多數新((("比特幣網路", "加密")))((("加密")))((("Tor 傳輸")))比特幣使用者假設比特幣節點的網路通訊是加密的。事實上，比特幣的原始實現完全以明文通訊，在撰寫本文時，Bitcoin Core 的現代實現也是如此。

作為增加比特幣 P2P 網路隱私和安全性的一種方式，有一種提供通訊加密的解決方案：_Tor 傳輸_。

Tor 代表_洋蔥路由網路_（The Onion Routing network），是一個軟體專案和網路，它透過提供匿名性、不可追溯性和隱私的隨機化網路路徑來提供資料的加密和封裝。

Bitcoin Core ((("Bitcoin Core", "Tor 傳輸")))提供了幾個配置選項，允許您執行一個比特幣節點，其流量透過 Tor 網路傳輸。此外，Bitcoin Core 還可以提供 Tor 隱藏服務，允許其他 Tor 節點直接透過 Tor 連接到您的節點。

從 Bitcoin Core 版本 0.12 開始，如果節點能夠連接到本機 Tor 服務，它將自動提供隱藏的 Tor 服務。如果您已安裝 Tor，並且 Bitcoin Core 程序以具有足夠權限存取 Tor 身份驗證 cookie 的使用者身份執行，它應該可以自動運作。使用 +debug+ 旗標開啟 Bitcoin Core 的 Tor 服務除錯，如下所示：

----
$ bitcoind --daemon --debug=tor
----

您應該在日誌中看到 ++tor: ADD_ONION successful++，表示 Bitcoin Core 已將隱藏服務添加到 Tor 網路。

您可以在 Bitcoin Core 文件（_docs/tor.md_）和各種線上教學中找到更多關於將 Bitcoin Core 作為 Tor 隱藏服務執行的說明。

[role="less_space pagebreak-before"]
[[mempool]]
=== 記憶池和孤兒池

幾乎((("比特幣網路", "記憶池")))((("比特幣網路", "孤兒池")))((("記憶池")))((("孤兒池")))((("未確認交易")))((("交易", "未確認")))比特幣網路上的每個節點都維護一個稱為_記憶池_（_mempool_）的未確認交易的臨時列表。節點使用此池來追蹤網路已知但尚未包含在區塊鏈中的交易，稱為_未確認交易_。

當收到並驗證未確認的交易時，它們被添加到記憶池，並轉發到相鄰節點以在網路上傳播。

一些節點實現還維護一個單獨的孤兒交易池。如果交易的輸入引用尚未知道的交易，例如缺少的父交易，孤兒交易將臨時儲存在孤兒池中，直到父交易到達。

當交易被添加到記憶池時，會檢查孤兒池是否有任何孤兒引用此交易的輸出（其子交易）。然後驗證任何匹配的孤兒。如果有效，它們將從孤兒池中刪除並添加到記憶池，完成從父交易開始的鏈。鑑於新添加的交易不再是孤兒，該過程遞迴重複，尋找任何進一步的後代，直到找不到更多後代。透過這個過程，父交易的到達會觸發一個級聯重建整個相互依賴的交易鏈，透過將孤兒與它們的父交易重新結合，一直到鏈的底部。

一些比特幣實現還維護一個 UTXO 資料庫，這是區塊鏈上所有未花費輸出的集合。這代表與記憶池不同的資料集。與記憶池和孤兒池不同，UTXO 資料庫包含數百萬個未花費交易輸出的條目，從創世區塊一直到現在的所有未花費的東西。UTXO 資料庫作為一個表格儲存在持久性儲存上。

記憶池和孤兒池代表單個節點的本機視角，並且可能根據節點何時啟動或重新啟動而在節點之間有顯著差異，而 UTXO 資料庫代表網路的緊急共識，因此通常不會在節點之間有所不同。

現在我們已經了解了節點和客戶端用於在比特幣網路上發送資料的許多資料類型和結構，是時候看看負責
