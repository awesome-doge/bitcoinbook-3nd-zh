[[mining]]
== 挖礦與共識

((("挖礦", "目的")))「挖礦」這個詞有點誤導。透過喚起對貴金屬的提取，它將我們的注意力集中在挖礦的獎勵上，即在每個區塊中創建的新比特幣。儘管挖礦受到這種獎勵的激勵，但挖礦的主要目的不是獎勵或產生新比特幣。如果您僅將挖礦視為創建比特幣的過程，您就是將手段（激勵）誤認為過程的目標。挖礦是支撐去中心化清算所的機制，交易透過該機制得到驗證和清算。挖礦是使比特幣特別的發明之一，一種去中心化的共識機制，是點對點數位現金的基礎。

挖礦_保護比特幣系統_並使網路範圍內的_共識在沒有中央權威的情況下_出現。新鑄造的比特幣和交易手續費的獎勵是一種激勵機制，將礦工的行動與網路安全對齊，同時實施貨幣供應。

[TIP]
====

挖礦是比特幣的_共識安全性_被_去中心化_的機制之一。
====

礦工((("挖礦", "操作概述", id="mining-overview")))在全球區塊鏈上記錄新交易。一個新區塊，包含自上一個區塊以來發生的交易，平均每 10 分鐘被_挖掘_一次，從而將這些交易添加到區塊鏈。成為區塊一部分並添加到區塊鏈的交易被認為是_已確認_的，這使得比特幣的新擁有者知道不可逆轉的努力被用於保護他們在這些交易中收到的比特幣。

此外，區塊鏈中的交易具有由其在區塊鏈中的位置定義的_拓撲順序_。如果一個交易出現在較早的區塊中，或者它出現在同一區塊中較早的位置，則該交易早於另一個交易。在比特幣協議中，只有當交易花費出現在區塊鏈中較早的交易的輸出時（無論它們是在同一區塊中較早還是在較早的區塊中），並且只有當沒有先前的交易花費任何相同的輸出時，交易才有效。在單個區塊鏈中，拓撲順序的執行確保沒有兩個有效交易可以花費相同的輸出，從而消除了_雙重花費_的問題。

在一些建立在比特幣之上的協議中，比特幣交易的拓撲順序也用於建立事件序列；我們將在 <<single_use_seals>> 中進一步討論這個想法。

礦工((("比特幣", "挖礦", "激勵")))((("挖礦", "激勵")))((("激勵")))因挖礦提供的安全性而獲得兩種類型的獎勵：每個新區塊創建的新比特幣（稱為_補貼_），以及區塊中包含的所有交易的交易手續費。為了賺取這個獎勵，礦工競爭滿足基於密碼學雜湊演算法的挑戰。該問題的解決方案稱為工作量證明，包含在新區塊中，並作為礦工花費大量計算努力的證明。競爭解決工作量證明演算法以賺取獎勵和在區塊鏈上記錄交易的權利是比特幣安全模型的基礎。

比特幣的貨幣供應是在一個類似於中央銀行透過印製紙幣發行新貨幣的過程中創建的。礦工可以添加到區塊中的新創建比特幣的最大數量大約每四年（或精確地每 210,000 個區塊）減少一次。它在 2009 年 1 月開始時為每個區塊 50 比特幣，並在 2012 年 11 月減半至每個區塊 25 比特幣。它在 2016 年 7 月再次減半至 12.5 比特幣，並在 2020 年 5 月再次減半至 6.25。根據這個公式，挖礦獎勵呈指數下降，直到大約 2140 年，屆時所有比特幣都將被發行。2140 年之後，將不再發行新比特幣。

比特幣礦工((("交易手續費")))也從交易中賺取手續費。每筆交易可能包括以交易的輸入和輸出之間的比特幣盈餘形式的交易手續費。獲勝的比特幣礦工可以「保留零錢」在獲勝區塊中包含的交易上。今天，手續費通常僅佔礦工收入的一小部分，絕大多數來自新鑄造的比特幣。然而，隨著時間的推移，獎勵減少，每個區塊的交易數量增加，挖礦收入中更大比例將來自手續費。逐漸地，挖礦獎勵將由交易手續費主導，這將成為礦工的主要激勵。2140 年之後，每個區塊中的新比特幣數量降至零，挖礦將僅由交易手續費激勵。

在本章中，我們將首先將挖礦作為貨幣供應機制進行檢查，然後查看挖礦最重要的功能：支撐比特幣安全性的去中心化共識機制。

為了理解挖礦和共識，我們將追蹤 Alice 的交易，因為它被 Jing 的挖礦設備接收並添加到區塊中。然後，我們將追蹤該區塊在挖掘、添加到區塊鏈並透過((("挖礦", "操作概述", startref="mining-overview")))緊急共識過程被比特幣網路接受時的情況。

=== 比特幣經濟學和貨幣創造

比特幣((("比特幣", "挖礦", "貨幣創造", id="bitcoin-mining-create")))((("挖礦", "貨幣創造", id="mining-create")))((("貨幣創造", id="currency-create")))((("比特幣", "經濟學", id="bitcoin-economics")))((("比特幣經濟學", id="economics")))在創建每個區塊期間以固定且遞減的速度鑄造。每個區塊，平均每 10 分鐘產生一次，包含全新的比特幣，從無到有創建。每 210,000 個區塊，或大約每四年，貨幣發行率減少 50%。在網路運營的前四年，每個區塊包含 50 個新比特幣。

第一次減半發生在區塊 210,000。本書出版後的下一次預期減半將發生在區塊 840,000，這可能在 2024 年 4 月或 5 月產生。新比特幣的速率在 32 次這些_減半_中呈指數下降，直到區塊 6,720,000（大約在 2137 年開採），屆時它達到最小貨幣單位 1 聰。最後，在大約 2140 年，在 693 萬個區塊之後，將發行近 2,099,999,997,690,000 聰，或近 2100 萬比特幣。此後，區塊將不包含新比特幣，礦工將僅透過交易手續費獲得獎勵。<<bitcoin_money_supply>> 顯示了隨著時間推移，隨著貨幣發行的減少，流通中的比特幣總數。

[[bitcoin_money_supply]]
.基於幾何遞減發行率的比特幣貨幣供應隨時間變化。
image::images/mbc3_1201.png["BitcoinMoneySupply"]

[NOTE]
====
開採的比特幣的最大數量是比特幣可能的挖礦獎勵的_上限_。實際上，礦工可能故意挖掘一個獲得少於全部獎勵的區塊。這樣的區塊已經被挖掘，將來可能會挖掘更多，從而導致貨幣的總發行量降低。
====

在 <<max_money>> 的程式碼中，我們計算將發行的比特幣總量。

[[max_money]]
.用於計算將發行多少比特幣總量的腳本
====
[source, python]
----
include::../code/max_money.py[]
----
====

<<max_money_run>> 顯示了執行此腳本產生的輸出。

[[max_money_run]]
.執行 max_money.py 腳本
====
[source,bash]
----
$ python max_money.py
Total BTC to ever be created: 2099999997690000 Satoshis
----
====

有限且遞減的發行創造了抵抗通貨膨脹的固定貨幣供應。與法定貨幣不同，法定貨幣可以由中央銀行無限量印製，沒有個人或團體有能力膨脹((("比特幣", "挖礦", "貨幣創造", startref="bitcoin-mining-create")))((("挖礦", "貨幣創造", startref="mining-create")))((("貨幣創造", startref="currency-create")))比特幣的供應。

.通貨緊縮貨幣
****
固定且遞減的貨幣發行最((("通貨緊縮", id="deflation")))((("通貨膨脹", id="inflation")))重要和最具爭議的後果是貨幣往往本質上是_通貨緊縮的_。通貨緊縮是由於供需不匹配而推高貨幣價值（和匯率）而導致的價值升值現象。價格通貨緊縮與通貨膨脹相反；這意味著貨幣隨著時間的推移具有更多的購買力。

許多經濟學家認為，通貨緊縮經濟是一場災難，應不惜一切代價避免。這是因為在快速通貨緊縮時期，人們傾向於囤積貨幣而不是花費它，希望價格會下降。這種現象在日本的「失落的十年」中展開，當時需求的完全崩潰將貨幣推入通貨緊縮螺旋。

比特幣專家認為，通貨緊縮本身並不壞。相反地，通貨緊縮與需求崩潰有關，因為這是我們必須研究的通貨緊縮最明顯的例子。在具有無限印製可能性的法定貨幣中，除非需求完全崩潰和不願印製貨幣，否則很難進入通貨緊縮螺旋。比特幣的通貨緊縮不是由需求崩潰引起的，而是由可預測的受限供應引起的。

當然，通貨緊縮的積極方面是它與通貨膨脹相反。通貨膨脹導致貨幣緩慢但不可避免的貶值，導致一種隱藏的稅收形式，懲罰儲蓄者以紓困債務人（包括最大的債務人，政府本身）。政府控制下的貨幣受到容易債務發行的道德風險的影響，這可能在以後透過以儲蓄者為代價的貶值而被抹去。

貨幣的通貨緊縮方面是否是一個問題，當它不是由快速經濟收縮驅動時，或者是一個優勢，因為免受通貨膨脹和貶值的保護超過了((("比特幣", "經濟學", startref="bitcoin-economics")))((("比特幣經濟學", startref="economics")))((("通貨緊縮", startref="deflation")))((("通貨膨脹", startref="inflation")))通貨緊縮的風險，還有待觀察。
****

=== 去中心化共識

在((("挖礦", "去中心化共識", id="mining-consensus")))((("去中心化共識", id="decentral-consensus")))((("緊急共識", id="emergent-consensus")))((("共識", see="去中心化共識")))上一章中，我們查看了區塊鏈，即所有交易的全球列表，比特幣網路中的每個人都接受它作為所有權轉移的權威記錄。

但是，網路中的每個人如何在不必信任任何人的情況下就誰擁有什麼的單一普遍「真相」達成一致？所有傳統支付系統都依賴於信任模型，該模型具有提供清算所服務的中央權威機構，基本上驗證和清算所有交易。比特幣沒有中央權威機構，但不知何故，每個完整節點都有一個可以信任為權威記錄的公共區塊鏈的完整副本。區塊鏈不是由中央權威機構創建的，而是由網路中的每個節點獨立組裝的。不知何故，網路中的每個節點，根據透過不安全網路連接傳輸的資訊採取行動，可以得出相同的結論，並組裝與其他人相同的區塊鏈副本。本章探討了比特幣網路在沒有中央權威的情況下實現全球共識的過程。

中本聰的發明之一是_緊急共識_的去中心化機制。緊急是因為共識不是明確實現的——沒有選舉或固定的共識發生時刻。相反地，共識是數千個獨立節點的異步互動的緊急產物，所有節點都遵循簡單的規則。比特幣的所有屬性，包括貨幣、交易、支付以及不依賴於中央權威或信任的安全模型，都源自這一發明。

比特幣的去中心化共識來自在網路節點上獨立發生的四個過程的相互作用：

- 每個完整節點根據綜合標準列表獨立驗證每筆交易

- 挖礦節點將這些交易獨立聚合到新區塊中，並透過工作量證明演算法展示計算

- 每個節點獨立驗證新區塊並組裝成鏈

- 每個節點獨立選擇透過工作量證明展示最多累積計算的鏈

在接下來的幾節中，我們將檢查這些過程以及它們如何互動以創造網路範圍共識的緊急屬性，該屬性允許任何比特幣節點組裝其自己的權威、可信、公共、全球((("挖礦", "去中心化共識", startref="mining-consensus")))((("去中心化共識", startref="decentral-consensus")))((("緊急共識", startref="emergent-consensus")))區塊鏈副本。

[[tx_verification]]
=== 交易的獨立驗證

在 <<c_transactions>> 中，我們看到((("挖礦", "獨立交易驗證", id="mining-verify")))((("交易", "獨立驗證", id="transaction-verify")))((("獨立交易驗證", id="independent-transaction-verify")))((("驗證", "交易", id="verify-transaction")))((("節點", "交易驗證", id="node-verify")))錢包軟體如何透過收集 UTXO、提供適當的認證資料，然後構建分配給新所有者的新輸出來創建交易。然後，產生的交易被發送到比特幣網路中的鄰近節點，以便它可以在整個比特幣網路上傳播。

然而，在將交易轉發給其鄰居之前，每個接收交易的比特幣節點都將首先驗證交易。這確保只有有效交易在網路上傳播，而無效交易在遇到它們的第一個節點處被丟棄。

每個節點根據一長串標準驗證每筆交易：

- 交易的語法和資料結構必須正確。

- 輸入和輸出列表都不為空。

- 交易權重足夠低，以允許它適合區塊。

- 每個輸出值以及總計必須在允許的值範圍內（零或更多，但不超過 2100 萬比特幣）。

- 鎖定時間等於 +INT_MAX+，或者鎖定時間和序列值根據鎖定時間和 BIP68 規則得到滿足。

- 交易中包含的簽章操作（SIGOPS）數量少於簽章操作限制。

- 被花費的輸出與記憶池中的輸出或主分支中區塊中的未花費輸出匹配。

- 對於每個輸入，如果引用的輸出交易是 coinbase 輸出，則它必須至少有 +COINBASE_MATURITY+（100）個確認。任何絕對或相對鎖定時間也必須得到滿足。節點可以在它們成熟之前一個區塊轉發交易，因為如果包含在下一個區塊中，它們將成熟。

- 如果輸入值的總和小於輸出值的總和，則拒絕。

- 每個輸入的腳本必須針對相應的輸出腳本進行驗證。

請注意，條件會隨時間變化，以添加新功能或解決新類型的拒絕服務攻擊。

透過在接收時獨立驗證每筆交易並在傳播之前，每個節點構建一個有效（但未確認）交易池，稱為((("挖礦", "獨立交易驗證", startref="mining-verify")))((("交易", "獨立驗證", startref="transaction-verify")))((("獨立交易驗證", startref="independent-transaction-verify")))((("驗證", "交易", startref="verify-transaction")))((("節點", "交易驗證", startref="node-verify")))((("記憶池"))_記憶池_或 _mempool_。

=== 挖礦節點

比特幣網路上的一些((("挖礦", "礦工節點，目的", id="mining-nodes-purpose")))((("節點", "礦工節點", "目的", id="nodes-miner-purpose")))節點是稱為_礦工_的專用節點。Jing 是一個比特幣礦工；他透過運行「挖礦設備」來賺取比特幣，這是一個專門設計用於挖掘比特幣的專用計算機硬體系統。Jing 的專用挖礦硬體連接到運行完整節點的伺服器。像其他每個完整節點一樣，Jing 的節點接收並在比特幣網路上傳播未確認的交易。然而，Jing 的節點還將這些交易聚合到新區塊中。

讓我們追蹤在 Alice 從 Bob 購買時創建的區塊（參見 <<spending_bitcoin>>）。為了演示本章中的概念，讓我們假設包含 Alice 交易的區塊是由 Jing 的挖礦系統挖掘的，並追蹤 Alice 的交易成為這個新區塊的一部分。

Jing 的挖礦節點維護區塊鏈的本機副本。到 Alice 購買東西的時候，Jing 的節點已經趕上了具有最多工作量證明的區塊鏈。Jing 的節點正在監聽交易，試圖挖掘新區塊，並且也在監聽其他節點發現的區塊。當 Jing 的節點正在挖礦時，它透過比特幣網路接收新區塊。這個區塊的到達標誌著該區塊的搜尋結束和創建下一個區塊的搜尋開始。

在之前的幾分鐘內，當 Jing 的節點正在尋找前一個區塊的解決方案時，它也在收集交易，為下一個區塊做準備。到現在，它已經在其記憶池中收集了幾千筆交易。在接收到新區塊並驗證它之後，Jing 的節點還將將其與記憶池中的所有交易進行比較，並刪除該區塊中包含的任何交易。記憶池中保留的任何交易都是未確認的，正在等待記錄在新區塊中。

Jing 的節點立即構建一個新的部分區塊，一個下一個區塊的候選。這個區塊被((("候選區塊")))((("區塊", "候選區塊")))稱為_候選區塊_，因為它還不是有效的區塊，因為它不包含有效的工作量證明。只有當礦工根據工作量證明演算法成功找到解決方案時，該區塊才會變得有效。

當 Jing 的節點從記憶池聚合所有交易時，新的候選區塊有幾千筆交易，每筆交易都支付交易手續費，他將嘗試((("挖礦", "礦工節點，目的", startref="mining-nodes-purpose")))((("節點", "礦工節點", "目的", startref="nodes-miner-purpose")))索取。

==== Coinbase 交易

任何((("比特幣", "挖礦", "coinbase 交易", id="bitcoin-mining-coinbase")))((("挖礦", "coinbase 交易", id="mining-coinbase")))((("節點", "礦工節點", "coinbase 交易", id="nodes-miner-coinbase")))((("coinbase 交易", id="coinbase")))((("交易", "coinbase", id="transaction-coinbase")))區塊中的第一筆交易是一筆特殊交易，稱為 _coinbase 交易_。這筆交易由 Jing 的節點構建，並為他的挖礦努力支付他的_獎勵_。

Jing 的節點創建 coinbase 交易作為對他自己錢包的支付。Jing 為挖掘區塊收集的獎勵總額是區塊補貼（2023 年為 6.25 個新比特幣）和區塊中包含的所有交易的交易手續費的總和。

與常規交易不同，coinbase 交易不消耗（花費）UTXO 作為輸入。相反地，它只有一個輸入，稱為 _coinbase 輸入_，它隱式包含區塊獎勵。coinbase 交易必須至少有一個輸出，並且可以有盡可能多的輸出以適合區塊。2023 年，coinbase 交易通常有兩個輸出：其中一個是零值輸出，使用 +OP_RETURN+ 來承諾區塊中所有隔離見證（segwit）交易的所有見證。另一個輸出向礦工支付他們的獎勵。

==== Coinbase 獎勵和手續費

為了構建((("獎勵", id="reward-coinbase")))((("交易手續費", "在 coinbase 交易中", secondary-sortas="coinbase 交易", id="transaction-fee-coinbase"))) coinbase 交易，Jing 的節點首先計算交易手續費的總額：

[latexmath]
++++
\begin{equation}
Total\:Fees = Sum(Inputs) - Sum(Outputs)
\end{equation}
++++


接下來，Jing 的節點計算新區塊的正確獎勵。獎勵是根據區塊高度計算的，從每個區塊 50 比特幣開始，每 210,000 個區塊減半。

可以在 Bitcoin Core 客戶端中的函數 +GetBlockSubsidy+ 中看到計算，如 <<getblocksubsidy_source>> 所示。

[[getblocksubsidy_source]]
.計算區塊獎勵——函數 [.plain]#+GetBlockSubsidy+,# Bitcoin Core 客戶端，[.plain]#main.cpp#
====
[role="c_less_space"]
[source, cpp]
----
CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams)
{
    int halvings = nHeight / consensusParams.nSubsidyHalvingInterval;
    // Force block reward to zero when right shift is undefined.
    if (halvings >= 64)
        return 0;

    CAmount nSubsidy = 50 * COIN;
    // Subsidy is cut in half every 210,000 blocks.
    nSubsidy >>= halvings;
    return nSubsidy;
}
----
====

初始補貼以聰為單位計算，方法是將 50 乘以 +COIN+ 常數（100,000,000 聰）。這將初始獎勵（+nSubsidy+）設定為 50 億聰。

接下來，該函數透過將當前區塊高度除以減半間隔（+SubsidyHalvingInterval+）來計算已發生的 +halvings+ 數量。

接下來，該函數使用二進位右移運算子將獎勵 [.keep-together]#(+nSubsidy+)# 除以二，針對每一輪減半。在區塊 277,316 的情況下，這將對 50 億聰的獎勵進行一次二進位右移（一次減半），結果為 25 億聰，或 25 比特幣。在第 33 次減半之後，補貼將向下捨入為零。使用二進位右移運算子是因為它比多次重複除法更有效。為了避免潛在的錯誤，在 63 次減半之後跳過移位操作，並將補貼設定為 0。

最後，coinbase 獎勵（+nSubsidy+）被添加到交易手續費（+nFees+），並返回總和。

[TIP]
====
如果 Jing 的挖礦節點編寫 coinbase 交易，是什麼阻止 Jing「獎勵」自己 100 或 1,000 比特幣？答案是，膨脹的獎勵將導致區塊被其他所有人視為無效，浪費 Jing 用於 PoW 的電力。只有當區塊被((("獎勵", startref="reward-coinbase")))((("交易手續費", "在 coinbase 交易中", secondary-sortas="coinbase 交易", startref="transaction-fee-coinbase")))所有人接受時，Jing 才能花費獎勵。
====

==== Coinbase 交易的結構

透過這些計算，Jing 的節點然後構建 coinbase 交易來支付他自己的區塊獎勵。

coinbase 交易具有特殊格式。它沒有指定要花費的先前 UTXO 的交易輸入，而是具有「coinbase」輸入。我們在 <<inputs>> 中檢查了交易輸入。讓我們比較常規交易輸入與 coinbase 交易輸入。<<table_8-1>> 顯示了常規交易的結構，而 <<table_8-2>> 顯示了((("輸入", "coinbase 與常規交易"))) coinbase 交易輸入的結構。

++++
<table id="table_8-1">
<caption>「正常」交易輸入的結構</caption>
<thead>
<tr>
<th>大小</th>
<th>欄位</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>32 位元組</p></td>
<td><p>交易雜湊</p></td>
<td><p>指向包含要花費的 UTXO 的交易的指標</p></td>
</tr>
<tr>
<td><p>4 位元組</p></td>
<td><p>輸出索引</p></td>
<td><p>要花費的 UTXO 的索引號，第一個為 0</p></td>
</tr>
<tr>
<td><p>1–9 位元組（compactSize）</p></td>
<td><p>腳本大小</p></td>
<td><p>腳本長度（以位元組為單位），後續</p></td>
</tr>
<tr>
<td><p>可變</p></td>
<td><p>輸入腳本</p></td>
<td><p>滿足 UTXO 輸出腳本條件的腳本</p></td>
</tr>
<tr>
<td><p>4 位元組</p></td>
<td><p>序列號</p></td>
<td><p>用於 BIP68 時間鎖定和交易替換信號的多用途欄位</p></td>
</tr>
</tbody>
</table>
<table id="table_8-2">
<caption>coinbase 交易輸入的結構</caption>
<thead>
<tr>
<th>大小</th>
<th>欄位</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>32 位元組</p></td>
<td><p>交易雜湊</p></td>
<td><p>所有位元都為零：不是交易雜湊引用</p></td>
</tr>
<tr>
<td><p>4 位元組</p></td>
<td><p>輸出索引</p></td>
<td><p>所有位元都為一：0xFFFFFFFF</p></td>
</tr>
<tr>
<td><p>1 位元組</p></td>
<td><p>Coinbase 資料大小</p></td>
<td><p>coinbase 資料的長度，從 2 到 100 位元組</p></td>
</tr>
<tr>
<td><p>可變</p></td>
<td><p>Coinbase 資料</p></td>
<td><p>用於額外 nonce 和挖礦標籤的任意資料；在 v2 區塊中，必須以區塊高度開始</p></td>
</tr>
<tr>
<td><p>4 位元組</p></td>
<td><p>序列號</p></td>
<td><p>設定為 0xFFFFFFFF</p></td>
</tr>
</tbody>
</table>
++++

在 coinbase 交易中，前兩個欄位設定為不代表 UTXO 引用的值。「交易雜湊」的第一個欄位填充了 32 個位元組，全部設定為零，而不是「交易雜湊」。「輸出索引」填充了 4 個位元組，全部設定為 0xFF（255 十進位）。輸入腳本被 coinbase 資料替換，這是礦工使用的資料欄位，我們接下來將看到。

[[duplicate_transactions]]
==== Coinbase 資料

Coinbase ((("coinbase 資料")))交易沒有輸入腳本欄位。相反地，此欄位被 coinbase 資料替換，該資料必須在 2 到 100 位元組之間。除了前幾個位元組外，coinbase 資料的其餘部分可以由礦工以任何方式使用；它是任意資料。

例如，在創世區塊中，中本聰在 coinbase 資料中添加了文字「The Times 03/Jan/2009 Chancellor on brink of second bailout for banks」，將其用作此區塊可能創建的最早日期的證明，並傳達訊息。目前，礦工經常使用 coinbase 資料來包含額外的 nonce 值和識別挖礦池的字串。

[role="less_space pagebreak-before"]
coinbase 的前幾個位元組曾經是任意的，但現在不再如此。根據 BIP34，版本 2 區塊（版本欄位設定為 2 或更高的區塊）必須在 coinbase 欄位的開頭包含區塊高度作為腳本「推送」((("比特幣", "挖礦", "coinbase 交易", startref="bitcoin-mining-coinbase")))((("挖礦", "coinbase 交易", startref="mining-coinbase")))((("節點", "礦工節點", "coinbase 交易", startref="nodes-miner-coinbase")))((("coinbase 交易", startref="coinbase")))((("交易", "coinbase", startref="transaction-coinbase")))操作。

=== 構建區塊標頭

為了構建((("挖礦", "構建區塊標頭", id="mining-blockheader")))((("節點", "礦工節點", "構建區塊標頭", id="nodes-miner-blockheader")))((("區塊標頭", "構建", id="block-header-construct")))區塊標頭，挖礦節點需要填寫六個欄位，如 <<block_header_structure_ch10>> 中所列。

++++
<table id="block_header_structure_ch10">
<caption>區塊標頭的結構</caption>
<thead>
<tr>
<th>大小</th>
<th>欄位</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>4 位元組</p></td>
<td><p>版本</p></td>
<td><p>多用途位欄位</p></td>
</tr>
<tr>
<td><p>32 位元組</p></td>
<td><p>前一個區塊雜湊</p></td>
<td><p>對鏈中前一個（父）區塊的雜湊的引用</p></td>
</tr>
<tr>
<td><p>32 位元組</p></td>
<td><p>默克爾根</p></td>
<td><p>此區塊交易的默克爾樹的根雜湊</p></td>
</tr>
<tr>
<td><p>4 位元組</p></td>
<td><p>時間戳</p></td>
<td><p>此區塊的近似創建時間（從 Unix 紀元開始的秒數）</p></td>
</tr>
<tr>
<td><p>4 位元組</p></td>
<td><p>目標</p></td>
<td><p>此區塊的工作量證明演算法目標</p></td>
</tr>
<tr>
<td><p>4 位元組</p></td>
<td><p>Nonce</p></td>
<td><p>用於工作量證明演算法的計數器</p></td>
</tr>
</tbody>
</table>
++++

版本欄位最初是一個整數欄位，用於比特幣網路的三次升級，這些升級在 BIP 34、66 和 65 中定義。每次版本號都會增加。後來的升級將版本欄位定義為位欄位，稱為 _versionbits_，允許最多 29 個升級同時進行；詳見 <<bip9>>。更晚些時候，礦工開始使用一些 versionbits 作為輔助 nonce 欄位。

[TIP]
====
BIP 34、66 和 65 中定義的協議升級按該順序發生，BIP66（嚴格 DER）發生在 BIP65（+OP_CHECKTIMELOCKVERIFY+）之前，因此比特幣開發人員通常按該順序列出它們，而不是按數字排序。
====

今天，除非正在進行升級共識協議的嘗試，否則 versionbits 欄位沒有意義，在這種情況下，您將需要閱讀其文件以確定它如何使用 versionbits。

接下來，挖礦節點需要添加「前一個區塊雜湊」（也稱為 [.keep-together]#+prevhash+）。#這是從網路接收的前一個區塊的區塊標頭的雜湊，Jing 的節點已接受並選擇它作為其候選區塊的_父區塊_。

[TIP]
====
透過選擇由候選區塊標頭中的前一個區塊雜湊欄位指示的特定_父區塊_，Jing 將他的挖礦算力投入到擴展以該特定區塊結束的鏈。
====

下一步是使用默克爾樹承諾所有交易。每個交易使用其見證交易識別符（_wtxid_）按拓撲順序列出，32 個 0x00 位元組代表第一筆交易（coinbase）的 wtxid。正如我們在 <<merkle_trees>> 中看到的，如果 wtxid 的數量為奇數，則最後一個 wtxid 與自身進行雜湊處理，創建每個包含一筆交易的雜湊的節點。然後將交易雜湊成對組合，創建樹的每一層，直到所有交易被摘要為樹「根」處的一個節點。默克爾樹的根將所有交易摘要為單個 32 位元組值，即_見證根雜湊_。

見證根雜湊被添加到 coinbase 交易的輸出中。如果區塊中沒有交易需要包含見證結構，則可以跳過此步驟。然後，每筆交易（包括 coinbase 交易）使用其交易識別符（txid）列出，並用於構建第二個默克爾樹，其根成為默克爾根，區塊標頭承諾該根。

然後，Jing 的挖礦節點將添加一個 4 位元組的時間戳，編碼為 Unix「紀元」時間戳，該時間戳基於從 1970 年 1 月 1 日午夜 UTC/GMT 經過的秒數。

然後，Jing 的節點填寫 nBits 目標，該目標必須設定為所需 PoW 的緊湊表示，以使其成為有效區塊。目標儲存在區塊中作為「目標位元」度量，這是目標的尾數-指數編碼。編碼具有 1 位元組指數，後跟 3 位元組尾數（係數）。例如，在區塊 277,316 中，目標位元值為 +0x1903a30c+。第一部分 +0x19+ 是十六進位指數，而下一部分 +0x03a30c+ 是係數。目標的概念在 <<target>> 中解釋，「目標位元」表示在 <<target_bits>> 中解釋。

最後一個欄位是 nonce，它被初始化為零。

填寫所有其他欄位後，候選區塊的標頭現在已完成，挖礦過程可以開始。目標現在是找到一個產生小於目標的雜湊的標頭。挖礦節點在找到滿足((("挖礦", "構建區塊標頭", startref="mining-blockheader")))((("節點", "礦工節點", "構建區塊標頭", startref="nodes-miner-blockheader")))((("區塊標頭", "構建", startref="block-header-construct")))要求的版本之前，需要測試數十億或數萬億個標頭的變體。

[role="less_space pagebreak-before"]
=== 挖掘區塊

現在((("候選區塊", "挖礦", id="candidate-mine")))((("區塊", "候選區塊", "挖礦", id="block-candidate-mine")))((("挖礦", "候選區塊", id="mining-candidate")))候選區塊已由 Jing 的節點構建，是時候讓 Jing 的硬體挖礦設備「挖掘」區塊了，以找到工作量證明演算法的解決方案，使區塊有效。在本書中，我們研究了在比特幣系統的各個方面使用的密碼學雜湊函數。雜湊函數 SHA256 是比特幣挖礦過程中使用的函數。

最簡單的說法是，挖礦是重複對候選區塊標頭進行雜湊處理的過程，改變一個參數，直到產生的雜湊與特定目標匹配。雜湊函數的結果無法提前確定，也無法創建將產生特定雜湊值的模式。雜湊函數的這一特徵意味著產生與特定目標匹配的雜湊結果的唯一方法是一次又一次地嘗試，修改輸入，直到所需的雜湊結果偶然出現。

==== 工作量證明演算法

雜湊((("挖礦", "工作量證明演算法", id="mining-proof")))((("雜湊函數", "工作量證明演算法", id="hash-proof")))((("工作量證明演算法", id="proof-mining")))演算法採用任意長度的資料輸入並產生固定長度的確定性結果，稱為_摘要_。摘要是對輸入的數位承諾。對於任何特定輸入，產生的摘要將始終相同，任何實現相同雜湊演算法的人都可以輕鬆計算和驗證。密碼學雜湊演算法的一個關鍵特徵是，找到產生相同摘要的兩個不同輸入在計算上是不可行的（稱為_衝突_）。作為推論，除了嘗試隨機輸入之外，以這樣的方式選擇輸入以產生所需摘要也幾乎是不可能的。

使用((("SHA256 雜湊函數"))) SHA256，無論輸入的大小如何，輸出始終為 256 位元長。例如，我們將計算短語「Hello, World!」的 SHA256 雜湊：

----
$ echo "Hello, world!" | sha256sum
d9014c4624844aa5bac314773d6b689ad467fa4e1d1a50a1b8a99d5a95f72ff5  -
----

這個 256 位元輸出（以十六進位表示）是短語的_雜湊_或_摘要_，取決於短語的每個部分。添加單個字母、標點符號或任何其他字元都將產生不同的雜湊。

在這種情況下使用的變數稱為 _nonce_。nonce 用於改變密碼學函數的輸出，在這種情況下改變對短語的 SHA256 承諾的輸出。

為了從這個演算法中製造挑戰，讓我們設定一個目標：找到一個產生以零開頭的十六進位雜湊的短語。幸運的是，這並不困難，如 <<sha256_example_generator_output2>> 所示。

[[sha256_example_generator_output2]]
.簡單的工作量證明實現
====
----
$ for nonce in $( seq 100 ) ; do echo "Hello, world! $nonce" | sha256sum ; done
3194835d60e85bf7f728f3e3f4e4e1f5c752398cbcc5c45e048e4dbcae6be782  -
bfa474bbe2d9626f578d7d8c3acc1b604ec4a7052b188453565a3c77df41b79e  -
[...]
f75a100821c34c84395403afd1a8135f685ca69ccf4168e61a90e50f47552f61  -
09cb91f8250df04a3db8bd98f47c7cecb712c99835f4123e8ea51460ccbec314  -
----
====

短語「Hello, World! 32」產生以下符合我們標準的雜湊：+09cb91f8250df04a3db8bd98f47c7cecb712c99835f4123e8ea51460ccbec314+。找到它花了 32 次嘗試。就機率而言，如果雜湊函數的輸出均勻分佈，我們預計每 16 個雜湊（十六進位數字 0 到 F 中的十六分之一）就會找到一個以 0 作為十六進位前綴的結果。從數字角度來說，這意味著找到一個小於 +0x1000000000000000000000000000000000000000000000000000000000000000+ 的雜湊值。我們稱此閾值為_目標_，目標是找到數字上小於目標的雜湊。如果我們降低目標，找到小於目標的雜湊的任務變得越來越困難。

++++
<p class="fix_tracking3">
為了給出一個簡單的類比，想像一個遊戲，玩家重複擲一對骰子，試圖擲出小於指定目標的點數。在第一輪中，目標是 12。除非您擲出雙 6，否則您會贏。在下一輪中，目標是 11。玩家必須擲出 10 或更少才能獲勝，這又是一項簡單的任務。假設幾輪後，目標降至 5。現在，超過一半的擲骰子將超過目標，因此無效。目標越低，贏得遊戲所需的擲骰子次數就越多。最終，當目標為 3（可能的最小值）時，每 36 次擲骰子中只有一次，或大約 3%，會產生獲勝結果。
</p>
++++

從知道骰子遊戲目標為 3 的觀察者的角度來看，如果有人成功擲出了獲勝的骰子，可以假設他們平均嘗試了 36 次。換句話說，可以從目標施加的難度估計成功所需的工作量。當演算法基於確定性函數（例如 SHA256）時，輸入本身構成
了產生低於目標的結果所完成的一定_工作量_的_證明_。因此，這就是_工作量證明_。

[TIP]
====
儘管每次嘗試都會產生隨機結果，但任何可能結果的機率都可以提前計算。因此，特定難度的結果構成了特定工作量的證明。
====

在 <<sha256_example_generator_output2>> 中，獲勝的「nonce」是 32，這個結果可以由任何人獨立確認。任何人都可以將數字 32 作為後綴添加到短語「Hello, world!」並計算雜湊值，驗證它小於目標：

----
$ echo "Hello, world! 32" | sha256sum
09cb91f8250df04a3db8bd98f47c7cecb712c99835f4123e8ea51460ccbec314  -
----

++++
<p class="fix_tracking3">
雖然驗證只需要一次雜湊計算，但我們花了 32 次雜湊計算才找到有效的 nonce。如果我們有更低的目標（更高的難度），找到合適的 nonce 將需要更多的雜湊計算，但任何人驗證時仍然只需要一次雜湊計算。通過知道目標，任何人都可以使用統計方法估計難度，從而大致了解找到這樣的 nonce 所需的工作量。
</p>
++++

[TIP]
====
工作量證明必須產生_小於_目標的雜湊值。更高的目標意味著找到低於目標的雜湊值更容易。更低的目標意味著找到低於目標的雜湊值更困難。目標與難度成反比。
====

比特幣的工作量證明與 <<sha256_example_generator_output2>> 中顯示的挑戰非常相似。礦工構建一個填滿交易的候選區塊。接下來，礦工計算此區塊標頭的雜湊值，並查看它是否小於當前_目標_。如果雜湊值不小於目標，礦工將修改 nonce（通常只是將其加 1）然後再試一次。在比特幣網路的當前難度下，礦工必須嘗試大量次數才能找到導致足夠低的區塊標頭雜湊值的 nonce。

[[target_bits]]
==== 目標表示方法

//TODO:use visual representation like I did on bitcoin.org


區塊標頭 ((("mining", "proof-of-work algorithm", startref="mining-proof")))((("hash functions", "proof-of-work algorithm", startref="hash-proof")))((("proof-of-work algorithm", startref="proof-mining")))((("mining", "target representation", id="mining-target")))((("targets", "representation of", id="target-represent")))((("proof-of-work algorithm", "target representation", id="proof-target")))包含一個稱為「目標位元」或簡稱「bits」的符號表示的目標，在區塊 277,316 中，其值為 +0x1903a30c+。這種符號以係數/指數格式表示工作量證明目標，前兩個十六進位數字為指數，接下來的六個十六進位數字為係數。因此，在這個區塊中，指數是 +0x19+，係數是 +0x03a30c+。

從這種表示方法計算難度目標的公式為：

++++
<ul class="simplelist">
  <li>target = coefficient × 2<sup>(8 × (exponent – 3))</sup></li>
</ul>
++++

使用該公式和難度位元值 0x1903a30c，我們得到：

++++
<ul class="simplelist">
  <li>target = 0x03a30c × 2<sup>0x08 × (0x19 – 0x03)</sup></li>
</ul>
++++

即：

++++
<ul class="simplelist">
  <li>22,829,202,948,393,929,850,749,706,076,701,368,331,072,452,018,388,575,715,328</li>
</ul>
++++

或者，以十六進位表示：

++++
<ul class="simplelist">
  <li>0x0000000000000003A30C00000000000000000000000000000000000000000000</li>
</ul>
++++

這意味著區塊高度 277,316 的有效區塊的區塊標頭雜湊值必須小於目標。以二進位表示，該數字必須有超過 60 個前導位元設定為零。在這個難度等級下，單個礦工以每秒 1 兆次雜湊（1 terahash per second 或 1 TH/sec）的速度處理，平均只會每 8,496 個區塊找到一次解決方案，或者說每 59 天一次。((("mining", "target representation", startref="mining-target")))((("targets", "representation of", startref="target-represent")))((("proof-of-work algorithm", "target representation", startref="proof-target")))

[[target]]
==== 重新定目標以調整難度

正如我們所看到的，((("mining", "adjusting difficulty", id="mining-difficulty")))((("targets", "adjusting difficulty", id="target-difficulty")))((("proof-of-work algorithm", "adjusting difficulty", id="proof-difficulty")))((("difficulty", "adjusting", id="difficulty-adjust")))目標決定了難度，因此影響找到工作量證明演算法解決方案所需的時間。這引出了一些顯而易見的問題：為什麼難度是可調整的，誰來調整它，以及如何調整？

比特幣的區塊平均每 10 分鐘產生一次。這是比特幣的心跳，支撐著貨幣發行的頻率和交易結算的速度。它不僅要在短期內保持恆定，還要在數十年的時間內保持恆定。在此期間，預計電腦性能將繼續快速提升。此外，參與挖礦的人數及其使用的電腦也會不斷變化。為了將區塊產生時間保持在 10 分鐘，必須調整挖礦難度以適應這些變化。事實上，工作量證明目標是一個動態參數，定期調整以達到 10 分鐘區塊間隔的目標。簡單來說，目標的設定使得當前的挖礦算力將產生 10 分鐘的區塊間隔。

那麼，在完全去中心化的網路中如何進行這樣的調整呢？重新定目標會在每個節點上自動且獨立地進行。每 2,016 個區塊，所有節點都會重新定目標工作量證明。計算實際時間跨度與期望的每個區塊 10 分鐘時間跨度之間的比率，並對目標進行成比例的調整（向上或向下）。簡單來說：如果網路找到區塊的速度快於每 10 分鐘，難度就會增加（目標降低）。如果發現區塊的速度慢於預期，難度就會降低（目標提高）。

該等式可以總結為：


----
新目標 = 舊目標 * (20,160 分鐘 / 最近 2015 個區塊的實際時間)
----

[NOTE]
====
雖然目標校準每 2,016 個區塊發生一次，但由於原始比特幣軟體中的 off-by-one 錯誤，它是基於前 2,015 個區塊（而不是應該的 2,016 個）的總時間，導致重新定目標偏向於更高的難度約 0.05%。
====

<<retarget_code>> 顯示了 Bitcoin Core 客戶端中使用的程式碼。

[[retarget_code]]
.重新定目標工作量證明：[.plain]#++CalculateNextWorkRequired()++# 在 [.plain]#pow.cpp# 中
====
[source,cpp]
----

   // Limit adjustment step
    int64_t nActualTimespan = pindexLast->GetBlockTime() - nFirstBlockTime;
    LogPrintf("  nActualTimespan = %d  before bounds\n", nActualTimespan);
    if (nActualTimespan < params.nPowTargetTimespan/4)
        nActualTimespan = params.nPowTargetTimespan/4;
    if (nActualTimespan > params.nPowTargetTimespan*4)
        nActualTimespan = params.nPowTargetTimespan*4;

    // Retarget
    const arith_uint256 bnPowLimit = UintToArith256(params.powLimit);
    arith_uint256 bnNew;
    arith_uint256 bnOld;
    bnNew.SetCompact(pindexLast->nBits);
    bnOld = bnNew;
    bnNew *= nActualTimespan;
    bnNew /= params.nPowTargetTimespan;

    if (bnNew > bnPowLimit)
        bnNew = bnPowLimit;

----
====

參數 +Interval+（2,016 個區塊）和 +TargetTimespan+（兩週，即 1,209,600 秒）在 _chainparams.cpp_ 中定義。

為了避免難度的極端波動，重新定目標調整在每個週期內必須小於 4 倍因子。如果所需的目標調整大於 4 倍因子，它將只調整 4 倍，不會更多。任何進一步的調整將在下一個重新定目標期間完成，因為不平衡將在接下來的 2,016 個區塊中持續存在。因此，雜湊算力與難度之間的巨大差異可能需要幾個 2,016 個區塊週期才能平衡。

請注意，目標與交易數量或交易價值無關。這意味著用於保護比特幣的雜湊算力以及因此消耗的電力也完全獨立於交易數量。比特幣可以擴展並保持安全，而無需從今天的水平增加任何雜湊算力。雜湊算力的增加代表了市場力量，因為新礦工進入市場。只要有足夠的雜湊算力在誠實追求獎勵的礦工控制之下，就足以防止「接管」攻擊，因此，就足以保護比特幣。

挖礦的難度與電費成本以及比特幣兌用於支付電費的貨幣的匯率密切相關。高性能挖礦系統在當前這一代矽製程中盡可能高效，以最高速率將電力轉換為雜湊計算。挖礦市場的主要影響因素是以比特幣計價的每千瓦時電費，因為這決定了挖礦的盈利能力，從而決定了進入或退出挖礦 ((("mining", "adjusting difficulty", startref="mining-difficulty")))((("targets", "adjusting difficulty", startref="target-difficulty")))((("proof-of-work algorithm", "adjusting difficulty", startref="proof-difficulty")))((("difficulty", "adjusting", startref="difficulty-adjust")))市場的動機。

[[mtp]]
=== 中位時間過去（MTP）

在比特幣中，((("decentralized consensus", "timestamps and", id="decentral-consensus-timestamp")))((("consensus rules", "timestamps and", id="consensus-timestamp")))((("timestamps", id="timestamp")))((("median time past (MTP)", id="median-time-past")))((("MTP (median time past)", id="mtp-median")))((("mining", "timestamps", id="mining-timestamps")))牆上時鐘時間與共識時間之間存在微妙但非常重要的區別。比特幣是一個去中心化的網路，這意味著每個參與者都有自己的時間視角。網路上的事件不會在所有地方同時發生。必須將網路延遲納入每個節點的視角中。最終，一切都會同步以創建一個共同的區塊鏈。比特幣每 10 分鐘就區塊鏈_過去_的狀態達成共識。

++++
<p class="fix_tracking">
區塊標頭中設定的時間戳記是由礦工設定的。共識規則允許一定程度的緯度，以解釋去中心化節點之間時鐘準確性的差異。然而，這為礦工在區塊中謊報時間創造了一個不幸的動機。例如，如果礦工將時間設定在未來，他們可以降低難度，使他們能夠挖掘更多區塊並領取一些為未來礦工保留的區塊補貼。如果他們可以為某些區塊設定過去的時間，他們可以為其他一些區塊使用當前時間，因此再次使它看起來區塊之間有很長的時間，以便操縱難度。
</p>
++++

為了防止操縱，比特幣有兩個共識規則。第一個是任何節點都不會接受任何時間戳記超過未來兩小時的區塊。第二個是任何節點都不會接受時間戳記小於或等於最近 11 個區塊的中位時間的區塊，稱為_中位時間過去_（MTP）。

作為 BIP68 相對時間鎖啟動的一部分，在交易中計算時間鎖（絕對和相對）的「時間」計算方式也發生了變化。以前，礦工可以在區塊中包含任何時間鎖等於或低於區塊時間的交易。這激勵礦工使用他們認為可能的最晚時間（接近未來兩小時），以便更多交易有資格進入他們的區塊。

為了消除說謊的動機並加強時間鎖的安全性，BIP113 被提出並與相對時間鎖的 BIP 同時啟動。MTP 成為所有時間鎖計算使用的共識時間。通過從大約兩小時前取中點，任何單個區塊時間戳記的影響都會減少。通過合併 11 個區塊，沒有單個礦工可以影響時間戳記以從尚未到期的時間鎖交易中獲得手續費。

MTP 改變了鎖定時間、+CLTV+、序列和 +CSV+ 的時間計算實作。由 MTP 計算的共識時間通常比牆上時鐘時間落後約一小時。如果您創建時間鎖交易，在估計要在鎖定時間、序列、+CLTV+ 和 +CSV+ 中編碼的期望值時，應該考慮到這一點。

=== 成功挖到區塊

++++
<p class="fix_tracking">
如前所述，Jing 的節點已經構建了一個候選區塊並準備好進行挖礦。Jing 有幾台配備特定應用積體電路的硬體挖礦設備，其中成千上萬的積體電路以驚人的速度並行運行比特幣的雙 SHA256 演算法。這些專用機器中的許多通過 USB 或區域網路連接到他的挖礦節點。接下來，在 Jing 桌面上運行的挖礦節點將區塊標頭傳輸到他的挖礦硬體，該硬體開始每秒測試數兆種標頭變體。由於 nonce 只有 32 位元，在耗盡所有 nonce 可能性（約 40 億）之後，挖礦硬體會更改區塊標頭（調整 coinbase 額外 nonce 空間、版本位元或時間戳記）並重置 nonce 計數器，測試新的組合。</p>
++++

開始挖掘某個特定區塊近 11 分鐘後，其中一台硬體挖礦機器找到了解決方案並將其發送回挖礦節點。

立即，Jing 的挖礦節點將該區塊傳輸給所有對等節點。他們接收、驗證，然後傳播新區塊。隨著區塊在網路中傳播，每個節點將其添加到自己的區塊鏈副本中，將其擴展到新的高度。當挖礦節點接收並驗證該區塊時，他們放棄了在相同高度找到區塊的努力，並立即開始計算鏈中的下一個區塊，使用 Jing 的區塊作為「父區塊」。通過在 Jing 新發現的區塊之上構建，其他礦工實質上是使用他們的挖礦算力來背書 Jing 的區塊以及它所擴展的鏈 ((("candidate blocks", "mining", startref="candidate-mine")))((("blocks", "candidate blocks", "mining", startref="block-candidate-mine")))((("mining", "candidate blocks", startref="mining-candidate")))。

在下一節中，我們將查看每個節點用於驗證區塊和選擇最多工作量鏈的過程，這創建了形成去中心化區塊鏈的共識。

=== 驗證新區塊

第三 ((("mining", "validating blocks", id="mining-validate")))((("blocks", "validating", id="block-validate")))((("validating", "blocks", id="validate-block")))((("decentralized consensus", "validating blocks", id="decentral-consensus-validate")))((("nodes", "validating blocks", id="nodes-validate")))步在比特幣的共識機制中是由網路上的每個節點對每個新區塊進行獨立驗證。當新解決的區塊在網路中移動時，每個節點執行一系列測試來驗證它。獨立驗證還確保只有遵循共識規則的區塊才會被併入區塊鏈，從而使礦工獲得獎勵。違反規則的區塊將被拒絕，不僅使其礦工失去獎勵，而且還浪費了尋找工作量證明解決方案所花費的努力，從而使這些礦工承擔創建區塊的所有成本，但沒有給他們任何獎勵。

當節點接收到新區塊時，它將根據一長串必須全部滿足的標準來驗證該區塊；否則，該區塊將被拒絕。這些標準可以在 Bitcoin Core 客戶端的 +CheckBlock+ 和 +CheckBlockHeader+ 函數中看到，包括：

- 區塊資料結構在語法上有效。

- 區塊標頭雜湊值小於目標（強制執行工作量證明）。

- 區塊時間戳記在 MTP 和未來兩小時之間（允許時間誤差）。

- 區塊權重在可接受的限制內。

- 第一筆交易（且僅第一筆）是 coinbase 交易。

- 區塊內的所有交易都使用 <<tx_verification>> 中討論的交易檢查清單有效。

網路上每個節點對每個新區塊的獨立驗證確保了礦工不能作弊。在前面的章節中，我們看到礦工如何編寫一筆交易，獎勵他們在區塊內創建的新比特幣並領取交易手續費。為什麼礦工不給自己寫一筆一千個比特幣的交易，而不是正確的獎勵？因為每個節點都根據相同的規則驗證區塊。無效的 coinbase 交易會使整個區塊無效，這將導致該區塊被拒絕，因此，該交易永遠不會成為區塊鏈的一部分。礦工必須根據所有節點遵循的共享規則構建一個區塊，並使用正確的工作量證明解決方案來挖掘它。為此，他們在挖礦中消耗了大量電力，如果他們作弊，所有的電力和努力都會被浪費。這就是為什麼獨立驗證是 ((("mining", "validating blocks", startref="mining-validate")))((("blocks", "validating", startref="block-validate")))((("validating", "blocks", startref="validate-block")))((("decentralized consensus", "validating blocks", startref="decentral-consensus-validate")))((("nodes", "validating blocks", startref="nodes-validate")))去中心化共識的關鍵組成部分。

//FIXME:normalize terminology between "block-finding race", "mining
//race", and "forks"
[[forks]]
=== 組裝和選擇區塊鏈

最後 ((("mining", "assembling blockchain", id="mining-assemble")))((("blockchain", "assembling", id="blockchain-assemble")))((("decentralized consensus", "assembling blockchain", id="decentral-consensus-assemble")))的部分在比特幣的去中心化共識機制中是將區塊組裝成鏈並選擇具有最多工作量證明的鏈。

_最佳區塊鏈_是與其相關聯的累積工作量證明最多的有效區塊鏈。最佳鏈也可能有與最佳鏈上的區塊成為「兄弟」的區塊分支。這些區塊是有效的，但不是最佳鏈的一部分。它們被保留以供將來參考，以防其中一條次級鏈後來成為主鏈。當出現兄弟區塊時，它們通常是在相同高度幾乎同時挖掘不同區塊的結果。

當接收到新區塊時，節點將嘗試將其添加到現有的區塊鏈中。節點將查看區塊的「前一區塊雜湊值」欄位，這是對區塊父區塊的引用。然後，節點將嘗試在現有區塊鏈中找到該父區塊。大多數時候，父區塊將是最佳鏈的「頂端」，這意味著這個新區塊擴展了最佳鏈。

有時新區塊不會擴展最佳鏈。在這種情況下，節點將把新區塊的標頭附加到次級鏈，然後比較次級鏈與先前最佳鏈的工作量。如果次級鏈現在是最佳鏈，節點將相應地_重組_其對已確認交易和可用 UTXO 的視圖。如果節點是礦工，它現在將構建一個候選區塊來擴展這個新的、更多工作量證明的鏈。

通過選擇最大累積工作量的有效鏈，所有節點
最終達成網路範圍的共識。透過選擇最大累積工作量的有效鏈，鏈之間的暫時差異最終會隨著更多工作的添加而得到解決，擴展其中一條可能的鏈。

[TIP]
====
本節中描述的區塊鏈分叉 ((("blockchain", "forks")))((("forks")))是全球網路傳輸延遲的自然結果。我們稍後還將在本章中討論故意誘發的分叉。
====

分叉幾乎總是在一個區塊內解決。如果兩個區塊幾乎同時被前一個分叉「兩側」的礦工發現，意外分叉可能會延伸到兩個區塊。然而，這種情況發生的機率很低。

比特幣 10 分鐘的區塊間隔是快速確認時間和分叉機率之間的設計妥協。更快的區塊時間會使交易看起來更快清算，但會導致更頻繁的區塊鏈分叉，而更慢的區塊時間會減少分叉數量，但使結算看起來更慢。

[NOTE]
====
哪個更安全：在區塊間平均時間為 10 分鐘的情況下包含在一個區塊中的交易，還是在區塊間平均時間為 1 分鐘的情況下包含在一個區塊上面建立了九個區塊的交易？答案是它們同樣安全。想要雙重花費該交易的惡意礦工需要做等於網路總算力 10 分鐘的工作量才能創建一條具有相同工作量證明的鏈。

區塊之間更短的時間不會導致更早的結算。它唯一的優勢是為願意接受這些保證的人提供較弱的保證。例如，如果您願意接受礦工就最佳區塊鏈達成 3 分鐘的協議作為足夠的安全性，您會更喜歡具有 1 分鐘區塊的系統，在該系統中您可以等待三個區塊，而不是具有 10 分鐘區塊的系統。區塊之間的時間越短，在意外分叉上浪費的礦工工作就越多（除了其他問題），因此許多人更喜歡比特幣的 10 分鐘區塊，而不是更短的區塊 ((("mining", "assembling blockchain", startref="mining-assemble")))((("blockchain", "assembling", startref="blockchain-assemble")))((("decentralized consensus", "assembling blockchain", startref="decentral-consensus-assemble")))間隔。
====



=== 挖礦與算力抽獎

比特幣挖礦 ((("mining", "competitiveness of", id="mining-competitive")))是一個極具競爭性的行業。在比特幣存在的每一年中，算力都呈指數級增長。有些年份的增長反映了技術的完全改變，例如 2010 年和 2011 年，當時許多礦工從使用 CPU 挖礦切換到 GPU 挖礦和現場可編程閘陣列（FPGA）挖礦。2013 年，ASIC 挖礦的引入導致挖礦算力的又一次巨大飛躍，將雙 SHA256 函數直接放在專門用於挖礦目的的矽晶片上。第一批這樣的晶片能夠在單個盒子中提供比 2010 年整個比特幣網路更多的挖礦算力。

在撰寫本文時，據信比特幣挖礦設備不再有更大的飛躍，因為該行業已經達到了 ((("Moore&#x27;s Law")))摩爾定律的前沿，該定律規定計算密度將大約每 18 個月翻一番。儘管如此，網路的挖礦算力仍在快速增長。

[[extra_nonce]]
==== 額外 Nonce 解決方案

自 2012 年以來，挖礦 ((("mining", "extra nonce solution", id="mining-nonce")))((("extra nonce solution", id="extra-nonce")))已演變為解決區塊標頭結構中的一個基本限制。在比特幣的早期，礦工可以透過迭代 nonce 直到產生的雜湊值低於目標來找到區塊。隨著難度增加，礦工經常循環遍歷 nonce 的所有 40 億個值而沒有找到區塊。然而，這很容易透過更新區塊時間戳記以計算經過的時間來解決。因為時間戳記是標頭的一部分，更改將允許礦工再次迭代 nonce 的值，並獲得不同的結果。然而，一旦挖礦硬體超過 4 GH/sec，這種方法變得越來越困難，因為 nonce 值在不到一秒的時間內就耗盡了。隨著 ASIC 挖礦設備開始超過 TH/sec 的雜湊率，挖礦軟體需要更多的 nonce 值空間才能找到有效的區塊。時間戳記可以稍微拉伸，但將其移得太遠到未來會導致區塊無效。區塊標頭中需要一個新的變化來源。

廣泛實施的一個解決方案是使用 coinbase 交易作為額外 nonce 值的來源。因為 coinbase 腳本可以儲存 2 到 100 位元組的資料，礦工開始使用該空間作為額外的 nonce 空間，允許他們探索更大範圍的區塊標頭值以找到有效的區塊。coinbase 交易包含在默克爾樹中，這意味著 coinbase 腳本中的任何更改都會導致默克爾根更改。8 位元組的額外 nonce 加上 4 位元組的「標準」nonce，允許礦工_每秒_探索總共 2^96^（8 後跟 28 個零）種可能性，而無需修改時間戳記。

今天廣泛使用的另一個解決方案是將區塊標頭 versionbits 欄位的最多 16 位元用於挖礦，如 BIP320 中所述。如果每個挖礦設備都有自己的 coinbase 交易，這允許單個挖礦設備僅透過對區塊標頭進行更改就可以執行高達 281 TH/s。這使挖礦設備和協議比每 40 億個雜湊就在 coinbase 交易中遞增額外 nonce 更簡單，後者需要重新計算默克爾樹的整個左側直到 ((("mining", "extra nonce solution", startref="mining-nonce")))((("extra nonce solution", startref="extra-nonce")))根。

[[mining_pools]]
==== 挖礦池

在這個 ((("mining", "mining pools", id="mining-mining-pools")))((("mining pools", id="mining-pools")))高度競爭的環境中，單獨工作的個體礦工（也稱為單人礦工）沒有機會。他們找到區塊以抵消電費和硬體成本的可能性非常低，這代表著一種賭博，就像玩彩票一樣。即使是最快的消費級 ASIC 挖礦系統也無法跟上在發電站附近的巨型倉庫中堆疊數萬個這樣的系統的商業運營。現在許多礦工合作組成挖礦池，匯集他們的算力並在數千名參與者之間分享獎勵。透過參與礦池，礦工獲得較小份額的總體獎勵，但通常每天都會獲得獎勵，從而減少不確定性。

讓我們看一個具體的例子。假設一位礦工購買了算力總和為當前網路總算力 0.0001% 的挖礦硬體。如果協議難度從未改變，該礦工大約每 20 年會找到一個新區塊。這可能是一個漫長的等待時間才能獲得報酬。然而，如果該礦工與其他礦工一起在挖礦池中工作，其總算力為網路總算力的 1%，他們平均每天會挖到一個以上的區塊。該礦工只會獲得其應得的獎勵份額（減去礦池收取的任何費用），因此他們每天只會獲得少量收入。如果他們挖礦 20 年，他們會賺到與自己找到平均一個區塊相同的金額（不計礦池費用）。唯一的根本區別是他們收到付款的頻率。

挖礦池透過專門的礦池挖礦協議協調數百或數千名礦工。個體礦工在使用礦池創建帳戶後，配置他們的挖礦設備連接到礦池伺服器。他們的挖礦硬體在挖礦時保持連接到礦池伺服器，與其他礦工同步他們的努力。因此，礦池礦工分享挖掘區塊的努力，然後分享獎勵。

成功的區塊將獎勵支付給礦池比特幣地址，而不是個體礦工。礦池伺服器將定期向礦工的比特幣地址付款，一旦他們的獎勵份額達到一定的閾值。通常，礦池伺服器會收取獎勵的百分比費用，用於提供礦池挖礦服務。

參與礦池的礦工分擔尋找候選區塊解決方案的工作，為其挖礦貢獻賺取「份額」。挖礦池設定了一個更高的目標（較低的難度）來賺取份額，通常比比特幣網路的目標容易 1,000 倍以上。當礦池中的某人成功挖掘出一個區塊時，獎勵由礦池賺取，然後根據他們為努力貢獻的份額數量與所有礦工分享。

許多礦池對任何礦工開放，無論大小、專業或業餘。因此，礦池將有一些參與者只有一台小型挖礦機器，而其他人則有一個車庫充滿高端挖礦硬體。有些人將以數十千瓦的電力進行挖礦，其他人將運行消耗兆瓦電力的資料中心。挖礦池如何衡量個人貢獻，以便在沒有作弊可能性的情況下公平分配獎勵？答案是使用比特幣的工作量證明演算法來衡量每個礦池礦工的貢獻，但設定較低的難度，以便即使是最小的礦池礦工也能經常贏得份額，使他們值得為礦池做出貢獻。透過設定較低的難度來賺取份額，礦池衡量每個礦工完成的工作量。每次礦池礦工找到小於礦池目標的區塊標頭雜湊值時，他們證明他們已經完成了尋找該結果的雜湊工作。該標頭最終承諾 coinbase 交易，並可用於證明礦工使用了會將區塊獎勵支付給礦池的 coinbase 交易。每個礦池礦工都被給予稍微不同的 coinbase 交易模板，因此他們每個人都雜湊不同的候選區塊標頭，防止重複工作。

尋找份額的工作以統計可衡量的方式貢獻了尋找低於比特幣網路目標的雜湊值的總體努力。數千名礦工試圖尋找低值雜湊值最終會找到一個足夠低以滿足比特幣網路目標的雜湊值。

讓我們回到骰子遊戲的類比。如果骰子玩家擲骰子的目標是擲出小於 4（整體網路難度），礦池會設定一個更容易的目標，計算礦池玩家成功擲出小於 8 的次數。當礦池玩家擲出小於 8（礦池份額目標）時，他們賺取份額，但他們沒有贏得遊戲，因為他們沒有達到遊戲目標（小於 4）。礦池玩家將更經常地達到更容易的礦池目標，使他們非常有規律地賺取份額，即使他們沒有達到贏得遊戲的更難目標。偶爾，礦池玩家中的一位會擲出小於 4 的組合擲骰，礦池就會獲勝。然後，收益可以根據他們賺取的份額分配給礦池玩家。儘管 8 或更少的目標沒有獲勝，但這是衡量玩家擲骰子的公平方式，並且它偶爾會產生小於 4 的擲出。

同樣，挖礦池將設定一個（更高和更容易的）礦池目標，這將確保個體礦池礦工透過找到小於礦池目標的區塊標頭雜湊值而頻繁賺取份額。偶爾，其中一次嘗試將產生小於比特幣網路目標的區塊標頭雜湊值，使其成為有效區塊，整個礦池獲勝。

===== 託管礦池

大多數 ((("managed pools", id="manage-pool")))挖礦池都是「託管的」，這意味著有一家公司或個人運行礦池伺服器。礦池伺服器的所有者稱為_礦池運營商_，他們向礦池礦工收取收益的百分比費用。

礦池伺服器運行專門的軟體和礦池挖礦協議，協調礦池礦工的活動。礦池伺服器還連接到一個或多個完整的比特幣節點。這允許礦池伺服器代表礦池礦工驗證區塊和交易，使他們免於運行完整節點的負擔。對於一些礦工來說，能夠在不運行完整節點的情況下進行挖礦是加入託管礦池的另一個好處。

礦池礦工使用挖礦協議 ((("Stratum")))（例如 Stratum（版本 1 或版本 2））連接到礦池伺服器。Stratum v1 創建包含候選區塊標頭模板的區塊_模板_。礦池伺服器透過聚合交易、添加 coinbase 交易（帶有額外的 nonce 空間）、計算默克爾根以及連結到前一個區塊雜湊值來構建候選區塊。然後將候選區塊的標頭作為模板發送給每個礦池礦工。然後，每個礦池礦工使用區塊模板進行挖礦，目標高於（更容易）比特幣網路目標，並將任何成功的結果發送回礦池伺服器以賺取份額。

Stratum v2 可選擇性地允許礦池中的個體礦工選擇在他們自己的區塊中出現的交易，他們可以使用自己的完整節點進行選擇。

===== 點對點挖礦池（P2Pool）

使用 Stratum v1 的託管礦池 ((("P2Pool (peer-to-peer mining pool)", id="p2pool")))創造了礦池運營商作弊的可能性，他可能會指示礦池努力進行雙重花費交易或使區塊無效（參見 <<consensus_attacks>>）。此外，中心化的礦池伺服器代表單點故障。如果礦池伺服器當機或被拒絕服務攻擊減慢，礦池礦工就無法挖礦。2011 年，為了解決這些中心化問題，提出並實施了一種新的礦池挖礦方法：P2Pool，一個沒有中央運營商的點對點挖礦池。

P2Pool 透過去中心化礦池伺服器的功能來工作，實現了一個稱為 ((("share chains")))_份額鏈_的類似區塊鏈的平行系統。份額鏈是一個以比比特幣區塊鏈更低難度運行的區塊鏈。份額鏈允許礦池礦工透過以每 30 秒一個份額區塊的速率在份額鏈上挖掘份額來進行去中心化礦池的協作。份額鏈上的每個區塊都記錄貢獻工作的礦池礦工的比例份額獎勵，從前一個份額區塊向前攜帶份額。當其中一個份額區塊也達到比特幣網路目標時，它會被傳播並包含在比特幣區塊鏈中，獎勵所有為獲勝份額區塊之前的所有份額做出貢獻的礦池礦工。本質上，不是由礦池伺服器追蹤礦池礦工的份額和獎勵，份額鏈允許所有礦池礦工使用類似於比特幣區塊鏈共識機制的去中心化共識機制追蹤所有份額。

P2Pool 挖礦比礦池挖礦更複雜，因為它要求礦池礦工運行一台具有足夠磁碟空間、記憶體和網際網路頻寬的專用電腦來支援比特幣完整節點和 P2Pool 節點軟體。P2Pool 礦工將他們的挖礦硬體連接到他們的本地 P2Pool 節點，該節點透過向挖礦硬體發送區塊模板來模擬礦池伺服器的功能。在 P2Pool 上，個體礦池礦工構建自己的候選區塊，像單人礦工一樣聚合交易，但隨後在份額鏈上協作挖礦。P2Pool 是一種混合方法，其優勢是比單人挖礦具有更細粒度的支出，但不會像託管礦池那樣給礦池運營商太多控制權。

儘管 P2Pool 減少了礦池運營商的權力集中，但它可以想像地容易受到對份額鏈本身的 51% 攻擊。更廣泛地採用 P2Pool 並不能解決比特幣本身的 51% 攻擊問題。相反，P2Pool 使比特幣整體更加穩健，作為多元化挖礦生態系統的一部分。在撰寫本文時，P2Pool 已經停用，但 Stratum v2 等新協議可以允許個體礦工選擇他們在自己的 ((("mining", "competitiveness of", startref="mining-competitive")))((("mining", "mining pools", startref="mining-mining-pools")))((("mining pools", startref="mining-pools")))((("P2Pool (peer-to-peer mining pool)", startref="p2pool")))區塊中包含的交易。

[[consensus_attacks]]
=== 算力攻擊

比特幣的 ((("decentralized consensus", "hashrate attacks", id="decentral-consensus-hashrate")))((("mining", "hashrate attacks", id="mining-hashrate")))((("hashrate attacks", id="hashrate")))((("forks", "hashrate attacks", id="fork-hashrate")))共識機制至少在理論上容易受到試圖使用其算力進行不誠實或破壞性目的的礦工（或礦池）的攻擊。正如我們所看到的，共識機制取決於大多數礦工出於自身利益誠實行事。然而，如果一個礦工或一組礦工能夠獲得挖礦算力的顯著份額，他們可以攻擊共識機制，從而破壞比特幣網路的安全性和可用性。

重要的是要注意，算力攻擊對未來共識的影響最大。最佳區塊鏈上已確認的交易隨著時間的推移變得越來越不可變。雖然理論上可以在任何深度實現分叉，但實際上，強制進行非常深的分叉所需的計算能力是巨大的，使得舊區塊非常難以更改。算力攻擊也不會影響私鑰和簽章演算法的安全性。

針對共識機制的一種攻擊場景稱為 ((("majority attacks", id="majority-attack")))((("51% attacks", id="attack-51")))((("double-spend attacks", id="double-spend")))_多數攻擊_或 _51% 攻擊_。在這種情況下，一組礦工控制著網路總算力的大多數（例如 51%），串通攻擊比特幣。憑藉挖掘大多數區塊的能力，攻擊礦工可以在區塊鏈中造成故意的「分叉」並雙重花費交易或對特定交易或地址執行拒絕服務攻擊。分叉/雙重花費攻擊是指攻擊者透過在它們下面分叉並重新收斂到備用鏈上，使先前確認的區塊無效。憑藉足夠的算力，攻擊者可以連續使六個或更多區塊無效，導致被認為是不可變的（六次確認）交易被無效化。請注意,雙重花費只能在攻擊者自己的交易上完成，攻擊者可以為這些交易產生有效的簽章。雙重花費自己的交易可能是有利可圖的，如果使交易無效允許攻擊者在不付款的情況下獲得不可逆轉的交換付款或產品。

讓我們檢查一個 51% 攻擊的實際例子。在第一章中，我們看了 Alice 和 Bob 之間的交易。Bob，賣家，願意在不等待確認（在區塊中挖掘）的情況下接受付款，因為與快速客戶服務的便利性相比，小物品雙重花費的風險較低。這類似於咖啡店的做法，對於低於 25 美元的金額，他們接受信用卡付款而不需要簽名，因為信用卡退款的風險較低，而延遲交易以獲得簽名的成本相對較大。相反，出售更昂貴的物品以換取比特幣會面臨雙重花費攻擊的風險，買家在其中廣播一個競爭交易，花費相同的輸入（UTXO）之一並取消對商家的付款。51% 攻擊允許攻擊者在新鏈中雙重花費他們自己的交易，從而撤銷舊鏈中的相應交易。

//TODO:distinguish between majority attack and sub-majority "reorg"
//attack.

在我們的示例中，惡意攻擊者 Mallory 前往 Carol 的畫廊並購買了一套描繪中本聰為普羅米修斯的美麗畫作。Carol 以 250,000 美元的比特幣價格將畫作賣給 Mallory。Carol 沒有等待六次或更多確認，而是在只有一次確認後就包裝並將畫作交給 Mallory。Mallory 與一位同謀 Paul 合作，Paul 運營著一個大型礦池，一旦 Mallory 的交易被包含在區塊中，同謀就會發起攻擊。Paul 指示礦池重新挖掘與包含 Mallory 交易的區塊相同的區塊高度，用雙重花費與 Mallory 付款相同輸入的交易替換 Mallory 對 Carol 的付款。雙重花費交易消耗相同的 UTXO 並將其支付回 Mallory 的錢包，而不是支付給 Carol，本質上允許 Mallory 保留比特幣。然後，Paul 指示礦池挖掘一個額外的區塊，以使包含雙重花費交易的鏈比原始鏈更長（導致在包含 Mallory 交易的區塊下面分叉）。當區塊鏈分叉有利於新（更長）鏈解決時，雙重花費交易取代了對 Carol 的原始付款。Carol 現在失去了三幅畫，也沒有付款。在所有這些活動中，Paul 的礦池參與者可能仍然幸福地不知道雙重花費嘗試，因為他們使用自動礦工進行挖礦，無法監控每筆交易或區塊。

為了防止這種攻擊，出售大價值物品的商家必須在將產品交給買家之前至少等待六次確認。有時等待六次以上的確認可能是有保證的。或者，商家應該使用託管多重簽章帳戶，在託管帳戶被資助後再次等待幾次確認。經過的確認越多，透過重組區塊鏈使交易無效就越困難。對於高價值物品，即使買家必須等待 24 小時才能交付（這將對應大約 144 次確認），透過比特幣付款仍然會很方便和高效。

除了雙重花費攻擊之外，共識攻擊的另一種情況是拒絕向特定參與者（特定比特幣地址）提供服務。擁有大多數挖礦算力的攻擊者可以審查交易。如果它們被包含在另一個礦工挖掘的區塊中，攻擊者可以故意分叉並重新挖掘該區塊，再次排除特定交易。這種類型的攻擊可能會導致對特定地址或一組地址的持續拒絕服務，只要攻擊者控制大多數挖礦算力。

//TODO: update to not use 51% attack name (see other TODO in this
//chapter)

儘管它的 ((("majority attacks", startref="majority-attack")))((("51% attacks", startref="attack-51")))((("double-spend attacks", startref="double-spend")))名稱，51% 攻擊場景實際上並不需要 51% 的算力。事實上，這種攻擊可以用較小百分比的算力來嘗試。51% 的閾值只是這種攻擊幾乎肯定成功的水平。算力攻擊本質上是對下一個區塊的拔河，「更強」的群體更有可能獲勝。憑藉較少的算力，成功的機率會降低，因為其他礦工控制
了區塊的產生。以另一種方式來看，攻擊者擁有的算力越多，他可以故意創建的分叉就越長，他可以使最近過去的區塊無效，或者他可以控制未來的區塊就越多。安全研究組織使用統計建模聲稱，只需 30% 的算力就可以進行各種類型的算力攻擊。

由挖礦池 ((("mining pools")))引起的控制中心化引入了礦池運營商進行營利性攻擊的風險。託管礦池中的礦池運營商控制候選區塊的構建，並控制包含哪些交易。這賦予礦池運營商排除交易或引入雙重花費交易的權力。如果以有限和微妙的方式濫用權力，礦池運營商可以想像從算力攻擊中獲利而不被注意到。

然而，並非所有攻擊者都會受到利潤的驅使。一種潛在的攻擊場景是攻擊者打算破壞比特幣網路，而沒有從這種破壞中獲利的可能性。旨在癱瘓比特幣的惡意攻擊將需要大量投資和秘密計劃，但可以想像由資金充足的、很可能是國家資助的攻擊者發起。或者，資金充足的攻擊者可以透過同時積累挖礦硬體、破壞礦池運營商以及用拒絕服務攻擊其他礦池來攻擊比特幣。所有這些場景在理論上都是可能的。

毫無疑問，嚴重的算力攻擊會在短期內侵蝕對比特幣的信心，可能導致價格大幅下跌。然而，比特幣網路和軟體正在不斷發展，因此攻擊將得到比特幣 ((("decentralized consensus", "hashrate attacks", startref="decentral-consensus-hashrate")))((("mining", "hashrate attacks", startref="mining-hashrate")))((("hashrate attacks", startref="hashrate")))((("forks", "hashrate attacks", startref="fork-hashrate")))社群的對策。

[[consensus_changes]]
=== 改變共識規則

共識的 ((("consensus rules")))規則決定了交易和區塊的有效性。這些規則是所有比特幣節點之間協作的基礎，並負責將所有本地視角收斂到整個網路上的單一一致的區塊鏈。

雖然共識規則在短期內是不變的，並且必須在所有節點之間保持一致，但它們在長期內並非不變。為了發展比特幣系統，規則可以不時更改以容納新功能、改進或錯誤修復。然而，與傳統軟體開發不同，共識系統的升級要困難得多，需要所有參與者之間的協調。

[[hard_forks]]
==== 硬分叉

在 <<forks>> 中，我們看到 ((("consensus rules", "hard forks", "explained", id="consensus-hard-fork")))((("forks", "hard forks", "explained", id="forks-hard")))((("hard forks", "explained", id="hard-forks-ch12")))比特幣網路如何可能暫時分歧，網路的兩個部分在短時間內遵循區塊鏈的兩個不同分支。我們看到這個過程如何自然發生，作為網路正常運作的一部分，以及在挖掘一個或多個區塊後網路如何收斂到一個共同的區塊鏈。

網路可能分歧成遵循兩條鏈的另一種情況是：共識規則的更改。這種類型的分叉被稱為_硬分叉_，因為在分叉之後，網路可能無法收斂到單一鏈。相反，兩條鏈可以獨立發展。硬分叉發生在網路的一部分在與網路其餘部分不同的共識規則集下運作時。這可能由於錯誤或共識規則實作的故意更改而發生。

硬分叉可用於更改共識規則，但它們需要系統中所有參與者之間的協調。任何未升級到新共識規則的節點都無法參與共識機制，並在硬分叉時刻被迫進入單獨的鏈。因此，硬分叉引入的更改可以被認為不是「向前相容」的，因為未升級的系統由於新的共識規則而無法再處理區塊。

讓我們透過一個具體的例子檢查硬分叉的機制。

<<blockchainwithforks>> 顯示了一個有兩個分叉的區塊鏈。在區塊高度 4，發生了一個單區塊分叉。這是我們在 <<forks>> 中看到的自發分叉類型。隨著區塊 5 的挖掘，網路收斂到一條鏈，分叉得到解決。

[[blockchainwithforks]]
.帶有分叉的區塊鏈。
image::images/mbc3_1202.png[A blockchain with forks]

然而，稍後在區塊高度 6，發布了客戶端的新實作，共識規則發生了更改。從區塊高度 7 開始，運行此新實作的礦工將接受一種新型的比特幣；讓我們稱之為「foocoin」。緊接著，運行新實作的節點創建了一筆包含 foocoin 的交易，帶有更新軟體的礦工挖掘包含此交易的區塊 7b。

任何未升級軟體以驗證 foocoin 的節點或礦工現在都無法處理區塊 7b。從他們的角度來看，包含 foocoin 的交易和包含該交易的區塊 7b 都是無效的，因為他們根據舊的共識規則評估它們。這些節點將拒絕該交易和該區塊，並且不會傳播它們。使用舊規則的任何礦工都不會接受區塊 7b，並將繼續挖掘其父區塊為區塊 6 的候選區塊。事實上，使用舊規則的礦工可能甚至不會收到區塊 7b，如果他們連接的所有節點也都遵守舊規則，因此不傳播該區塊。最終，他們將能夠挖掘區塊 7a，這在舊規則下是有效的，並且不包含任何帶有 foocoin 的交易。

兩條鏈從這一點繼續分歧。「b」鏈上的礦工將繼續接受並挖掘包含 foocoin 的交易，而「a」鏈上的礦工將繼續忽略這些交易。即使區塊 8b 不包含任何 foocoin 交易，「a」鏈上的礦工也無法處理它。對他們來說，它似乎是一個無效的區塊，因為其父區塊「7b」未被識別為有效 ((("consensus rules", "hard forks", "explained", startref="consensus-hard-fork")))((("forks", "hard forks", "explained", startref="forks-hard")))((("hard forks", "explained", startref="hard-forks-ch12")))區塊。

===== 硬分叉：軟體、網路、挖礦和鏈

對於 ((("software forks", id="software-fork")))((("network forks", id="network-fork")))((("mining forks", id="mining-fork")))((("chain forks", id="chain-fork")))((("consensus rules", "hard forks", "types of", id="consensus-hard-fork-type")))((("forks", "hard forks", "types of", id="forks-hard-type")))((("hard forks", "types of", id="hard-forks-type")))軟體開發人員來說，「分叉」一詞有另一個含義，為「硬分叉」一詞增添了混淆。在開源軟體中，當一組開發人員選擇遵循不同的軟體路線圖並開始開源專案的競爭實作時，就會發生分叉。我們已經討論了將導致硬分叉的兩種情況：共識規則中的錯誤和共識規則的故意修改。在故意更改共識規則的情況下，軟體分叉先於硬分叉。然而，要發生這種類型的硬分叉，必須開發、採用和啟動共識規則的新軟體實作。

嘗試更改共識規則的軟體分叉示例包括 Bitcoin XT 和 Bitcoin Classic。然而，這些程式都沒有導致硬分叉。雖然軟體分叉是必要的先決條件，但它本身不足以發生硬分叉。要發生硬分叉，競爭實作必須被礦工、錢包和中介節點採用並啟動新規則。相反，有許多 Bitcoin Core 的替代實作，甚至軟體分叉，它們不會更改共識規則，除非有錯誤，否則可以在網路上共存並互操作，而不會導致硬分叉。

共識規則可能在交易或區塊的驗證中以明顯和明確的方式不同。規則也可能在共識規則的實作中以更微妙的方式不同，因為它們適用於比特幣腳本或數位簽章等密碼學原語。最後，共識規則可能以意外的方式不同，因為系統限制或實作細節強加的隱式共識約束。後者的一個例子是在 Bitcoin Core 0.7 升級到 0.8 期間看到的意外硬分叉，這是由用於儲存區塊的 Berkeley DB 實作的限制引起的。

從概念上講，我們可以認為硬分叉分為四個階段：軟體分叉、網路分叉、挖礦分叉和鏈分叉。該過程從開發人員創建具有修改共識規則的客戶端的替代實作開始。

當這個分叉實作部署在網路中時，一定百分比的礦工、錢包用戶和中介節點可能會採用並運行此實作。首先，網路將分叉。基於共識規則原始實作的節點將拒絕根據新規則創建的任何交易和區塊。此外，遵循原始共識規則的節點可能會與向它們發送這些無效交易和區塊的任何節點斷開連接。結果，網路可能會分區為兩個：舊節點將僅保持與舊節點的連接，新節點將僅連接到新節點。基於新規則的單個區塊將在網路中傳播，並導致分區為兩個網路。

新礦工可能會在新區塊之上挖礦，而舊礦工將基於舊規則挖掘單獨的鏈。分區網路將使在單獨共識規則下運作的礦工不太可能收到彼此的區塊，因為他們連接到兩個單獨的 ((("software forks", startref="software-fork")))((("network forks", startref="network-fork")))((("mining forks", startref="mining-fork")))((("chain forks", startref="chain-fork")))((("consensus rules", "hard forks", "types of", startref="consensus-hard-fork-type")))((("forks", "hard forks", "types of", startref="forks-hard-type")))((("hard forks", "types of", startref="hard-forks-type")))網路。

===== 分歧的礦工和難度

當礦工 ((("consensus rules", "hard forks", "difficulty and", id="consensus-hard-fork-difficult")))((("forks", "hard forks", "difficulty and", id="forks-hard-difficult")))((("hard forks", "difficulty and", id="hard-forks-difficult")))((("difficulty", "hard forks and", id="difficulty-hardfork")))分歧挖掘兩條不同的鏈時，算力在鏈之間分配。挖礦算力可以在兩條鏈之間以任何比例分配。新規則可能只被少數人遵循，或者被絕大多數挖礦算力遵循。

例如，假設 80%-20% 的分配，大多數挖礦算力使用新的共識規則。我們還假設分叉在重新定目標期間之後立即發生。

兩條鏈將各自繼承重新定目標期間的難度。新的共識規則將有 80% 的先前可用挖礦算力承諾給它們。從這條鏈的角度來看，挖礦算力相對於前一個時期突然下降了 20%。區塊將平均每 12.5 分鐘找到一次，代表可用於擴展此鏈的挖礦算力下降了 20%。這個區塊發行率將繼續（除非算力有任何變化），直到挖掘 2,016 個區塊，這將需要大約 25,200 分鐘（每個區塊 12.5 分鐘），或 17.5 天。17.5 天後，將發生重新定目標，難度將調整（降低 20%）以再次產生 10 分鐘的區塊，基於此鏈中減少的算力。

少數鏈，根據舊規則以僅 20% 的算力挖礦，將面臨更困難的任務。在這條鏈上，區塊現在將平均每 50 分鐘挖掘一次。難度不會調整 2,016 個區塊，這將需要 100,800 分鐘，或大約 10 週才能挖掘。假設每個區塊的固定容量，這也將導致交易容量減少 5 倍，因為每小時可用於記錄交易的區塊較少。

===== 有爭議的硬分叉

這是 ((("consensus rules", "hard forks", "contentious forks")))((("forks", "hard forks", "contentious forks")))((("hard forks", "contentious forks")))((("contentious hard forks")))去中心化共識軟體開發的黎明。正如開發中的其他創新改變了軟體的方法和產品，並在其後創建了新的方法論、新工具和新社群一樣，共識軟體開發也代表了電腦科學的新前沿。從比特幣開發的辯論、實驗和磨難中，我們將看到新的開發工具、實踐、方法論和社群出現。

硬分叉被視為有風險，因為它們迫使少數人要麼升級，要麼留在少數鏈上。將整個系統分割成兩個競爭系統的風險被許多人視為不可接受的風險。因此，許多開發人員不願使用硬分叉機制來實施共識規則的升級，除非整個網路幾乎一致支援。任何沒有幾乎一致支援的硬分叉提案都被認為太有爭議，無法在不冒系統分區風險的情況下嘗試。

我們已經看到了解決硬分叉風險的新方法論的出現。在下一節中，我們將看看軟分叉以及信號和啟動共識修改的方法。

==== 軟分叉

並非所有 ((("consensus rules", "soft forks", "explained", id="consensus-soft-explain")))((("forks", "soft forks", "explained", id="fork-soft-explain")))((("soft forks", "explained", id="soft-fork-explain")))共識規則更改都會導致硬分叉。只有向前不相容的共識更改才會導致分叉。如果以這樣一種方式實現更改，即未修改的客戶端仍然將交易或區塊視為在先前規則下有效，則更改可以在沒有分叉的情況下發生。

引入術語_軟分叉_是為了將這種升級方法與「硬分叉」區分開來。實際上，軟分叉根本不是分叉。軟分叉是共識規則的向前相容更改，允許未升級的客戶端繼續在新規則下運作於共識中。

軟分叉的一個不太明顯的方面是，軟分叉升級只能用於約束共識規則，而不能擴展它們。為了向前相容，根據新規則創建的交易和區塊在舊規則下也必須是有效的，但反之則不然。新規則只能限制有效的內容；否則，當根據舊規則被拒絕時，它們將觸發硬分叉。

軟分叉可以用多種方式實現——該術語不指定特定的方法，而是指定所有具有一個共同點的一組方法：它們不需要所有節點升級或強制未升級的節點退出共識。

兩個軟分叉已在比特幣中實作，基於對 ((("NOP opcodes")))((("OP_NOP opcodes")))NOP 操作碼的重新解釋。比特幣腳本有 10 個保留供將來使用的操作碼，NOP1 到 NOP10。根據共識規則，這些操作碼在腳本中的存在被解釋為無效運算子，這意味著它們沒有效果。執行在 NOP 操作碼之後繼續，就好像它不在那裡一樣。

因此，軟分叉可以修改 NOP 程式碼的語義以賦予它新的含義。例如，BIP65（+CHECKLOCKTIMEVERIFY+）重新解釋了 NOP2 操作碼。實現 BIP65 的客戶端將 NOP2 解釋為 +OP_CHECKLOCKTIMEVERIFY+，並對包含此操作碼在其鎖定腳本中的 UTXO 施加絕對鎖定時間共識規則。根據 BIP65 有效的交易在未實現（不知道）BIP65 的任何客戶端上也是有效的。對於舊客戶端，腳本包含一個 NOP 程式碼，它被 ((("consensus rules", "soft forks", "explained", startref="consensus-soft-explain")))((("forks", "soft forks", "explained", startref="fork-soft-explain")))((("soft forks", "explained", startref="soft-fork-explain")))忽略。

===== 對軟分叉的批評

基於 NOP 操作碼的軟分叉 ((("consensus rules", "soft forks", "criticisms of", id="consensus-soft-critic")))((("forks", "soft forks", "criticisms of", id="fork-soft-critic")))((("soft forks", "criticisms of", id="soft-fork-critic")))相對沒有爭議。NOP 操作碼被放置在比特幣腳本中，明確目標是允許非破壞性升級。

然而，許多開發人員擔心其他軟分叉升級方法會做出不可接受的權衡。對軟分叉更改的常見批評包括：

技術債務:: 因為軟分叉比硬分叉升級在技術上更複雜，所以它們 ((("technical debt")))引入了_技術債務_，這個術語是指由於過去做出的設計權衡而增加未來程式碼維護成本。程式碼複雜性反過來增加了錯誤和安全漏洞的可能性。

驗證放寬:: 未修改的客戶端在不評估修改的共識規則的情況下將交易視為有效。實際上，未修改的客戶端沒有使用完整範圍的共識規則進行驗證，因為它們對新規則視而不見。這適用於基於 NOP 的升級以及其他軟分叉升級。

不可逆轉的升級:: 因為軟分叉創建具有額外共識約束的交易，所以它們在實踐中變成了不可逆轉的升級。如果軟分叉升級在啟動後被逆轉，根據新規則創建的任何交易可能會導致舊規則下的資金損失。例如，如果根據舊規則評估 CLTV 交易，則沒有時間鎖約束，可以隨時花費它。因此，批評者認為，由於錯誤而必須逆轉的失敗軟分叉幾乎肯定會導致資金損失。

[[softforksignaling]]
===== 使用區塊版本的軟分叉信號

由於軟分叉允許未修改的客戶端繼續在共識內運作，一種「啟動」軟分叉的機制是透過礦工信號表明他們已準備好並願意執行新的共識規則。如果所有礦工執行新規則，則未修改的節點接受升級節點將拒絕的區塊沒有風險。這個機制是由 BIP34 引入的。

===== BIP34：信號和啟動

BIP34 使用 ((("consensus rules", "soft forks", "BIP34 signaling/activation", tertiary-sortas="BIP034", id="consensus-soft-bip34")))((("forks", "soft forks", "BIP34 signaling/activation", tertiary-sortas="BIP034", id="fork-soft-bip34")))((("soft forks", "BIP34 signaling/activation", secondary-sortas="BIP034", id="soft-fork-bip34")))((("signaling", "BIP34", secondary-sortas="BIP034", id="signal-bip34")))((("activation (soft forks)", "BIP34", secondary-sortas="BIP034", id="activation-bip34")))((("BIP34 signaling/activation", primary-sortas="BIP034", id="bip34")))區塊版本欄位允許礦工為特定的共識規則更改發出準備就緒的信號。在 BIP34 之前，區塊版本透過_慣例_而不是_共識_強制設定為「1」。

BIP34 定義了一個共識規則更改，要求 coinbase 交易的 coinbase 欄位（輸入）包含區塊高度。在 BIP34 之前，coinbase 可以包含礦工選擇包含的任何任意資料。在 BIP34 啟動後，有效的區塊必須在 coinbase 的開頭包含特定的區塊高度，並用大於或等於「2」的區塊版本號標識。

為了表明他們準備好執行 BIP34 的規則，礦工將區塊版本設定為「2」而不是「1」。這並不會立即使版本「1」區塊無效。一旦啟動，版本「1」區塊將變為無效，所有版本「2」區塊將需要在 coinbase 中包含區塊高度才能有效。

BIP34 基於 1,000 個區塊的滾動視窗定義了兩步啟動機制。礦工會透過使用「2」作為版本號構建區塊來表明他們的個人準備狀態。嚴格來說，這些區塊還不必遵守在 coinbase 交易中包含區塊高度的新共識規則，因為共識規則尚未啟動。共識規則分兩步啟動：

- 如果 75%（最近 1,000 個區塊中的 750 個）標記為版本「2」，則版本「2」區塊必須在 coinbase 交易中包含區塊高度，否則將被拒絕為無效。版本「1」區塊仍然被網路接受，不需要包含區塊高度。舊和新共識規則在這段時間內共存。

- 當 95%（最近 1,000 個區塊中的 950 個）是版本「2」時，版本「1」區塊不再被視為有效。版本「2」區塊僅在它們在 coinbase 中包含區塊高度時才有效（根據先前的閾值）。此後，所有區塊都必須遵守新的共識規則，所有有效區塊都必須在 coinbase 交易中包含區塊高度。

在 BIP34 規則下成功信號和啟動後，此機制又被使用了兩次來啟動軟分叉：

- https://oreil.ly/Xes2l[BIP66] 簽章的嚴格 DER 編碼透過 BIP34 風格的信號與區塊版本「3」一起啟動。

- https://oreil.ly/pk8tz[BIP65] +CHECKLOCKTIMEVERIFY+ 透過 BIP34 風格的信號與區塊版本「4」一起啟動。

在 BIP65 啟動後，BIP34 的信號和啟動機制退役並被 ((("consensus rules", "soft forks", "BIP34 signaling/activation", tertiary-sortas="BIP034", startref="consensus-soft-bip34")))((("forks", "soft forks", "BIP34 signaling/activation", tertiary-sortas="BIP034", startref="fork-soft-bip34")))((("soft forks", "BIP34 signaling/activation", secondary-sortas="BIP034", startref="soft-fork-bip34")))((("signaling", "BIP34", secondary-sortas="BIP034", startref="signal-bip34")))((("activation (soft forks)", "BIP34", secondary-sortas="BIP034", startref="activation-bip34")))((("BIP34 signaling/activation", primary-sortas="BIP034", startref="bip34")))接下來描述的 BIP9 信號機制取代。

[role="less_space pagebreak-before"]
[[bip9]]
===== BIP9：信號和啟動

BIP34、BIP66 和 BIP65 使用的 ((("consensus rules", "soft forks", "BIP9 signaling/activation", tertiary-sortas="BIP009", id="consensus-soft-bip9")))((("forks", "soft forks", "BIP9 signaling/activation", tertiary-sortas="BIP009", id="fork-soft-bip9")))((("soft forks", "BIP9 signaling/activation", secondary-sortas="BIP009", id="soft-fork-bip9")))((("signaling", "BIP9", secondary-sortas="BIP009", id="signal-bip9")))((("activation (soft forks)", "BIP9", secondary-sortas="BIP009", id="activation-bip9")))((("BIP9 signaling/activation", primary-sortas="BIP009", id="bip9-ch12")))機制在啟動三個軟分叉方面是成功的。然而，它被替換了，因為它有幾個限制：

- 透過使用區塊版本的整數值，一次只能啟動一個軟分叉，因此需要軟分叉提案之間的協調以及對其優先順序和順序的一致意見。

- 此外，由於區塊版本遞增，該機制沒有提供一種直接的方式來拒絕更改然後提出不同的更改。如果舊客戶端仍在運行，他們可能會將新更改的信號誤認為是先前被拒絕的更改的信號。

- 每個新的更改不可逆轉地減少了未來更改可用的區塊版本。

提出 BIP9 是為了克服這些挑戰並提高實施未來更改的速度和便利性。

BIP9 將區塊版本解釋為位元欄位而不是整數。因為區塊版本最初用作版本 1 到 4 的整數，所以只有 29 位元可用作位元欄位。這留下了 29 個位元可用於獨立且同時地在 29 個不同的提案上發出準備就緒的信號。

BIP9 還為信號和啟動設定了最大時間。這樣礦工就不需要永遠信號。如果提案在 +TIMEOUT+ 期間（在提案中定義）內未啟動，則該提案被視為被拒絕。提案可以以不同的位元重新提交以進行信號，更新啟動期間。

此外，在 +TIMEOUT+ 過去並且功能已啟動或被拒絕之後，信號位元可以重新用於另一個功能而不會造成混淆。因此，最多可以並行信號 29 個更改。+TIMEOUT+ 之後，位元可以「回收」以提出新的更改。

[NOTE]
====
雖然信號位元可以重新使用或回收，只要投票期不重疊，BIP9 的作者建議只有在必要時才重新使用位元；由於舊軟體中的錯誤，可能會發生意外行為。簡而言之，我們不應期望看到重新使用，直到所有 29 個位元都被使用過一次。
====

提出的更改由包含以下欄位的資料結構標識：

name:: 用於區分提案的簡短描述。通常是描述提案的 BIP，如「bipN」，其中 N 是 BIP 號碼。

bit:: 0 到 28，礦工用來為此提案發出批准信號的區塊版本中的位元。

starttime:: 信號開始後的時間（基於 MTP），之後位元的值被解釋為為提案發出準備就緒的信號。

endtime:: 如果未達到啟動閾值，則更改被視為被拒絕的時間（基於 MTP）。

與 BIP34 不同，BIP9 基於 2,016 個區塊的難度重新定目標期間計算整個間隔中的啟動信號。對於每個重新定目標期間，如果為提案發出信號的區塊總和超過 95%（2,016 個中的 1,916 個），該提案將在一個重新定目標期間後啟動。

BIP9 提供了一個提案狀態圖來說明提案的各個階段和轉換，如 <<bip9states>> 所示。


[[bip9states]]
.BIP9 狀態轉換圖。
image::images/mbc3_1203.png[BIP9 Proposal State Transition Diagram]


提案在其參數在比特幣軟體中已知（定義）後從 +DEFINED+ 狀態開始。對於 MTP 在開始時間之後的區塊，提案狀態轉換到 +STARTED+。如果在重新定目標期間內超過投票閾值並且未超過超時，則提案狀態轉換到 +LOCKED_IN+。一個重新定目標期間後，提案變為 +ACTIVE+。提案一旦達到該狀態就永久保持在 +ACTIVE+ 狀態。如果在達到投票閾值之前超時過期，則提案狀態更改為 +FAILED+，表示被拒絕的提案。+FAILED+ 提案永久保持在該狀態。

BIP9 首次實施是為了啟動 +CHECKSEQUENCEVERIFY+ 和相關的 BIP（68、112、113）。名為「csv」的提案於 2016 年 7 月成功啟動。

該 ((("consensus rules", "soft forks", "BIP9 signaling/activation", tertiary-sortas="BIP009", startref="consensus-soft-bip9")))((("forks", "soft forks", "BIP9 signaling/activation", tertiary-sortas="BIP009", startref="fork-soft-bip9")))((("soft forks", "BIP9 signaling/activation", secondary-sortas="BIP009", startref="soft-fork-bip9")))((("signaling", "BIP9", secondary-sortas="BIP009", startref="signal-bip9")))((("activation (soft forks)", "BIP9", secondary-sortas="BIP009", startref="activation-bip9")))((("BIP9 signaling/activation", primary-sortas="BIP009", startref="bip9-ch12")))標準定義在 https://oreil.ly/FoCsz[BIP9（帶有超時和延遲的版本位元）]中。

===== BIP8：具有早期啟動的強制鎖定

在 ((("consensus rules", "soft forks", "BIP8 mandatory lock-in", tertiary-sortas="BIP008", id="consensus-soft-bip8")))((("forks", "soft forks", "BIP8 mandatory lock-in", tertiary-sortas="BIP008", id="fork-soft-bip8")))((("soft forks", "BIP8 mandatory lock-in", secondary-sortas="BIP008", id="soft-fork-bip8")))((("activation (soft forks)", "BIP8", secondary-sortas="BIP008", id="activate-soft-fork-bip8")))((("BIP8 mandatory lock-in", primary-sortas="BIP008", id="bip8")))((("mandatory lock-in", id="mandatory-lockin")))((("lock-in, mandatory", id="lockin-mandatory")))((("segregated witness (segwit)", id="segwit-bip8")))BIP9 成功用於 CSV 相關軟分叉後，下一次軟分叉共識更改的實施也嘗試使用它進行礦工強制啟動。然而，一些人反對該軟分叉提案，稱為 _segwit_，幾個月來很少有礦工表示準備好執行 segwit。

後來發現，一些礦工，特別是與反對者相關的礦工，可能一直在使用一種稱為_隱蔽 ASICBoost_ 的功能的硬體，這給了他們相對於使用它的其他礦工的隱藏優勢。無意中，segwit 干擾了使用隱蔽 ASICBoost 的能力——如果 segwit 被啟動，使用它的礦工將失去他們的隱藏優勢。

在社群發現這種利益衝突後，一些用戶決定他們想要行使他們的權力，不接受礦工的區塊，除非這些區塊遵循某些規則。用戶最終想要的規則是 segwit 添加的新規則，但用戶想要透過利用計劃在礦工發出足夠準備就緒信號時執行 segwit 規則的大量節點來增加他們的努力。一位匿名開發人員提出了 BIP148，((("BIP148 activation of segwit")))該提案要求任何實現它的節點從某個日期開始拒絕所有不為 segwit 發出信號的區塊，並持續到 segwit 啟動。

儘管只有有限數量的用戶實際運行 BIP148 程式碼，但許多其他用戶似乎同意這種情緒，並可能準備承諾 BIP148。在 BIP148 生效前幾天，幾乎所有礦工都開始表示他們準備好執行 segwit 的規則。Segwit 在大約兩週後達到其鎖定閾值，並在大約兩週後啟動。

許多用戶開始相信 BIP9 的一個缺陷是礦工可以透過不發出一年的信號來阻止啟動嘗試成功。他們想要一種機制，確保軟分叉在特定區塊高度之前啟動，但也允許礦工表示他們已準備好提前鎖定它。

為此開發的方法是 BIP8，它類似於 BIP9，除了它定義了一個 +MUST_SIGNAL+ 期間，礦工必須表示他們已準備好執行軟分叉提案。

發布了使用 BIP8 嘗試在 2021 年啟動 taproot 提案的軟體，並且有證據表明至少有少數用戶運行了該軟體。其中一些用戶還聲稱，他們願意使用 BIP8 強制礦工啟動 taproot 是它最終啟動的原因。他們聲稱，如果 taproot 沒有快速啟動，其他用戶也會開始運行 BIP8。不幸的是，沒有辦法證明會發生什麼，因此我們無法確定 BIP8 對 ((("consensus rules", "soft forks", "BIP8 mandatory lock-in", tertiary-sortas="BIP008", startref="consensus-soft-bip8")))((("forks", "soft forks", "BIP8 mandatory lock-in", tertiary-sortas="BIP008", startref="fork-soft-bip8")))((("soft forks", "BIP8 mandatory lock-in", secondary-sortas="BIP008", startref="soft-fork-bip8")))((("activation (soft forks)", "BIP8", secondary-sortas="BIP008", startref="activate-soft-fork-bip8")))((("BIP8 mandatory lock-in", primary-sortas="BIP008", startref="bip8")))((("mandatory lock-in", startref="mandatory-lockin")))((("lock-in, mandatory", startref="lockin-mandatory")))((("segregated witness (segwit)", startref="segwit-bip8")))taproot 的啟動貢獻了多少。

===== 快速試驗：快速失敗或最終成功

儘管 ((("consensus rules", "soft forks", "speedy trial activation", id="consensus-soft-speed")))((("forks", "soft forks", "speedy trial activation", id="fork-soft-speed")))((("soft forks", "speedy trial activation", id="soft-fork-speed")))((("speedy trial activation", id="speed-trial")))((("activation (soft forks)", "speedy trial", id="activation-speed")))BIP9 本身似乎沒有導致儘管提案得到廣泛支援但 segwit 的啟動，但對許多協議開發人員來說並不清楚 BIP9 本身是一個失敗。如前所述，礦工最初未能為 segwit 發出支援信號可能主要是一次性利益衝突的結果，該衝突在未來不會適用。對一些人來說，再次嘗試 BIP9 似乎是值得的。其他人不同意並想使用 BIP8。

在對特定啟動想法最感興趣的人之間進行數月的討論後，為了啟動 taproot，提出了一個妥協方案。建議修改版本的 BIP9，該版本只會給礦工很短的時間來表示他們打算執行 taproot 規則。如果信號不成功，可以使用不同的啟動機制（或者，可能放棄這個想法）。如果信號成功，強制執行將在大約六個月後在指定的區塊高度開始。這個機制被幫助推廣它的人之一命名為_快速試驗_。

嘗試了快速試驗啟動，礦工迅速表示他們願意執行 taproot 的規則，taproot 在大約六個月後成功啟動。對快速試驗的支持者來說，這顯然是成功的。其他人仍然失望 BIP8 沒有被使用。

目前還不清楚未來嘗試啟動軟分叉是否會再次使用快速試驗。

==== 共識軟體開發

共識軟體 ((("consensus rules", "software development")))((("software development for consensus rules")))((("forks", "consensus rule software development")))繼續發展，關於更改共識規則的各種機制有很多討論。就其本質而言，比特幣為更改的協調和共識設定了非常高的標準。作為一個去中心化的系統，它沒有可以將其意志強加於網路參與者的「權威」。權力分散在礦工、協議開發人員、錢包開發人員、交易所、商家和終端用戶等多個群體之間。任何這些群體都不能單方面做出決定。例如，雖然礦工可以透過簡單多數（51%）審查交易，但他們受到其他群體的同意的約束。如果他們單方面行動，網路的其餘參與者可能會拒絕接受他們的區塊，將經濟活動保持在少數鏈上。沒有經濟活動（交易、商家、錢包、交易所），礦工將挖掘一種無價值的貨幣，其區塊為空。這種權力的分散意味著所有參與者都必須協調，否則無法做出任何更改。現狀是這個系統的穩定狀態，如果有絕大多數的強烈共識，只有少數更改是可能的。軟分叉的 95% 閾值反映了這一現實。

重要的是要認識到，共識開發沒有完美的解決方案。硬分叉和軟分叉都涉及權衡。對於某些類型的更改，軟分叉可能是更好的選擇；對於其他更改，硬分叉可能是更好的選擇。沒有完美的選擇；兩者都有風險。共識軟體開發的一個不變特徵是更改很困難，共識迫使妥協。

有些人認為這是共識系統的弱點。隨著時間的推移，您可能會將其視為系統最大的優勢。

在本書的這一點上，我們已經完成了對比特幣系統本身的討論。剩下的是建立在比特幣之上的軟體、工具和其他協議。
