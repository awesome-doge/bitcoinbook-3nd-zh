[[blockchain]]
== 區塊鏈

區塊鏈((("區塊鏈", "說明", id="blockchain-explain")))是每筆已確認比特幣交易的歷史記錄。它允許每個完整節點獨立確定哪些金鑰和腳本控制哪些比特幣。在本章中，我們將探討區塊鏈的結構，並了解它如何使用密碼學承諾和其他巧妙的技巧，使完整節點（有時是輕量級客戶端）能夠輕鬆驗證其每個部分。

區塊鏈資料結構是一個有序的、反向連結的交易區塊列表。區塊鏈可以儲存為平面檔案或簡單的資料庫。區塊「向後」連結，每個區塊都引用鏈中的前一個區塊。區塊鏈通常被視覺化為垂直堆疊，區塊彼此層層疊加，第一個區塊作為堆疊的基礎。將區塊堆疊在一起的視覺化導致使用諸如「高度」之類的術語來指距離第一個區塊的距離，以及「頂部」或「尖端」來指最近添加的區塊。

區塊鏈中的每個區塊都由一個雜湊識別，該雜湊是使用 SHA256 密碼學雜湊演算法對區塊標頭生成的。每個區塊也透過區塊標頭中的「前一個區塊雜湊」欄位承諾前一個區塊，稱為((("父區塊")))_父區塊_。將每個區塊連結到其父區塊的雜湊序列創建了一條鏈，一直追溯到有史以來創建的第一個區塊，稱為((("創世區塊")))_創世區塊_。

儘管一個區塊只有一個父區塊，但它可以有((("子區塊")))多個子區塊。每個子區塊都承諾相同的父區塊。多個子區塊出現在區塊鏈「分叉」期間，這是一種臨時情況，當不同的礦工幾乎同時發現不同的區塊時可能發生（參見 <<forks>>）。最終，只有一個子區塊成為所有完整節點接受的區塊鏈的一部分，「分叉」得以解決。

「前一個區塊雜湊」欄位在區塊標頭內，從而影響_當前_區塊的雜湊。對父區塊的任何更改都需要更改子區塊的雜湊，這需要更改孫區塊的指標，從而更改孫區塊，依此類推。這個序列確保，一旦一個區塊有許多代跟隨它，就無法在不強制重新計算所有後續區塊的情況下更改它。由於這種重新計算需要大量計算（因此能源消耗），因此長鏈區塊的存在使得區塊鏈的深層歷史難以改變，這是比特幣安全性的關鍵特徵。

思考區塊鏈的一種方式就像地質構造或冰川核心樣本中的層。表層可能隨季節變化，甚至可能在有時間沉降之前被吹走。但是，一旦您深入幾英寸，地質層就會變得越來越穩定。當您向下看幾百英尺時，您正在查看數百萬年來未受干擾的過去快照。在區塊鏈中，如果由於分叉而導致鏈重組，最近的幾個區塊可能會被修改。前六個區塊就像幾英寸的表土。但是，一旦您更深入區塊鏈，超過六個區塊，區塊就越來越不太可能改變。在 100 個區塊之後，有如此多的穩定性，以至於 coinbase 交易——包含創建新區塊的比特幣獎勵的交易——可以被花費。雖然協議始終允許鏈被更長的鏈撤銷，並且任何區塊被逆轉的可能性始終存在，但隨著時間的推移，此類事件的機率會降低，直到它((("區塊鏈", "說明", startref="blockchain-explain")))變得微乎其微。

=== 區塊的結構

區塊((("區塊", "結構")))是一個容器資料結構，它聚合交易以包含在區塊鏈中。區塊由標頭組成，包含元資料，後面是組成其大部分大小的一長串交易。區塊標頭為 80 位元組，而區塊中所有交易的總大小最多可達約 4,000,000 位元組。因此，包含所有交易的完整區塊可以比區塊標頭大近 50,000 倍。<<block_structure1>> 描述了 Bitcoin Core 如何儲存區塊的結構。

++++
<table id="block_structure1">
<caption>區塊的結構</caption>
<thead>
<tr>
<th>大小</th>
<th>欄位</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>4 位元組</p></td>
<td><p>區塊大小</p></td>
<td><p>此欄位之後的區塊大小（以位元組為單位）</p></td>
</tr>
<tr>
<td><p>80 位元組</p></td>
<td><p>區塊標頭</p></td>
<td><p>幾個欄位組成區塊標頭</p></td>
</tr>
<tr>
<td><p>1–3 位元組（compactSize）</p></td>
<td><p>交易計數器</p></td>
<td><p>後面有多少筆交易</p></td>
</tr>
<tr>
<td><p>可變</p></td>
<td><p>交易</p></td>
<td><p>此區塊中記錄的交易</p></td>
</tr>
</tbody>
</table>
++++


[[block_header]]
=== 區塊標頭

區塊標頭((("區塊", "區塊標頭")))((("區塊標頭")))由區塊元資料組成，如 <<block_header_structure_ch09>> 所示。

++++
<table id="block_header_structure_ch09">
<caption>區塊標頭的結構</caption>
<thead>
<tr>
<th>大小</th>
<th>欄位</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>4 位元組</p></td>
<td><p>版本</p></td>
<td><p>最初是一個版本欄位；其用途隨時間演變</p></td>
</tr>
<tr>
<td><p>32 位元組</p></td>
<td><p>前一個區塊雜湊</p></td>
<td><p>鏈中前一個（父）區塊的雜湊</p></td>
</tr>
<tr>
<td><p>32 位元組</p></td>
<td><p>默克爾根</p></td>
<td><p>此區塊交易的默克爾樹的根雜湊</p></td>
</tr>
<tr>
<td><p>4 位元組</p></td>
<td><p>時間戳</p></td>
<td><p>此區塊的近似創建時間（Unix 紀元時間）</p></td>
</tr>
<tr>
<td><p>4 位元組</p></td>
<td><p>目標</p></td>
<td><p>此區塊的工作量證明目標的緊湊編碼</p></td>
</tr>
<tr>
<td><p>4 位元組</p></td>
<td><p>Nonce</p></td>
<td><p>用於工作量證明演算法的任意資料</p></td>
</tr>
</tbody>
</table>
++++

nonce、目標和時間戳在挖礦過程中使用，將在 <<mining>> 中更詳細地討論。

[[block_hash]]
=== 區塊識別符：區塊標頭雜湊和區塊高度

區塊的((("區塊", "識別符", id="block-identify")))((("區塊標頭雜湊", id="block-header-hash")))((("區塊高度", id="block-height")))主要識別符是其密碼學雜湊，這是透過兩次使用 SHA256 演算法對區塊標頭進行雜湊處理而做出的承諾。產生的 32 位元組雜湊稱為_區塊雜湊_，但更準確地說是_區塊標頭雜湊_，pass:[<span class="keep-together">因為只有區塊標頭用於計算它。例如，</span>] +000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f+ 是比特幣區塊鏈上第一個區塊的區塊雜湊。區塊雜湊唯一且明確地識別一個區塊，任何節點都可以透過簡單地對區塊標頭進行雜湊處理來獨立推導它。

請注意，區塊雜湊實際上並未包含在區塊的資料結構中。相反地，當節點從網路接收區塊時，每個節點都會計算區塊的雜湊。區塊雜湊可能儲存在單獨的資料庫表中，作為區塊元資料的一部分，以便於索引和從磁碟更快地檢索區塊。

識別區塊的第二種方法是根據其在區塊鏈中的位置，稱為 pass:[<span class="keep-together"><em>區塊高度</em>。創世區塊的區塊高度為 0（零），並且是</span>] pass:[<span class="keep-together">先前由以下區塊雜湊引用的同一區塊</span>] +000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f+。因此，區塊可以透過兩種方式識別：透過引用區塊雜湊或透過引用區塊高度。每個後續區塊添加在該第一個區塊「之上」，在區塊鏈中處於一個位置「更高」，就像一個接一個堆疊的盒子。在撰寫本書期間，區塊高度 800,000 於 2023 年中期達到，這意味著在 2009 年 1 月創建的第一個區塊之上堆疊了 800,000 個區塊。

與區塊雜湊不同，區塊高度不是唯一識別符。儘管單個區塊將始終具有特定且不變的區塊高度，但反之則不然——區塊高度並不總是識別單個區塊。兩個或更多區塊可能具有相同的區塊高度，爭奪區塊鏈中的相同位置。此場景在 <<forks>> 章節中詳細討論。在早期區塊中，區塊高度也不是區塊資料結構的一部分；它沒有儲存在區塊中。當從比特幣網路接收區塊時，每個節點動態識別區塊在區塊鏈中的位置（高度）。後來的協議變更（BIP34）開始在 coinbase 交易中包含區塊高度，儘管其目的是確保每個區塊具有不同的 coinbase 交易。節點仍然需要動態識別區塊的高度以驗證 coinbase 欄位。區塊高度也可能儲存為索引資料庫表中的元資料，以便更快地檢索。

[TIP]
====
區塊的_區塊雜湊_始終唯一識別單個區塊。區塊也始終具有特定的_區塊高度_。然而，並非總是特定區塊高度識別單個區塊。相反地，兩個或更多區塊可能爭奪區塊鏈中的((("區塊", "識別符", startref="block-identify")))((("區塊標頭雜湊", startref="block-header-hash")))((("區塊高度", startref="block-height")))單個位置。
====

=== 創世區塊

區塊鏈中的第一個區塊((("區塊鏈", "創世區塊", id="blockchain-genesis")))((("創世區塊", id="genesis-block")))((("Bitcoin Core", "創世區塊", id="bitcoin-core-genesis")))稱為_創世區塊_，創建於 2009 年。它是區塊鏈中所有區塊的共同祖先，這意味著如果您從任何區塊開始並在時間上向後追溯鏈，您最終將到達創世區塊。

每個節點始終以至少一個區塊的區塊鏈開始，因為創世區塊在 Bitcoin Core 中靜態編碼，因此無法更改。每個節點始終「知道」創世區塊的雜湊和結構、創建它的固定時間，甚至其中的單個交易。因此，每個節點都有區塊鏈的起點，一個安全的「根」，從中建立可信的區塊鏈。

請參閱 Bitcoin Core 客戶端內部靜態編碼的創世區塊，位於 https://oreil.ly/FqPW5[_chainparams.cpp_]。

以下識別符雜湊屬於創世區塊：

----
000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
----

您可以在幾乎任何區塊瀏覽器網站上搜尋該區塊雜湊，例如 _blockstream.info_，您將找到一個描述此區塊內容的頁面，其 URL 包含該雜湊：

[quote]
____
https://blockstream.info/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
____

或者，您可以在命令列上使用 Bitcoin Core 獲取區塊：

----
$ bitcoin-cli getblock \
  000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
----
[source,json]
----
{
  "hash": "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f",
  "confirmations": 790496,
  "height": 0,
  "version": 1,
  "versionHex": "00000001",
  "merkleroot": "4a5e1e4baab89f3a32518a88c3[...]76673e2cc77ab2127b7afdeda33b",
  "time": 1231006505,
  "mediantime": 1231006505,
  "nonce": 2083236893,
  "bits": "1d00ffff",
  "difficulty": 1,
  "chainwork": "[...]000000000000000000000000000000000000000000000100010001",
  "nTx": 1,
  "nextblockhash": "00000000839a8e6886ab5951d7[...]fc90947ee320161bbf18eb6048",
  "strippedsize": 285,
  "size": 285,
  "weight": 1140,
  "tx": [
    "4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b"
  ]
}
----

創世區塊在其中包含一條訊息。coinbase 交易輸入包含文字「The Times 03/Jan/2009 Chancellor on brink of second bailout for banks.」此訊息旨在透過引用英國報紙 _The Times_ 的標題來提供此區塊可能創建的最早日期的證明。它也作為獨立貨幣系統重要性的諷刺提醒，比特幣的推出發生在史無前例的全球貨幣危機的同時。該訊息由比特幣的((("Nakamoto, Satoshi")))((("區塊鏈", "創世區塊", startref="blockchain-genesis")))((("創世區塊", startref="genesis-block")))((("Bitcoin Core", "創世區塊", startref="bitcoin-core-genesis")))創造者中本聰嵌入在第一個區塊中。

=== 在區塊鏈中連結區塊

比特幣((("區塊鏈", "連結區塊", id="blockchain-link")))((("區塊", "在區塊鏈中連結", id="block-link")))((("在區塊鏈中連結區塊", id="link-block")))完整節點驗證創世區塊之後的區塊鏈中的每個區塊。它們對區塊鏈的本機檢視會隨著找到新區塊並用於擴展鏈而不斷更新。當節點從網路接收傳入區塊時，它將驗證這些區塊，然後將它們連結到其現有區塊鏈的檢視。要建立連結，節點將檢查傳入區塊標頭並尋找「前一個區塊雜湊」。

[role="less_space pagebreak-before"]
例如，假設一個節點在區塊鏈的本機副本中有 277,314 個區塊。節點知道的最後一個區塊是區塊 277,314，其區塊標頭雜湊為：

----
00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249
----

然後，比特幣節點從網路接收一個新區塊，它將其解析如下：

[source,json]
----
{
    "size" : 43560,
    "version" : 2,
    "previousblockhash" :
        "00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249",
    "merkleroot" :
        "5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d",
    "time" : 1388185038,
    "difficulty" : 1180923195.25802612,
    "nonce" : 4215469401,
    "tx" : [
        "257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77",
        "[... many more transactions omitted ...]",
        "05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634"
    ]
}
----

查看這個新區塊，節點找到 +previousblockhash+ 欄位，其中包含其父區塊的雜湊。這是節點已知的雜湊，即高度 277,314 的鏈上最後一個區塊的雜湊。因此，這個新區塊是鏈上最後一個區塊的子區塊，並擴展了現有的區塊鏈。節點將這個新區塊添加到鏈的末端，使區塊鏈變得更長，新高度為 277,315。<<chain_of_blocks>> 顯示了三個區塊的鏈，透過((("區塊鏈", "連結區塊", startref="blockchain-link")))((("區塊", "在區塊鏈中連結", startref="block-link")))((("在區塊鏈中連結區塊", startref="link-block"))) +previousblockhash+ 欄位中的引用連結。

[[chain_of_blocks]]
.透過每個引用前一個區塊標頭雜湊在鏈中連結的區塊。
image::images/mbc3_1101.png[]

[[merkle_trees]]
=== 默克爾樹

比特幣區塊鏈中的每個區塊((("區塊鏈", "默克爾樹", id="blockchain-merkle")))((("默克爾樹", id="merkle-tree-explain")))都包含使用_默克爾樹_對區塊中所有交易的摘要。

_默克爾樹_，也稱為_二元雜湊樹_，是((("二元雜湊樹")))一種用於有效摘要和驗證大型資料集完整性的資料結構。默克爾樹是包含密碼學雜湊的二元樹。在計算機科學中，術語「樹」用於描述分支資料結構，但這些樹通常顯示為倒置，「根」在頂部，「葉」在圖表底部，如您將在下面的範例中看到的那樣。

默克爾樹在比特幣中用於摘要區塊中的所有交易，產生對整個交易集的總體承諾，並允許非常有效的過程來驗證交易是否包含在區塊中。默克爾樹透過遞迴地對元素對進行雜湊處理來構建，直到只有一個雜湊，稱為_根_或_默克爾根_。比特幣默克爾樹中使用的密碼學雜湊演算法是 SHA256 應用兩次，也稱為雙 SHA256。

當 N 個資料元素被雜湊並在默克爾樹中摘要時，您可以使用大約 +log~2~(N)+ 次計算來檢查任何一個資料元素是否包含在樹中，使其成為非常有效的資料結構。

默克爾樹是自下而上構建的。在以下範例中，我們從四筆交易 A、B、C 和 D 開始，它們構成默克爾樹的_葉_，如 <<simple_merkle>> 所示。交易不儲存在默克爾樹中；相反地，它們的資料被雜湊處理，產生的雜湊儲存在每個葉節點中，作為 H~A~、H~B~、H~C~ 和 H~D~：

++++
<pre data-type="codelisting">
H<sub>A</sub> = SHA256(SHA256(Transaction A))
</pre>
++++

然後，透過串聯兩個雜湊並一起對它們進行雜湊處理，在父節點中摘要連續的葉節點對。例如，要構建父節點 H~AB~，將子節點的兩個 32 位元組雜湊串聯以創建 64 位元組字串。然後，對該字串進行雙雜湊處理以產生父節點的雜湊：

++++
<pre data-type="codelisting">
H<sub>AB</sub> = SHA256(SHA256(H<sub>A</sub> || H<sub>B</sub>))
</pre>
++++

此過程繼續進行，直到頂部只有一個節點，稱為默克爾根的節點。該 32 位元組雜湊儲存在區塊標頭中，並摘要所有四筆交易中的所有資料。<<simple_merkle>> 顯示了如何透過節點的成對雜湊計算根。

[[simple_merkle]]
.計算默克爾樹中的節點。
image::images/mbc3_1102.png["merkle_tree"]

由於默克爾樹是二元樹，因此需要偶數個葉節點。如果要摘要的交易數量為奇數，則最後一個交易雜湊將被複製以創建偶數個葉節點，也稱為((("平衡默克爾樹")))_平衡樹_。這在 <<merkle_tree_odd>> 中顯示，其中交易 C 被複製。同樣，如果在任何等級要處理的雜湊數量為奇數，則最後一個雜湊被複製。

[[merkle_tree_odd]]
.複製一個資料元素以實現偶數個資料元素。
image::images/mbc3_1103.png["merkle_tree_odd"]

.比特幣默克爾樹的設計缺陷
****
Bitcoin Core 原始碼中的一條擴展註釋，在此稍作修訂後轉載，描述了比特幣默克爾樹中複製奇數元素的設計中的一個重大問題：


____
警告！如果您正在閱讀此內容是因為您正在學習密碼學和／或設計一個將使用默克爾樹的新系統，請記住，以下默克爾樹演算法存在與重複 txid 相關的嚴重缺陷，導致漏洞（CVE-2012-2459）。

原因是，如果在給定等級的列表中的雜湊數量為奇數，則在計算下一個等級之前複製最後一個（這在默克爾樹中不常見）。這導致某些交易序列導致相同的默克爾根。例如，<<cve_tree>> 中的兩棵樹：

[[cve_tree]]
[role="width-90"]
.兩個具有相同根但不同葉數量的比特幣風格默克爾樹。
image::images/mbc3_1104.png["兩個具有相同根但不同葉數量的比特幣風格默克爾樹"]

交易列表 [1,2,3,4,5,6] 和 [1,2,3,4,5,6,5,6]（其中 5 和 6 重複）產生相同的根雜湊 A（因為 (F) 和 (F,F) 的雜湊都是 C）。

漏洞來自能夠發送具有這樣的交易列表的區塊，具有相同的默克爾根和與原始區塊相同的區塊雜湊，而無需複製，導致驗證失敗。然而，如果接收節點繼續將該區塊標記為永久無效，它將無法接受同一區塊的進一步未修改（因此可能有效）版本。我們透過檢測我們將在列表末尾將兩個相同的雜湊一起雜湊處理的情況來防禦此情況，並將其視為與具有無效默克爾根的區塊相同。假設沒有雙 SHA256 衝突，這將檢測到所有已知的在不影響默克爾根的情況下更改交易的方法。

++++
<p data-type="attribution">Bitcoin Core <em>src/consensus/merkle.cpp</em></p>
++++
____

****

[role="less_space pagebreak-before"]
從四筆交易構建樹的相同方法可以推廣到構建任何大小的樹。在比特幣中，單個區塊中通常有數千筆交易，以完全相同的方式摘要，僅產生 32 位元組的資料作為單個默克爾根。在 <<merkle_tree_large>> 中，您將看到從 16 筆交易構建的樹。請注意，儘管根在圖表中看起來比葉節點大，但它的大小完全相同，只有 32 位元組。無論區塊中有一筆交易還是一萬筆交易，默克爾根始終將它們摘要為 32 位元組。

要證明特定交易包含在區塊中，節點只需要產生大約 +log~2~(N)+ 個 32 位元組雜湊，構成((("認證路徑")))((("默克爾路徑")))_認證路徑_或_默克爾路徑_，將特定交易連接到樹的根。隨著交易數量的增加，這一點尤其重要，因為交易數量的以 2 為底的對數增長要慢得多。這允許比特幣節點有效地產生 10 或 12 個雜湊（320–384 位元組）的路徑，這可以提供數兆位元組區塊中超過一千筆交易中單筆交易的證明。

[[merkle_tree_large]]
.摘要許多資料元素的默克爾樹。
image::images/mbc3_1105.png["merkle_tree_large"]

在 <<merkle_tree_path>> 中，節點可以透過產生僅四個 32 位元組雜湊長（總共 128 位元組）的默克爾路徑來證明交易 K 包含在區塊中。該路徑由四個雜湊（以陰影背景顯示）H~L~、H~IJ~、H~MNOP~ 和 H~ABCDEFGH~ 組成。透過提供這四個雜湊作為認證路徑，任何節點都可以透過計算四個額外的成對雜湊 H~KL~、H~IJKL~、H~IJKLMNOP~ 和默克爾樹根（在圖表中以虛線輪廓顯示）來證明 H~K~（在圖表底部具有黑色背景）包含在默克爾根中。

[[merkle_tree_path]]
.用於證明資料元素包含的默克爾路徑。
image::images/mbc3_1106.png["merkle_tree_path"]

隨著規模的增加，默克爾樹的效率變得顯而易見。最大的可能區塊可以在 4,000,000 位元組中容納近 16,000 筆交易，但證明這 16,000 筆交易中的任何一筆是該區塊的一部分只需要交易的副本、80 位元組區塊標頭的副本和 448 位元組的默克爾證明。這使得最大的可能證明比最大的可能比特幣區塊小近 10,000 倍。

=== 默克爾樹和輕量級客戶端

默克爾樹被((("比特幣網路", "輕量級客戶端", "默克爾樹和")))((("輕量級客戶端", "默克爾樹和")))輕量級客戶端廣泛使用。輕量級客戶端沒有所有交易，也不下載完整區塊，只下載區塊標頭。為了驗證交易是否包含在區塊中，而無需下載區塊中的所有交易，它們使用默克爾路徑。

例如，考慮一個輕量級客戶端，它對錢包中包含的地址的傳入付款感興趣。輕量級客戶端將在其與對等節點的連接上建立布隆過濾器（參見 <<bloom_filters>>），以將接收的交易限制為僅包含感興趣的地址的交易。當對等節點看到與布隆過濾器匹配的交易時，它將使用 +merkleblock+ 訊息發送該區塊。+merkleblock+ 訊息包含區塊標頭以及將感興趣的交易連結到區塊中的默克爾根的默克爾路徑。輕量級客戶端可以使用此默克爾路徑將交易連接到區塊標頭，並驗證交易是否包含在區塊中。輕量級客戶端還使用區塊標頭將區塊連結到區塊鏈的其餘部分。這兩個連結的組合，交易和區塊之間以及區塊和區塊鏈之間的連結，證明了交易記錄在區塊鏈中。總而言之，輕量級客戶端將接收不到一千位元組的資料用於區塊標頭和默克爾路徑，這個資料量比完整區塊（目前約 2 MB ((("區塊鏈", "默克爾樹", startref="blockchain-merkle")))((("默克爾樹", startref="merkle-tree-explain")))）少一千多倍。

=== 比特幣的測試區塊鏈

您可能會驚訝地得知，比特幣使用的區塊鏈不止一個。由中本聰於 2009 年 1 月 3 日創建的「主要」比特幣區塊鏈，我們在本章中研究的具有創世區塊的區塊鏈，被((("主網")))稱為_主網_。還有其他用於測試目的的比特幣區塊鏈：目前是 _testnet_、_signet_ 和 _regtest_。讓我們依次看一下每個。

==== Testnet：比特幣的測試遊樂場

Testnet 是((("區塊鏈", "測試區塊鏈", "testnet", id="blockchain-test-testnet")))((("測試區塊鏈", "testnet", id="test-block-testnet")))((("testnet", id="testnet")))用於測試目的的測試區塊鏈、網路和貨幣的名稱。testnet 是一個功能齊全的實時 P2P 網路，具有錢包、測試比特幣（testnet 幣）、挖礦以及主網的所有其他功能。最重要的區別是 testnet 幣被認為是無價值的。

任何旨在在比特幣主網上進行生產使用的軟體開發都可以首先使用測試幣在 testnet 上進行測試。這既保護開發人員免受由於錯誤而造成的金錢損失，也保護網路免受由於錯誤而導致的意外行為。

當前的 testnet 稱為 _testnet3_，是 testnet 的第三次迭代，於 2011 年 2 月重新啟動，以重置先前 testnet 的難度。Testnet3 是一個大型區塊鏈，在 2023 年超過 30 GB。它需要一段時間才能完全同步，並且會佔用您電腦上的資源。不像主網那麼多，但也不完全是「輕量級」的。

[TIP]
====
Testnet 和本書中描述的其他測試區塊鏈不使用與主網地址相同的地址前綴，以防止有人意外將真實比特幣發送到測試地址。主網地址以 +1+、+3+ 或 +bc1+ 開頭。本書中提到的測試網路的地址以 +m+、+n+ 或 +tb1+ 開頭。其他測試網路或在測試網路上開發的新協議可能使用其他地址前綴或更改。
====

===== 使用 testnet

Bitcoin Core，像((("Bitcoin Core", "testnet")))許多其他比特幣程式一樣，完全支援在 testnet 上作為替代主網的操作。Bitcoin Core 的所有功能都可以在 testnet 上運作，包括錢包、挖掘 testnet 幣和同步完整的 testnet 節點。

[role="less_space pagebreak-before"]
要在 testnet 而不是主網上啟動 Bitcoin Core，您可以使用 +testnet+ 開關：

----
$ bitcoind -testnet
----

在日誌中，您應該看到 bitcoind 正在 bitcoind 預設目錄的 +testnet3+ 子目錄中建立新的區塊鏈：

----
bitcoind: Using data directory /home/username/.bitcoin/testnet3
----

要連接到 bitcoind，您可以使用 +bitcoin-cli+ 命令列工具，但您還必須將其切換到 testnet 模式：

----
$ bitcoin-cli -testnet getblockchaininfo
{
  "chain": "test",
  "blocks": 1088,
  "headers": 139999,
  "bestblockhash": "0000000063d29909d475a1c[...]368e56cce5d925097bf3a2084370128",
  "difficulty": 1,
  "mediantime": 1337966158,
  "verificationprogress": 0.001644065914099759,
  "chainwork": "[...]000000000000000000000000000000000000000000044104410441",
  "pruned": false,
  "softforks": [

  [...]
----

您也可以在其他完整節點實現上執行 testnet3，例如 +btcd+（用 Go 編寫）和 +bcoin+（用 JavaScript 編寫），以使用其他程式語言和框架進行實驗和學習。

Testnet3 支援主網的所有功能，包括隔離見證 v0 和 v1（參見 <<segwit>> 和 <<taproot>>）。因此，testnet3 也可用於測試隔離見證功能。

===== testnet 的問題

Testnet 不僅使用與比特幣相同的資料結構，還使用與比特幣幾乎完全相同的工作量證明安全機制。testnet 的顯著區別是其最低難度是比特幣的一半，並且如果該區塊的時間戳比前一個區塊晚 20 分鐘以上，則允許它包含最低難度的區塊。

不幸的是，比特幣的 PoW 安全機制被設計為依賴於經濟激勵——這些激勵在禁止有價值的測試區塊鏈中不存在。在主網上，礦工有動機將使用者交易包含在他們的區塊中，因為這些交易支付手續費。在 testnet 上，交易仍然包含稱為手續費的東西，但這些手續費沒有任何經濟價值。這意味著 testnet 礦工包含交易的唯一動機是因為他們想幫助使用者和開發人員測試他們的軟體。

唉，喜歡破壞系統的人通常會感受到更強的動機，至少在短期內是這樣。由於 PoW 挖礦被設計為無需許可，任何人都可以挖礦，無論他們的意圖是好是壞。這意味著破壞性礦工可以在 testnet 上連續創建許多區塊，而不包含任何使用者交易。當這些攻擊發生時，testnet 對使用者和((("區塊鏈", "測試區塊鏈", "testnet", startref="blockchain-test-testnet")))((("測試區塊鏈", "testnet", startref="test-block-testnet")))((("testnet", startref="testnet")))開發人員來說變得不可用。

==== Signet：權威證明測試網路

沒有((("區塊鏈", "測試區塊鏈", "signet", id="blockchain-test-signet")))((("測試區塊鏈", "signet", id="test-block-signet")))((("signet", id="signet")))已知的方法讓依賴於無需許可 PoW 的系統在不引入經濟激勵的情況下提供高度可用的區塊鏈，因此比特幣協議開發人員開始考慮替代方案。主要目標是盡可能保留比特幣的結構，以便軟體可以在測試網路上以最小的更改執行——但同時也提供一個保持有用的環境。次要目標是產生一個可重複使用的設計，使新軟體的開發人員可以輕鬆創建自己的測試網路。

在 Bitcoin Core 和其他軟體中實現的解決方案稱為 _signet_，由 BIP325 定義。signet 是一個測試網路，其中每個區塊必須包含證明（例如簽章）該區塊的創建得到可信權威機構的批准。

而在比特幣中挖礦是無需許可的——任何人都可以做——在 signet 上挖礦是完全需要許可的。只有獲得許可的人才能做到。這對比特幣的主網來說是完全不可接受的變化——沒有人會使用該軟體——但在測試網路上是合理的，其中幣沒有價值，唯一的目的是測試軟體和系統。

BIP325 signet 的設計使得創建自己的 signet 非常容易。如果您不同意別人執行其 signet 的方式，您可以啟動自己的 signet 並將您的軟體連接到它。

===== 預設 signet 和自訂 signet

Bitcoin Core 支援((("Bitcoin Core", "signet")))((("預設 signet")))((("自訂 signet")))預設 signet，我們認為這是撰寫本文時使用最廣泛的 signet。它目前由該專案的兩位貢獻者營運。如果您使用 +signet+ 參數而沒有其他 signet 相關參數啟動 Bitcoin Core，這就是您將使用的 signet。

在撰寫本文時，預設 signet 約有 150,000 個區塊，大小約為 1 GB。它支援與比特幣主網相同的所有功能，還用於透過 Bitcoin Inquisition 專案測試提議的升級，該專案是 Bitcoin Core 的軟體分支，僅設計為在 signet 上執行。

如果您想使用不同的 signet，稱為_自訂 signet_，您需要知道用於確定何時授權區塊的腳本，稱為((("挑戰腳本")))_挑戰_腳本。這是一個標準的比特幣腳本，因此它可以使用多重簽章等功能來允許多人授權區塊。您可能還需要連接到種子節點，該節點將為您提供自訂 signet 上的對等節點地址。例如：

----
bitcoind -signet -signetchallenge=0123...cdef -signetseednode=example.com:1234
----

在撰寫本文時，我們通常建議挖礦軟體的公開測試在 testnet3 上進行，所有其他比特幣軟體的公開測試在預設 signet 上進行。

要與您選擇的 signet 互動，您可以使用 +-signet+ 參數與 +bitcoin-cli+，類似於您使用 testnet 的方式。例如((("區塊鏈", "測試區塊鏈", "signet", startref="blockchain-test-signet")))((("測試區塊鏈", "signet", startref="test-block-signet")))((("signet", startref="signet")))：

----
$ bitcoin-cli -signet getblockchaininfo
{
  "chain": "signet",
  "blocks": 143619,
  "headers": 143619,
  "bestblockhash": "000000c46cb3505ddd296537[...]ad1c5768e2908439382447572a93",
  "difficulty": 0.003020638517858618,
  "time": 1684530244,
  "mediantime": 1684526116,
  "verificationprogress": 0.999997961940662,
  "initialblockdownload": false,
  "chainwork": "[...]000000000000000000000000000000000000000000019ab37d2194",
  "size_on_disk": 769525915,
  "pruned": false,
  "warnings": ""
}
----

==== Regtest：本機區塊鏈

Regtest，((("區塊鏈", "測試區塊鏈", "regtest", id="blockchain-test-regtest")))((("測試區塊鏈", "regtest", id="test-block-regtest")))((("regtest", id="regtest")))代表「迴歸測試」，是 Bitcoin Core 功能，允許您為測試目的創建本機區塊鏈。與 signet 和 testnet3 不同，它們是公共和共享的測試區塊鏈，regtest 區塊鏈旨在作為封閉系統執行以進行本機測試。您從頭開始啟動 regtest 區塊鏈。您可以將其他節點添加到網路，或僅使用單個節點執行它以測試 Bitcoin Core 軟體。

要((("Bitcoin Core", "regtest")))在 regtest 模式下啟動 Bitcoin Core，您可以使用 +regtest+ 旗標：

----
$ bitcoind -regtest
----

就像 testnet 一樣，Bitcoin Core 將在您的 bitcoind 預設目錄的 _regtest_ 子目錄下初始化新的區塊鏈：

----
bitcoind: Using data directory /home/username/.bitcoin/regtest
----

[role="less_space pagebreak-before"]
要使用命令列工具，您也需要指定 +regtest+ 旗標。讓我們嘗試 +getblockchaininfo+ 命令來檢查 regtest 區塊鏈：

----
$ bitcoin-cli -regtest getblockchaininfo
{
  "chain": "regtest",
  "blocks": 0,
  "headers": 0,
  "bestblockhash": "0f9188f13cb7b2c71f2a335e3[...]b436012afca590b1a11466e2206",
  "difficulty": 4.656542373906925e-10,
  "mediantime": 1296688602,
  "verificationprogress": 1,
  "chainwork": "[...]000000000000000000000000000000000000000000000000000002",
  "pruned": false,
  [...]
----

如您所見，還沒有區塊。讓我們創建一個預設錢包，獲取一個地址，然後挖掘一些（500 個區塊）以賺取獎勵：

----
$ bitcoin-cli -regtest createwallet ""

$ bitcoin-cli -regtest getnewaddress
bcrt1qwvfhw8pf79kw6tvpmtxyxwcfnd2t4e8v6qfv4a

$ bitcoin-cli -regtest generatetoaddress 500 \
  bcrt1qwvfhw8pf79kw6tvpmtxyxwcfnd2t4e8v6qfv4a
[
  "3153518205e4630d2800a4cb65b9d2691ac68eea99afa7fd36289cb266b9c2c0",
  "621330dd5bdabcc03582b0e49993702a8d4c41df60f729cc81d94b6e3a5b1556",
  "32d3d83538ba128be3ba7f9dbb8d1ef03e1b536f65e8701893f70dcc1fe2dbf2",
  ...,
  "32d55180d010ffebabf1c3231e1666e9eeed02c905195f2568c987c2751623c7"
]
----

挖掘所有這些區塊只需要幾秒鐘，這無疑使測試變得容易。如果您檢查您的錢包餘額，您將看到您獲得了前 400 個區塊的獎勵（coinbase 獎勵必須深度 100 個區塊才能((("區塊鏈", "測試區塊鏈", "regtest", startref="blockchain-test-regtest")))((("測試區塊鏈", "regtest", startref="test-block-regtest")))((("regtest", startref="regtest")))花費它們）：

----
$ bitcoin-cli -regtest getbalance
12462.50000000
----

=== 使用測試區塊鏈進行開發

比特幣的((("區塊鏈", "測試區塊鏈", "開發使用")))((("測試區塊鏈", "開發使用")))各種區塊鏈（regtest、signet、testnet3、mainnet）為比特幣開發提供了一系列測試環境。無論您是為 Bitcoin Core 或另一個完整節點共識客戶端開發；開發錢包、交易所、電子商務網站等應用程式；還是開發新穎的智慧合約和複雜腳本，都可以使用測試區塊鏈。

您可以使用測試區塊鏈建立開發管道。在開發程式碼時，在 regtest 上本機測試您的程式碼。一旦您準備好在公共網路上嘗試它，請切換到 signet 或 testnet，以將您的程式碼暴露於更動態的環境中，具有更多樣化的程式碼和應用程式。最後，一旦您確信您的程式碼按預期工作，請切換到主網以在生產中部署它。當您進行更改、改進、錯誤修復等時，請再次啟動管道，首先在 regtest 上部署每個更改，然後在 signet 或 testnet 上，最後進入生產。

現在我們知道區塊鏈包含哪些資料以及密碼學承諾如何安全地將各個部分綁定在一起，我們將研究既提供計算安全性又確保沒有區塊可以在不使所有其他區塊無效的情況下被更改的特殊承諾
