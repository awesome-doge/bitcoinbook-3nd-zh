[[tx_fees]]
== 交易手續費

++++
<p class="fix_tracking">
我們在 <a data-type="xref" href="#c_signatures">#c_signatures</a> 中看到 Alice 創建的數位簽章只能證明她知道她的私鑰並且她承諾了一筆支付 Bob 的交易。她可以創建另一個簽章，改為承諾一筆支付 Carol 的交易——一筆花費與支付 Bob 相同輸出（比特幣）的交易。這兩筆交易現在是<em>衝突交易</em>，因為在具有最多工作量證明的有效區塊鏈中——完整節點用來確定哪些金鑰控制哪些比特幣的區塊鏈——只能包含花費特定輸出的一筆交易。
</p>
++++

為了((("衝突交易")))((("交易", "衝突")))保護自己免受衝突交易的影響，Bob 明智的做法是等到 Alice 的交易被包含在區塊鏈中到足夠的深度，然後再認為他收到的錢可以由他花費（請參見 <<confirmations>>）。要將 Alice 的交易包含在區塊鏈中，它必須被包含在交易_區塊_中。在((("區塊", "交易")))((("交易", "在區塊中", secondary-sortas="blocks")))給定時間內產生的區塊數量有限，並且每個區塊只有有限的空間。只有創建該區塊的礦工才能選擇包含哪些交易。礦工可以按他們想要的任何標準選擇交易，包括完全拒絕包含任何交易。

++++
<div data-type="note">
<p class="fix_tracking"> 在本章中，當我們說「交易」時，我們指的是區塊中除第一筆交易之外的每筆交易。區塊中的第一筆交易是 <em>coinbase 交易</em>，在 <a data-type="xref" href="#coinbase_transactions">#coinbase_transactions</a> 中描述，它允許區塊的礦工收取其生產區塊的獎勵。與其他交易不同，coinbase 交易不花費先前交易的輸出，也是適用於其他交易的其他幾項規則的例外。Coinbase 交易不支付交易手續費，不需要進行手續費提升，不受交易固定的影響，並且對以下關於手續費的討論基本上沒有意義——所以我們將在本章中忽略它們。
</p>
</div>
++++


幾乎所有礦工用來選擇在其區塊中包含哪些交易的標準是最大化其收入。Bitcoin 專門設計為透過提供一種機制來適應這一點，該機制允許交易將錢給包含該交易在區塊中的礦工。我們稱這種機制為_交易手續費_，儘管它不是該詞通常意義上的手續費。它不是由協議或任何特定礦工設定的金額——它更像是拍賣中的出價。購買的商品是交易將消耗的區塊中有限空間的一部分。礦工選擇一組交易，其出價將使他們能夠賺取最大收入。

在本章中，我們將探討這些出價——交易手續費——的各個方面，以及它們如何影響 Bitcoin 交易的創建和管理。

=== 誰支付交易手續費？

大多數((("交易手續費", "支付責任", id="fees-responsibility")))((("支付", "交易手續費", see="交易手續費")))((("手續費", see="交易手續費")))支付系統都涉及某種交易手續費，但這種手續費通常對典型買家是隱藏的。例如，商家可能以相同的價格宣傳相同的商品，無論您是用現金還是信用卡支付，即使他們的支付處理商對信用交易收取的手續費可能高於他們的銀行對現金存款收取的手續費。

在 Bitcoin 中，每次花費比特幣都必須經過認證（通常使用簽章），因此交易不可能在未經支付者許可的情況下支付手續費。交易的接收者可以在不同的交易中支付手續費——我們稍後會看到這種用法——但如果我們希望單筆交易支付自己的手續費，該手續費需要由支付者同意。它無法被隱藏。

Bitcoin 交易的設計使得支付者承諾其支付的手續費不需要在交易中佔用任何額外空間。這意味著，儘管可以在不同的交易中支付手續費，但在單筆交易中支付手續費是最有效率的（因此最便宜）。

在 Bitcoin 中，手續費是一種出價，支付的金額有助於確定交易確認所需的時間。支付的支付者和接收者通常都有興趣使其快速確認，因此通常只允許支付者選擇手續費有時可能是一個問題；我們將在 <<cpfp>> 中查看該問題的解決方案。但是，在許多常見的支付流程中，最希望看到交易快速確認的各方——也就是最願意支付更高手續費的各方——是支付者。

出於這些技術和實際原因，在 Bitcoin 中，支付者支付交易手續費是慣例。也有例外，例如接受未確認交易的商家，以及不在簽署後立即廣播交易的協議（阻止支付者能夠為當前市場選擇適當的手續費）。我們稍後將探討這些((("交易手續費", "支付責任", startref="fees-responsibility")))例外。

=== 手續費和手續費率

每筆((("交易手續費", "手續費率", id="fees-rates")))((("手續費率", id="fee-rate")))交易只支付一筆手續費——無論交易有多大都無關緊要。但是，交易越大，礦工能夠在區塊中放入的交易就越少。因此，礦工評估交易的方式與您在市場上比較幾種等效商品時的方式相同：他們將價格除以數量。

您可能將幾種不同袋裝米的成本除以每袋的重量以找到每重量的最低價格（最划算），礦工將交易的手續費除以其大小（也稱為其權重）以找到每權重的最高手續費（最大收入）。在 Bitcoin 中，我們使用術語_手續費率_來表示交易的大小除以權重。由於 Bitcoin 多年來的變化，手續費率可以用不同的單位表示：

- BTC/Bytes（很少使用的舊單位）
- BTC/Kilobytes（很少使用的舊單位）
- BTC/Vbytes（很少使用）
- BTC/Kilo-vbyte（主要在 Bitcoin Core 中使用）
- Satoshi/Vbyte（今天最常用）
- Satoshi/Weight（今天也常用）

我們建議使用 sat/vbyte 或 sat/weight 單位來顯示手續費率。

[WARNING]
====
在((("荒謬手續費")))((("過高手續費")))((("交易手續費", "過度支付")))((("過度支付交易手續費")))接受手續費率輸入時要小心。如果使用者將以一種分母列印的手續費率複製並貼上到使用不同分母的欄位中，他們可能會多付 1,000 倍的手續費。如果他們改變分子，理論上他們可能會多付 100,000,000 倍。錢包應該讓使用者難以支付過高的手續費率，並可能希望提示使用者確認任何不是由錢包本身使用可信資料來源產生的手續費率。

過高的手續費，也稱為_荒謬手續費_，是指任何明顯高於手續費率估算器目前預期在下一個區塊中確認交易所需金額的手續費率。請注意，錢包不應完全阻止使用者選擇過高的手續費率——他們只應使意外使用此類手續費率變得困難。使用者在極少數情況下有合理的理由過度支付手續費。
====

=== 估算適當的手續費率

我們已經((("估算手續費率", id="estimate-fee-rate")))確定，如果您願意等待更長時間讓交易確認，您可以支付較低的手續費率，但例外情況是支付太低的手續費率可能導致您的交易永遠無法確認。由於手續費率是區塊空間公開拍賣中的出價，因此不可能完美預測您需要支付什麼手續費率才能在特定時間內確認交易。但是，我們可以根據其他交易在最近過去支付的手續費率產生粗略估計。

完整節點可以記錄其看到的每筆交易的三條資訊：它首次收到該交易的時間（區塊高度）、該交易確認時的區塊高度，以及該交易支付的手續費率。透過將在相似高度到達、在相似高度確認並支付相似手續費的交易組合在一起，我們可以計算確認支付特定手續費率的交易需要多少個區塊。然後，我們可以假設現在支付類似手續費率的交易將需要類似數量的區塊來確認。Bitcoin Core 包含一個使用這些原則的手續費率估算器，可以使用 `estimatesmartfee` RPC 呼叫，並帶有一個參數，指定您願意等待多少個區塊，交易才有很高的可能性確認（例如，144 個區塊約為 1 天）：

----
$ bitcoin-cli -named estimatesmartfee conf_target=144
{
  "feerate": 0.00006570,
  "blocks": 144
}
----

許多基於網路的服務也提供手續費估算作為 API。有關當前列表，請參見 https://oreil.ly/TB6IN。

如前所述，手續費率估算永遠無法完美。一個常見的問題是基本需求可能會改變，調整平衡點並將價格（手續費）提高到新高度或將其降低到最低值。如果手續費率下降，那麼先前支付正常手續費率的交易現在可能支付高手續費率，它將比預期更早確認。您無法降低已發送交易的手續費率，因此您只能支付更高的手續費率。但是，當手續費率上升時，需要有方法能夠提高這些交易的手續費率，這稱為_手續費提升_。Bitcoin 中有兩種常用的手續費提升類型，手續費替代（RBF）和子支付((("手續費率", startref="fee-rate")))((("交易手續費", "手續費率", startref="fees-rates")))父（CPFP）。

[[rbf]]
=== 手續費替代（RBF）手續費提升

要((("交易手續費", "手續費提升", "RBF (手續費替代)", id="transaction-fees-bump-rbf")))((("手續費提升", "RBF (手續費替代)", id="fee-bump-rbf")))((("RBF (手續費替代) 手續費提升", id="rbf-ch9")))使用 RBF 手續費提升來提高交易的手續費，您需要創建支付更高手續費的交易的衝突版本。如果兩筆或多筆交易((("衝突交易")))((("交易", "衝突"))被認為是_衝突交易_，則只有其中一筆可以包含在有效的區塊鏈中，迫使礦工只選擇其中一筆。當兩筆或多筆交易各自嘗試花費相同的 UTXO 之一時，即它們各自包含具有相同輸出點（對先前交易輸出的引用）的輸入時，就會發生衝突。

為了防止有人透過創建無限數量的衝突交易並透過中繼完整節點的網路發送它們來消耗大量頻寬，Bitcoin Core 和其他支援交易替換的完整節點要求每筆替換交易支付比被替換交易更高的手續費率。Bitcoin Core 目前還要求替換交易支付比原始交易更高的總手續費，但這一要求具有不良副作用，開發人員在撰寫本文時一直在尋找消除它的方法。

Bitcoin Core((("Bitcoin Core", "RBF 變體", id="bitcoin-core-rbf")))目前支援兩種 RBF 變體：

選擇性 RBF::
  未確認的交易可以向礦工和完整節點發出信號，表明交易的創建者希望允許它被更高手續費率版本替換。該信號及其使用規則在 BIP125 中指定。截至本文撰寫時，這已在 Bitcoin Core 中預設啟用多年。

完全 RBF::
  任何未確認的交易都可以被更高手續費率版本替換。截至本文撰寫時，這可以在 Bitcoin Core 中選擇性啟用（但預設情況下已禁用）。

.為什麼有兩種 RBF 變體？
****
兩種不同版本的 RBF 的原因是完全 RBF 一直存在爭議。早期版本的 Bitcoin 允許交易替換，但此行為在幾個版本中被禁用。在那段時間內，使用現在稱為 Bitcoin Core 的軟體的礦工或完整節點不會將他們收到的未確認交易的第一個版本替換為任何不同的版本。一些商家開始期待這種行為：他們假設任何支付適當手續費率的有效未確認交易最終都會成為已確認的交易，因此他們在收到此類未確認交易後不久就提供商品或服務。

然而，Bitcoin 協議無法保證任何未確認的交易最終都會被確認。如本章前面所述，每個礦工都可以自己選擇他們將嘗試確認哪些交易——包括這些交易的哪些版本。Bitcoin Core 是開源軟體，因此任何擁有其原始碼副本的人都可以添加（或刪除）交易替換。即使 Bitcoin Core 不是開源的，Bitcoin 也是一個開放協議，可以由具有足夠能力的程式設計師從頭開始重新實現，允許重新實現者包含或不包含交易替換。

交易替換打破了一些商家的假設，即每筆合理的未確認交易最終都會被確認。交易的替代版本可以支付與原始版本相同的輸出，但不需要支付任何這些輸出。如果未確認交易的第一個版本支付商家，則第二個版本可能不支付他們。如果商家根據第一個版本提供商品或服務，但第二個版本被確認，那麼商家將不會收到其成本的付款。

一些商家以及支持他們的人要求不要在 Bitcoin Core 中重新啟用交易替換。其他人指出，交易替換提供了好處，包括能夠提升最初支付太低手續費率的交易的手續費。

最終，致力於 Bitcoin Core 的開發人員實現了妥協：他們沒有允許每筆未確認的交易被替換（完全 RBF），而是僅對 Bitcoin Core 進行程式設計，以允許替換發出信號表明它們希望允許替換的交易（選擇性 RBF）。商家可以檢查他們收到的交易是否有選擇性信號，並以不同於沒有信號的交易的方式對待這些交易。

這並沒有改變根本問題：任何人仍然可以修改他們的 Bitcoin Core 副本，或創建重新實現，以允許完全 RBF——一些開發人員甚至這樣做了，但似乎很少有人使用他們的軟體。

幾年後，致力於 Bitcoin Core 的開發人員稍微改變了妥協。除了預設保留選擇性 RBF 之外，他們還添加了一個選項，允許使用者啟用完全 RBF。如果足夠的挖礦算力和中繼完整節點啟用此選項，則任何未確認的交易最終都可以被支付更高手續費率的版本替換。截至本文撰寫時，尚不清楚這是否已經((("Bitcoin Core", "RBF 變體", startref="bitcoin-core-rbf")))發生。
****

作為使用者，如果您計劃使用 RBF 手續費提升，您首先需要選擇支援它的錢包，例如在 https://oreil.ly/IhMzx 上列為具有「發送支援」的錢包之一。

作為開發人員，如果您計劃實現 RBF 手續費提升，您首先需要決定是執行選擇性 RBF 還是完全 RBF。在撰寫本文時，選擇性 RBF 是唯一確定可行的方法。即使完全 RBF 變得可靠，也可能會有幾年時間，選擇性交易的替換比完全 RBF 替換確認得稍快。如果您選擇選擇性 RBF，您的錢包將需要實現 BIP125 中指定的信號，這是對交易中任何一個序列欄位的簡單修改（請參見 <<sequence>>）。如果您選擇完全 RBF，則無需在交易中包含任何信號。與 RBF 相關的其他所有內容對於兩種方法都是相同的。

當您需要提升交易的手續費時，您只需創建一筆新交易，該交易花費至少與您想要替換的原始交易相同的 UTXO 之一。您可能希望在交易中保留支付接收者的相同輸出。您可以透過減少找零輸出的價值或向交易添加額外輸入來支付增加的手續費。開發人員應為使用者提供手續費提升介面，為他們完成所有這些工作，並簡單地詢問他們（或向他們建議）手續費率應該提高多少。

[WARNING]
====
在創建同一交易的多個替換時要非常小心。您必須確保交易的所有版本都相互衝突。如果它們不是所有衝突，則可能確認多個單獨的交易，導致您多付給接收者。例如：

- 交易版本 0 包含輸入 _A_。
- 交易版本 1 包含輸入 _A_ 和 _B_（例如，您必須添加輸入 _B_ 來支付額外的手續費）
- 交易版本 2 包含輸入 _B_ 和 _C_（例如，您必須添加輸入 _C_ 來支付額外的手續費，但 _C_ 足夠大，您不再需要輸入 _A_）。

在這種情況下，任何保存交易版本 0 的礦工都能夠確認它和交易版本 2。如果兩個版本都支付相同的接收者，他們將被支付兩次（礦工將從兩個單獨的交易中收到交易手續費）。

避免此問題的簡單方法是確保替換交易始終包含與交易的先前版本相同的所有輸入。
====

RBF 手續費提升相對於其他類型的手續費提升的優勢在於它可以非常有效地使用區塊空間。通常，替換交易與它替換的交易大小相同。即使它更大，它通常與使用者如果在第一時間支付增加的手續費率時會創建的交易大小相同。

RBF 手續費提升的根本缺點是它通常只能由交易的創建者執行——需要為交易提供簽章或其他認證資料的人或人們。例外情況是透過使用 sighash 標誌（請參見 <<sighash_types>>）設計為允許添加額外輸入的交易，但這會帶來自己的挑戰。一般來說，如果您是未確認交易的接收者，並且您想讓它更快（或完全）確認，您無法使用 RBF 手續費提升；您需要其他方法。

RBF 還有((("交易手續費", "手續費提升", "RBF (手續費替代)", startref="transaction-fees-bump-rbf")))((("手續費提升", "RBF (手續費替代)", startref="fee-bump-rbf")))((("RBF (手續費替代) 手續費提升", startref="rbf-ch9")))其他問題，我們將在 <<transaction_pinning>> 中探討。

[[cpfp]]
=== 子支付父（CPFP）手續費提升

任何((("交易手續費", "手續費提升", "CPFP (子支付父)", id="transaction-fees-bump-cpfp")))((("手續費提升", "CPFP (子支付父)", id="fee-bump-cpfp")))((("CPFP (子支付父) 手續費提升", id="cpfp-ch9")))收到未確認交易輸出的人都可以透過花費該輸出來激勵礦工確認該交易。您想要確認的交易稱為_父交易_。花費父交易輸出的交易稱為_子交易_。

正如我們在 <<outpoints>> 中學到的，已確認交易中的每個輸入都必須引用出現在區塊鏈中較早的交易的未花費輸出（無論是在同一區塊中較早還是在先前的區塊中）。這意味著想要確認子交易的礦工還必須確保其父交易已確認。如果父交易尚未確認，但子交易支付的手續費足夠高，礦工可以考慮在同一區塊中確認它們兩者是否有利可圖。

為了評估挖掘父交易和子交易的獲利能力，礦工將它們視為具有總大小和總手續費的_交易包_，從中可以將手續費除以大小來計算((("包手續費率")))_包手續費率_。然後，礦工可以按手續費率對他們知道的所有單獨交易和交易包進行排序，並將最高收入的交易包含在他們正在嘗試挖掘的區塊中，直到區塊中允許包含的最大大小（權重）。為了找到更多可能有利可圖的包，礦工可以評估跨多代的包（例如，將未確認的父交易與其子交易和孫交易組合在一起）。這被((("祖先手續費率挖掘")))((("CPFP (子支付父) 手續費提升", "祖先手續費率挖掘")))稱為_祖先手續費率挖掘_。

Bitcoin Core 多年來一直實現祖先手續費率挖掘，並且據信在撰寫本文時幾乎所有礦工都在使用它。這意味著錢包使用此功能透過使用子交易為其父交易支付手續費來提升傳入交易的手續費是切實可行的（CPFP）。

CPFP 相對於 RBF 有幾個優勢。任何收到交易輸出的人都可以使用 CPFP——包括支付的接收者和支付者（如果支付者包含了找零輸出）。它也不需要替換原始交易，這使得它對某些商家來說比 RBF 的干擾性更小。

與 RBF 相比，CPFP 的主要缺點是 CPFP 通常使用更多區塊空間。在 RBF 中，手續費提升交易通常與它替換的交易大小相同。在 CPFP 中，手續費提升會添加一個完全獨立的交易。使用額外的區塊空間需要支付超出手續費提升成本之外的額外手續費。

CPFP 存在幾個挑戰，其中一些我們將在 <<transaction_pinning>> 中探討。我們特別需要提到的另一個問題是最低中繼手續費率問題，這由((("交易手續費", "手續費提升", "CPFP (子支付父)", startref="transaction-fees-bump-cpfp")))((("手續費提升", "CPFP (子支付父)", startref="fee-bump-cpfp")))((("CPFP (子支付父) 手續費提升", startref="cpfp-ch9")))包中繼解決。

=== 包中繼

早期版本((("交易手續費", "包中繼", id="transaction-fee-package-relay")))((("包中繼", id="package-relay")))的 Bitcoin Core 對其記憶池（請參見 <<mempool>>）中儲存用於稍後中繼和挖掘的未確認交易數量沒有任何限制。當然，電腦有物理限制，無論是記憶體（RAM）還是磁碟空間——完整節點不可能儲存無限數量的未確認交易。後來的 Bitcoin Core 版本將記憶池的大小限制為大約可容納一天的交易量，僅儲存手續費率最高的交易或包。

這對大多數事情都非常有效，但它創建了一個依賴問題。為了計算交易包的手續費率，我們需要父交易和子交易——但如果父交易支付的手續費率不夠高，它將不會保留在節點的記憶池中。如果節點收到一筆子交易而沒有訪問其父交易的權限，它就無法對該交易做任何事情。

解決此問題的方法是能夠將交易作為包中繼，稱為_包中繼_，允許接收節點在對任何單獨交易進行操作之前評估整個包的手續費率。截至本文撰寫時，致力於 Bitcoin Core 的開發人員在實現包中繼方面取得了重大進展，並且在本書出版時可能會提供其有限的早期版本。

包中繼對於基於時間敏感的預簽交易的協議尤其重要，例如閃電網路（LN）。在非合作的情況下，一些預簽交易無法使用 RBF 進行手續費提升，迫使它們依賴於 CPFP。在這些協議中，某些交易也可能在需要廣播之前很久就創建了，這使得估算適當的手續費率實際上是不可能的。如果預簽交易支付的手續費率低於進入節點記憶池所需的金額，則無法使用子交易提升其手續費。如果這阻止交易及時確認，誠實的使用者可能會損失金錢。包中繼是解決這個關鍵問題的((("交易手續費", "包中繼", startref="transaction-fee-package-relay")))((("包中繼", startref="package-relay")))方案。

[[transaction_pinning]]
=== 交易固定

++++
<p class="fix_tracking">
儘管 RBF 和 CPFP 手續費提升在我們描述的基本情況下都有效，但與這兩種方法相關的規則旨在防止對礦工和中繼完整節點的拒絕服務攻擊。這些規則的一個不幸的副作用是，它們有時會阻止某人能夠使用手續費提升。使手續費提升交易變得不可能或困難稱為<em>交易固定</em>。</p>
++++

主要的((("交易手續費", "手續費提升", "交易固定", id="transaction-fee-bump-pin")))((("手續費提升", "交易固定", id="fee-bump-pin")))((("交易固定", id="transaction-pin")))((("RBF (手續費替代) 手續費提升", "交易固定", id="rbf-pin")))((("CPFP (子支付父) 手續費提升", "交易固定", id="cpfp-pin")))拒絕服務問題之一圍繞著交易關係的影響。每當交易的輸出被花費時，該交易的識別碼（txid）就會被子交易引用。但是，當交易被替換時，替換具有不同的 txid。如果該替換交易被確認，則其所有後代都不能包含在同一區塊鏈中。可以重新創建和重新簽署後代交易，但這並不保證會發生。這對 RBF 和 CPFP 有相關但不同的含義：

- 在 RBF 的上下文中，當 Bitcoin Core 接受替換交易時，它透過忘記原始交易和所有依賴於該原始交易的後代交易來保持簡單。為了確保礦工接受替換更有利可圖，Bitcoin Core 僅在替換交易支付的手續費多於所有將被遺忘的交易時才接受替換交易。
+
這種方法的缺點是 Alice 可以創建一筆支付 Bob 的小交易。然後 Bob 可以使用他的輸出創建一筆大的子交易。如果 Alice 然後想替換她的原始交易，她需要支付比她和 Bob 最初支付的更高的手續費。例如，如果 Alice 的原始交易約為 100 vbytes，Bob 的交易約為 100,000 vbytes，並且它們都使用相同的手續費率，Alice 現在需要支付超過她最初支付的 1,000 倍才能 RBF 手續費提升她的交易。

- 在 CPFP 的上下文中，每次節點考慮在區塊中包含一個包時，它必須從它想要為同一區塊考慮的任何其他包中刪除該包中的交易。例如，如果一筆子交易為 25 個祖先支付費用，並且這些祖先中的每一個都有 25 個其他子交易，那麼在區塊中包含該包需要更新大約 625 個包（25^2^）。同樣，如果從節點的記憶池中刪除具有 25 個後代的交易（例如因為被包含在區塊中），並且這些後代中的每一個都有 25 個其他祖先，則需要更新另外 625 個包。每次我們將參數加倍（例如，從 25 到 50），我們的節點需要執行的工作量就會翻兩番。
+
此外，如果交易的替代版本被挖掘，則交易及其所有後代對於長期保留在記憶池中並不有用——除非發生罕見的區塊鏈重組，否則這些交易現在都無法確認。Bitcoin Core 將從其記憶池中刪除當前區塊鏈上無法再確認的每筆交易。在最壞的情況下，這可能會浪費節點的大量頻寬，並可能被用來阻止交易正確傳播。
+
為了防止這些問題以及其他相關問題，Bitcoin Core 將父交易限制為在其記憶池中最多擁有 25 個祖先或後代，並將所有這些交易的總大小限制為 100,000 vbytes。這種方法的缺點是，如果交易已經有太多後代（或者它及其後代太大），則會阻止使用者創建 CPFP 手續費提升。

交易固定可能是偶然發生的，但它也代表了對多方時間敏感協議（如 LN）的嚴重漏洞。如果您的交易對手可以在截止日期之前阻止您的交易之一確認，他們可能能夠從您那裡竊取金錢。

協議開發人員多年來一直在努力緩解交易固定的問題。<<cpfp_carve_out>> 中描述了一個部分解決方案。已經提出了其他幾種解決方案，並且截至本文撰寫時，至少有一種解決方案正在積極((("交易手續費", "手續費提升", "交易固定", startref="transaction-fee-bump-pin")))((("手續費提升", "交易固定", startref="fee-bump-pin")))((("交易固定", startref="transaction-pin")))((("RBF (手續費替代) 手續費提升", "交易固定", startref="rbf-pin")))((("CPFP (子支付父) 手續費提升", "交易固定", startref="cpfp-pin")))((("交易手續費", "手續費提升", "CPFP 分割", id="transaction-fee-bump-carveout")))((("手續費提升", "CPFP 分割", id="fee-bump-carveout")))((("分割 (CPFP)", id="carveout")))((("CPFP (子支付父) 手續費提升", "分割", id="cpfp-carveout")))開發中——https://oreil.ly/300dv[暫時性錨點]。

[[cpfp_carve_out]]
=== CPFP 分割和錨點輸出

++++
<p class="fix_tracking2">
在 2018 年，致力於 LN 的開發人員遇到了一個問題。他們的協議使用需要來自兩個不同方的簽章的交易。任何一方都不想信任另一方，因此他們在協議中不需要信任的時候簽署交易，允許他們中的任何一方在稍後的時間（當另一方可能不想（或無法）履行其義務時）廣播這些交易之一。這種方法的問題在於，交易可能需要在未來的未知時間廣播，超出了任何合理估算交易適當手續費率的能力。</p>
++++

理論上，開發人員可以設計他們的交易以允許使用 RBF（使用特殊的 sighash 標誌）或 CPFP 進行手續費提升，但這兩個協議都容易受到交易固定的影響。鑑於所涉及的交易具有時間敏感性，允許交易對手使用交易固定來延遲交易的確認很容易導致惡意方可以用來從誠實方竊取金錢的可重複利用。

LN 開發人員 Matt Corallo 提出了一個解決方案：為 CPFP 手續費提升的規則提供特殊例外，稱為 _CPFP 分割_。CPFP 的正常規則禁止包含額外的後代，如果它會導致父交易擁有 26 個或更多後代，或者如果它會導致父交易及其所有後代的大小超過 100,000 vbytes。根據 CPFP 分割的規則，即使會超過其他限制，只要單個額外交易的大小最多為 1,000 vbytes，且是沒有未確認祖先的未確認交易的直接子交易，就可以將其添加到包中。

++++
<p class="fix_tracking">
例如，Bob 和 Mallory 共同簽署一筆交易，其中有兩個輸出，各給他們一個。Mallory 廣播該交易，並使用她的輸出附加 25 個子交易或總計 100,000 vbytes 大小的任何較小數量的子交易。如果沒有分割，Bob 將無法將另一個子交易附加到他的輸出以進行 CPFP 手續費提升。透過分割，只要他的子交易小於 1,000 vbytes（應該有足夠的空間），他就可以花費交易中屬於他的兩個輸出之一。</p>
++++

不允許使用 CPFP 分割超過一次，因此它僅適用於兩方協議。已經有提議將其擴展到涉及更多參與者的協議，但對此需求不大，開發人員專注於構建更通用的解決方案來解決交易固定攻擊。

截至本文撰寫時，大多數流行的 LN 實現使用稱為_錨點輸出_的交易模板，該模板旨在與 CPFP ((("錨點輸出 (CPFP)")))((("交易手續費", "手續費提升", "CPFP 分割", startref="transaction-fee-bump-carveout")))((("手續費提升", "CPFP 分割", startref="fee-bump-carveout")))((("分割 (CPFP)", startref="carveout")))((("CPFP (子支付父) 手續費提升", "分割", startref="cpfp-carveout")))分割一起使用。

=== 向交易添加手續費

交易的((("交易手續費", "找零輸出和")))((("找零輸出", "交易手續費和")))((("輸出", "交易手續費和")))((("輸入", "交易手續費和")))資料結構沒有手續費欄位。相反，手續費隱含為輸入總和與輸出總和之間的差額。在扣除所有輸出後從所有輸入中剩餘的任何多餘金額就是礦工收取的手續費：

[latexmath]
++++
\begin{equation}
{Fees = Sum(Inputs) - Sum(Outputs)}
\end{equation}
++++


這是交易的一個有點令人困惑的元素，也是需要理解的重要一點，因為如果您正在構建自己的交易，您必須確保不會因為輸入支出不足而無意中包含非常高的手續費。這意味著您必須計算所有輸入，如有必要，透過創建找零來實現，否則您最終會給礦工一筆非常大的小費！

例如，如果您花費 20 比特幣的 UTXO 進行 1 比特幣的支付，您必須包含 19 比特幣的找零輸出返回到您的錢包。否則，19 比特幣的「剩餘」將被計為交易手續費，並由在區塊中挖掘您的交易的礦工收取。儘管您會獲得優先處理並使礦工非常高興，但這可能不是您的本意。

[WARNING]
====
如果您在手動構建的交易中忘記添加找零輸出，您將把找零作為交易手續費支付。「不用找零！」可能不是您的本意。
====

[[fee_sniping]]
=== 時間鎖防禦手續費狙擊

手續費狙擊((("交易手續費", "手續費狙擊", id="transaction-fee-sniping")))((("手續費狙擊", id="fee-snipe")))((("時間鎖", "手續費狙擊和", id="timelock-fee-snipe")))((("鎖定時間", "手續費狙擊和", id="lock-time-fee-snipe")))是一種理論攻擊情境，其中試圖重寫過去區塊的礦工從未來區塊「狙擊」更高手續費的交易以最大化其[.keep-together]#獲利能力。#

例如，假設存在的最高區塊是區塊 #100,000。如果一些礦工不是試圖挖掘區塊 #100,001 來擴展鏈，而是試圖重新挖掘區塊 #100,000。這些礦工可以選擇在其候選區塊 #100,000 中包含任何有效交易（尚未被挖掘）。他們不必用相同的交易重新挖掘區塊。事實上，他們有動機選擇最有利可圖的（每 kB 最高手續費）交易包含在其區塊中。他們可以包含「舊」區塊 #100,000 中的任何交易，以及當前記憶池中的任何交易。本質上，當他們重新創建區塊 #100,000 時，他們可以選擇將交易從「現在」拉到重寫的「過去」。

今天，這種攻擊不是非常有利可圖，因為區塊補貼遠高於每個區塊的總手續費。但在未來的某個時候，交易手續費將佔獎勵的大部分（甚至是全部獎勵）。那時，這種情況變得不可避免。

幾個錢包透過創建帶有鎖定時間的交易來阻止手續費狙擊，該鎖定時間將這些交易限制為僅包含在下一個區塊或任何後續區塊中。在我們的情境中，我們的錢包會將其創建的任何交易的鎖定時間設定為 100,001。在正常情況下，此鎖定時間沒有效果——無論如何，交易只能包含在區塊 #100,001 中；這是下一個區塊。

但在重組攻擊下，礦工將無法從記憶池中提取高手續費交易，因為所有這些交易都將被時間鎖定到區塊 #100,001。他們只能使用當時有效的任何交易重新挖掘區塊 #100,000，本質上沒有獲得新的手續費。

這並不能完全防止手續費狙擊，但在某些情況下確實使其獲利較少，並且可以在區塊補貼下降時幫助保持 Bitcoin 網路的穩定性。我們建議所有錢包在不干擾錢包對鎖定時間欄位的其他使用時實現反手續費狙擊。

隨著 Bitcoin 繼續成熟，隨著補貼繼續下降，手續費對 Bitcoin 使用者變得越來越重要，無論是在他們日常使用中快速確認交易，還是在為礦工提供繼續用新的工作量證明保護 Bitcoin 交易的((("交易手續費", "手續費狙擊", startref="transaction-fee-sniping")))((("手續費狙擊", startref="fee-snipe")))((("時間鎖", "手續費狙擊和", startref="timelock-fee-snipe")))((("鎖定時間", "手續費狙擊和", startref="lock-time-fee-snipe")))動機方面。
